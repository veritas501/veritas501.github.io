<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="emmmm,本来想发bobao360上的，后来他说这文章之前已经有人翻译过几篇了，就不能发布。（摊手¯\(ツ)/¯那我就发在博客上好了。 当学习一波ptrace也是极好的。 一口气直接1~10发完（｀Δ´）！ （一）：准备工作（二）：断点（三）：内存和寄存器（四）：Elves 和 dwarves（五）：源码和信号（六）：源码级单步执行（七）：源码级断点（八）：栈卷回（九）：处理变量（十）：进阶话题">
<meta name="keywords" content="Ptrace">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻译】编写一个Linux 调试器 （一）~（十）">
<meta property="og:url" content="https://veritas501.github.io/2017/10/16/翻译_编写一个Linux调试器/index.html">
<meta property="og:site_name" content="Veritas501&#39;s Blog">
<meta property="og:description" content="emmmm,本来想发bobao360上的，后来他说这文章之前已经有人翻译过几篇了，就不能发布。（摊手¯\(ツ)/¯那我就发在博客上好了。 当学习一波ptrace也是极好的。 一口气直接1~10发完（｀Δ´）！ （一）：准备工作（二）：断点（三）：内存和寄存器（四）：Elves 和 dwarves（五）：源码和信号（六）：源码级单步执行（七）：源码级断点（八）：栈卷回（九）：处理变量（十）：进阶话题">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://img2.tan90.me/debugger_2_c1d8a1307d84d0de293a90b678d7f0ee.png">
<meta property="og:image" content="http://img2.tan90.me/ptrace_10_260e0e6cc5e29daf92c63851d919e8c2.png">
<meta property="og:updated_time" content="2018-09-20T06:34:26.422Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【翻译】编写一个Linux 调试器 （一）~（十）">
<meta name="twitter:description" content="emmmm,本来想发bobao360上的，后来他说这文章之前已经有人翻译过几篇了，就不能发布。（摊手¯\(ツ)/¯那我就发在博客上好了。 当学习一波ptrace也是极好的。 一口气直接1~10发完（｀Δ´）！ （一）：准备工作（二）：断点（三）：内存和寄存器（四）：Elves 和 dwarves（五）：源码和信号（六）：源码级单步执行（七）：源码级断点（八）：栈卷回（九）：处理变量（十）：进阶话题">
<meta name="twitter:image" content="http://img2.tan90.me/debugger_2_c1d8a1307d84d0de293a90b678d7f0ee.png">






  <link rel="canonical" href="https://veritas501.github.io/2017/10/16/翻译_编写一个Linux调试器/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【翻译】编写一个Linux 调试器 （一）~（十） | Veritas501's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Veritas501's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-guestbook">
    <a href="/Guestbook" rel="section">
      <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />Guestbook</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://veritas501.github.io/2017/10/16/翻译_编写一个Linux调试器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Veritas501">
      <meta itemprop="description" content="开始踏上Re&Pwn之路...">
      <meta itemprop="image" content="/images/215.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veritas501's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【翻译】编写一个Linux 调试器 （一）~（十）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-16T00:00:00+08:00">2017-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-09-20 14:34:26" itemprop="dateModified" datetime="2018-09-20T14:34:26+08:00">2018-09-20</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/16/翻译_编写一个Linux调试器/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count valine-comment-count" data-xid="/2017/10/16/翻译_编写一个Linux调试器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/16/翻译_编写一个Linux调试器/" class="leancloud_visitors" data-flag-title="【翻译】编写一个Linux 调试器 （一）~（十）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>emmmm,本来想发bobao360上的，后来他说这文章之前已经有人翻译过几篇了，就不能发布。（摊手¯\<em>(ツ)</em>/¯<br>那我就发在博客上好了。</p>
<p>当学习一波ptrace也是极好的。</p>
<p>一口气直接1~10发完（｀Δ´）！</p>
<p>（一）：准备工作<br>（二）：断点<br>（三）：内存和寄存器<br>（四）：Elves 和 dwarves<br>（五）：源码和信号<br>（六）：源码级单步执行<br>（七）：源码级断点<br>（八）：栈卷回<br>（九）：处理变量<br>（十）：进阶话题</p>
<a id="more"></a>
<hr>
<p>原文链接：<a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/" target="_blank" rel="noopener">https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/</a></p>
<p>作者：<a href="https://www.twitter.com/TartanLlama" target="_blank" rel="noopener">TartanLlama</a></p>
<p>译者：veritas501</p>
<hr>
<h1 id="（一）：准备工作"><a href="#（一）：准备工作" class="headerlink" title="（一）：准备工作"></a>（一）：准备工作</h1><p>任何一个写过比helloworld更加复杂的程序的人都应该已经使用过调试器了（如果你还没有用过，就放下你手头的事来学习一下吧）。然而，虽然这些工具被人们广泛使用，但目前却没有较多的资料（这些是一些已经公开的资料，如果你需要的话。<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1" target="_blank" rel="noopener">1</a> <a href="https://t-a-w.blogspot.co.uk/2007/03/how-to-code-debuggers.html" target="_blank" rel="noopener">2</a> <a href="https://www.codeproject.com/Articles/43682/Writing-a-basic-Windows-debugger" target="_blank" rel="noopener">3</a> <a href="http://system.joekain.com/debugger/" target="_blank" rel="noopener">4</a>）来告诉我们他们的工作原理以及如何编写一个调试器，尤其是与其他工具链（比如编译器）相比。在我的这一系列文章中，我们将学习调试器的原理以及如何自己编写一个调试器。</p>
<p>我们将会提供以下的功能：</p>
<ul>
<li>启动，暂停，继续执行</li>
<li>在不同地点设置断点<ul>
<li>内存地址</li>
<li>程序源码</li>
<li>函数入口点</li>
</ul>
</li>
<li>向内存或寄存器读取和写入值</li>
<li>单步执行<ul>
<li>指令</li>
<li>步入函数</li>
<li>跳出函数</li>
<li>跳过函数</li>
</ul>
</li>
<li>打印当前的代码地址</li>
<li>打印函数调用堆栈</li>
<li>打印变量的值</li>
</ul>
<p>在最后一章，我会指出如何添加以下功能：</p>
<ul>
<li>远程调试</li>
<li>共享库和动态加载</li>
<li>表达式执行</li>
<li>多线程调试</li>
</ul>
<p>在此项目中，我会把重点放在C和C++上，但它也同样能够工作在被编译成机器码且输出标准DWARF调试信息的其他语言上（如果你还不知道那是什么，不用担心，我们马上会说到）。此外，我只关注于如何让程序运行起来且在大多数情况下运行，因此为了简便，我将避开鲁棒的错误处理。</p>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在我们开始之前，我们先配置好环境。在这系列教程中，我将使用两个依赖工具：<a href="https://github.com/antirez/linenoise" target="_blank" rel="noopener">Linenoise</a>用于处理我们的命令行输入，<a href="https://github.com/TartanLlama/libelfin/tree/fbreg" target="_blank" rel="noopener">libelfin</a>则用于解析调试信息。你也可以使用传统的libdwarf 来替代libelfin，但是界面交互没有那么好，而且libelfin还提供了基本完备的DWARF 表达式执行器，能够在你需要读取变量值的时候节省大量时间。确认你使用的是我的fork的libelfin的fbreg分支，因为我对x86下的变量读取做了一些额外的支持。</p>
<p>一旦你在你的系统上安装或是在你喜欢的系统上编译好了这些依赖工具，我们就可以开始了。我在CMake文件中把它们设置为和我的其余一些代码一起编译。</p>
<hr>
<h2 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h2><p>在我们开始调试之前，我们需要启动被调试端（debugee），通过经典的fork/exec模式来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Program name not specified"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> prog = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//我们在子进程中</span></span><br><span class="line">        <span class="comment">//执行被调试端</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;= <span class="number">1</span>)  &#123;</span><br><span class="line">        <span class="comment">//我们在父进程中</span></span><br><span class="line">        <span class="comment">//执行调试器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们通过调用fork来将我们的程序分离成两个进程。如果我们在子进程中，fork会返回0；如果我们在父进程中，fork会返回子进程的pid。</p>
<p>如果我们在子进程中，我们希望他变成我们需要调试的程序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">execl(prog, prog, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>此处我们第一次遇到了<code>ptrace</code>，它将成为我们编写调试器过程中最好的伙伴。ptrace允许我们用过读取寄存器，内存，单步执行等方法来控制另一个进程。他的API非常简单，你需要提供一个枚举值给这个函数来指明你想进行的操作，后面的一些参数是使用还是被忽略取决于你所提供的值。下面是<code>ptrace</code>的原形：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>request是我们对被调试进程的操作；pid是被调试进程的进程ID；addr是一个内存地址，将在一些call中被用于指定被调试进程的地址；data与request的值有关；返回值一般是一些错误信息，因此你需要在你的代码中检测它。这里我为了简便就略过了，你可以通过查看ptrace的man手册来了解更多信息。</p>
<p>上面的代码中，我们使用的request是<code>PTRACE_TRACEME</code>。表示这个进程提出要求它的父进程来调试它。它的参数会被忽略因为API就是这样设计的。</p>
<p>接着，我们调用了execl，这是许多exec族函数中的一个。我们执行指定的程序，把他的名字作为命令行参数传递，并使用一个nullptr来终止这个列表。如果你需要，你可以传递其他执行你程序所需的参数。</p>
<p>当我们完成这些后，我们就完成了子进程的设置；在我们结束它之前它会一直运行下去。</p>
<hr>
<h2 id="添加调试器循环"><a href="#添加调试器循环" class="headerlink" title="添加调试器循环"></a>添加调试器循环</h2><p>现在我们已经启动了子进程，我们想要和它交互。因此，我们创建了debugger类，提供了一个循环来监听用户的输入，然后从父进程的main函数中启动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt;= <span class="number">1</span>)  &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    debugger dbg&#123;prog, pid&#125;;</span><br><span class="line">    dbg.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">debugger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    debugger (<span class="built_in">std</span>::<span class="built_in">string</span> prog_name, <span class="keyword">pid_t</span> pid)</span><br><span class="line">        : m_prog_name&#123;<span class="built_in">std</span>::move(prog_name)&#125;, m_pid&#123;pid&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_prog_name;</span><br><span class="line">    <span class="keyword">pid_t</span> m_pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在run函数中，我们需要一直等到子进程完成启动，然后从linenoise 中读取输入知道我们读到EOF（ctrl+d）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::run() &#123;</span><br><span class="line">    <span class="keyword">int</span> wait_status;</span><br><span class="line">    <span class="keyword">auto</span> options = <span class="number">0</span>;</span><br><span class="line">    waitpid(m_pid, &amp;wait_status, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* line = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>((line = linenoise(<span class="string">"minidbg&gt; "</span>)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        handle_command(line);</span><br><span class="line">        linenoiseHistoryAdd(line);</span><br><span class="line">        linenoiseFree(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当被调试进程启动完成，他将会发送<code>SIGTRAP</code> 信号，表示这是一个跟踪或是遇到断点。我们通过watpid函数来等待直到收到这个信号。</p>
<p>当我们知道这个进程准备好被调试后，我们监听用户的输入，linenoise 函数会自己显示一个提示符并处理用户的输入。这意味着我们不需要做太多工作就能拥有一个拥有历史记录和导航的命令行。当我们获取到用户输入后，我们把命令发送到相应的处理函数中（我们马上会看到），然后我们将这个命令添加到 linenoise 历史并释放资源。</p>
<hr>
<h2 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h2><p>我们的命令将和gdb和lldb保持相似。用户想要继续运行程序只需要输入continue或是cont或是c即可。如果他们想要在一个地址上设置断点，他们可以写break 0xDEADBEEF，0xDEADBEEF是用户期望的地址的16进制格式。让我们为这些命令添加支持。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::handle_command(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; line) &#123;</span><br><span class="line">    <span class="keyword">auto</span> args = split(line,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">auto</span> command = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_prefix(command, <span class="string">"continue"</span>)) &#123;</span><br><span class="line">        continue_execution();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unknown command\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>split 和is_prefix 是一对有用的小函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">char</span> delimiter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; out&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss &#123;s&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::getline(ss,item,delimiter)) &#123;</span><br><span class="line">        out.push_back(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; of)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() &gt; of.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::equal(s.begin(), s.end(), of.begin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为debugger类添加continue_execution 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::continue_execution() &#123;</span><br><span class="line">    ptrace(PTRACE_CONT, m_pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wait_status;</span><br><span class="line">    <span class="keyword">auto</span> options = <span class="number">0</span>;</span><br><span class="line">    waitpid(m_pid, &amp;wait_status, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，continue_execution 函数将使用ptrace来告知被调试进程继续执行，然后用waitpid函数直到它收到信号。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在应该有能力编译一些C或C++程序，通过调试器运行他们，看它能否停在入口点以及从调试中继续执行。在下一篇文章中，我们讲学习如何让我们的调试器设置断点，如果你遇到了任何问题，可以通过下面的评论告诉我。</p>
<p>你可以在<a href="https://github.com/TartanLlama/minidbg/tree/tut_setup" target="_blank" rel="noopener">这里</a>找到本文的代码。</p>
<hr>
<h1 id="（二）：断点"><a href="#（二）：断点" class="headerlink" title="（二）：断点"></a>（二）：断点</h1><p>第一部分中我们写了一个小型的进程启动器作为我们的调试器，在这一篇中，我们将学习在x86 linux下断点是如何运作的以及为我们的工具添加设置断点的功能。</p>
<hr>
<h2 id="断点是怎么形成的？"><a href="#断点是怎么形成的？" class="headerlink" title="断点是怎么形成的？"></a>断点是怎么形成的？</h2><p>断点的类型有两种：硬件断点和内存断点。硬件断点通常通过设置架构指定的寄存器来设置中断，而内存断点则是通过修改正在执行的代码来设置中断。这篇文章我们把精力集中在内存断点上，因为它们较为简单且没有数量限制。在x86上，你在同一时刻最多只能设置4个硬件断点，但它们不仅能在代码执行到此处的时候断下，还能在被读取或是被写入的时候触发。</p>
<p>前面说内存断点是通过修改当前正在执行的代码来实现的，那么问题是：</p>
<ul>
<li>我们如何修改代码？</li>
<li>如何修改代码才能设置断点？</li>
<li>如何让调试器注意到？</li>
</ul>
<p>第一个问题的答案很显然，<code>ptrace</code>。我们之前使用它来设置我们的程序来跟踪以及继续执行，但我们也可以使用它来读取和写入内存。</p>
<p>当执行到断点位置的时候，我们的修改要让处理器暂停并向调试器发送信号。在x86上这是通过将需要下断的地址上的指令设置为<code>int 3</code>来实现的。x86上有一个中断向量表（interrupt vector table），操作系统通过中断向量表能够为许多事件注册处理函数，比如缺页中断（page faults），保护错误（protection faults），无效操作码（invalid opcodes）等。它有点像注册错误的回调函数，但是在硬件层面实现的。当处理器执行到<code>int 3</code>指令是，控制权就被传递给了断点中断处理程序（breakpoint interrupt handler），就Linux来说，是给进程发送<code>SIGTRAP</code>信号。下图展现了这个过程，当把<code>mov</code>指令的第一个字节覆盖为<code>0xcc</code>，即<code>int 3</code>的机器码。</p>
<p><img src="http://img2.tan90.me/debugger_2_c1d8a1307d84d0de293a90b678d7f0ee.png" alt=""></p>
<p>最后一个问题是如何让调试器注意到这个中断。如果你还记得上一篇中我们使用<code>waitpid</code>函数来监听被调试端发送的信号的方法，我们在此处也可以用同样的方法来处理：设置断点，让程序继续执行，调用<code>waitpid</code>直到收到<code>SIGTRAP</code>信号。然后就可以通过打印当前代码的位置或改变图形界面中选中的行来将这个断点传达给用户。</p>
<hr>
<h2 id="实现内存断点"><a href="#实现内存断点" class="headerlink" title="实现内存断点"></a>实现内存断点</h2><p>我们实现一个<code>breakpoint</code>类来表现一个断点断在某个位置，然后根据需求选择启用或是停用这个断点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">breakpoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    breakpoint(<span class="keyword">pid_t</span> pid, <span class="built_in">std</span>::<span class="keyword">intptr_t</span> addr)</span><br><span class="line">        : m_pid&#123;pid&#125;, m_addr&#123;addr&#125;, m_enabled&#123;<span class="literal">false</span>&#125;, m_saved_data&#123;&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    auto is_enabled() const -&gt; bool &#123; return m_enabled; &#125;</span><br><span class="line">    auto get_address() const -&gt; std::intptr_t &#123; return m_addr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pid_t</span> m_pid;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">intptr_t</span> m_addr;</span><br><span class="line">    <span class="keyword">bool</span> m_enabled;</span><br><span class="line">    <span class="keyword">uint8_t</span> m_saved_data; <span class="comment">//存储断点地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些代码多数只是跟踪状态，真正实现部分在<code>enable</code>和<code>disable</code>函数中。</p>
<p>正如我们上面了解到的，我们需要将用户给定地址上的指令修改为<code>int 3</code>，即<code>0xcc</code>。我们还要保存那条指令原本的机器码，以便后续恢复这行代码。而且我们不能忘记去执行这行代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> breakpoint::enable() &#123;</span><br><span class="line">    <span class="keyword">auto</span> data = ptrace(PTRACE_PEEKDATA, m_pid, m_addr, <span class="literal">nullptr</span>);</span><br><span class="line">    m_saved_data = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data &amp; <span class="number">0xff</span>); <span class="comment">//保存最低一字节</span></span><br><span class="line">    <span class="keyword">uint64_t</span> int3 = <span class="number">0xcc</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> data_with_int3 = ((data &amp; ~<span class="number">0xff</span>) | int3); <span class="comment">//将最低一字节改为0xcc</span></span><br><span class="line">    ptrace(PTRACE_POKEDATA, m_pid, m_addr, data_with_int3);</span><br><span class="line"></span><br><span class="line">    m_enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PTRACE_PEEKDATA</code>这个request告诉<code>ptrace</code>如何去读取被调试程序的内存。我们传递给它一个pid和地址，然后它将指定地址上的64位长度的值返回给我们。 <code>(m_saved_data &amp; ~0xff)</code>将返回数据的最低字节置零，然后我们通过<code>OR</code>指令把<code>int 3</code>和最低字节置零的指令做或操作，从而得到能产生中断的指令。最后，我们通过<code>PTRACE_POKEDATA</code>将这条指令写入内存原位置来设置断点。</p>
<p><code>disable</code>比较简单，但也有点巧妙。因为<code>ptrace</code>的内存操作针对于words而不是一个字节，因此我们要先把words读回来，然后将最低一字节还原，再将words写回内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> breakpoint::disable() &#123;</span><br><span class="line">    <span class="keyword">auto</span> data = ptrace(PTRACE_PEEKDATA, m_pid, m_addr, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> restored_data = ((data &amp; ~<span class="number">0xff</span>) | m_saved_data);</span><br><span class="line">    ptrace(PTRACE_POKEDATA, m_pid, m_addr, restored_data);</span><br><span class="line"></span><br><span class="line">    m_enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="给调试器添加断点"><a href="#给调试器添加断点" class="headerlink" title="给调试器添加断点"></a>给调试器添加断点</h2><p>为了能通过用户界面设置断点，我们需要对debugger类做三处修改。</p>
<ol>
<li>为<code>debugger</code>添加断点数据储存结构体</li>
<li>添加一个<code>set_breakpoint_at_address</code>函数</li>
<li>给<code>handle_command</code>函数添加<code>break</code>指令</li>
</ol>
<p>我把断点存在<code>std::unordered_map&lt;std::intptr_t, breakpoint&gt;</code>类型的结构体中，因此能够简洁迅速地检测给定的地址上是否已经有断点，如果有就取回这个断点对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">debugger</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_breakpoint_at_address</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">intptr_t</span> addr)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="keyword">intptr_t</span>,breakpoint&gt; m_breakpoints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>set_breakpoint_at_address</code>函数中我们将创建一个新的断点，启用它，把它加入结构体中，并向用户打印一条信息。你喜欢的话可以将所有的信息取出然后就可以像一个命令行工具一样使用你的调试器。为了简洁，我把它们都整合到了一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::set_breakpoint_at_address(<span class="built_in">std</span>::<span class="keyword">intptr_t</span> addr) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Set breakpoint at address 0x"</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; addr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    breakpoint bp &#123;m_pid, addr&#125;;</span><br><span class="line">    bp.enable();</span><br><span class="line">    m_breakpoints[addr] = bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们在对命令处理程序做补充以便调用我们的新函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::handle_command(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; line) &#123;</span><br><span class="line">    <span class="keyword">auto</span> args = split(line,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">auto</span> command = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_prefix(command, <span class="string">"cont"</span>)) &#123;</span><br><span class="line">        continue_execution();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"break"</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> addr &#123;args[<span class="number">1</span>], <span class="number">2</span>&#125;; <span class="comment">//粗暴认定用户在地址前加了"0x"</span></span><br><span class="line">        set_breakpoint_at_address(<span class="built_in">std</span>::stol(addr, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unknown command\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我只是简单的删除了字符串中的前两个字符并对结果调用<code>std::stol</code>，你也可以在提高一下解析的鲁棒性。<code>std::stol</code>可以设置转换的基数，因此读入一个十六进制数据是很简单的。</p>
<hr>
<h2 id="从断点恢复执行"><a href="#从断点恢复执行" class="headerlink" title="从断点恢复执行"></a>从断点恢复执行</h2><p>如果你尝试从断点恢复执行，你会发现啥都没发生。这是因为断点依然存在于内存中，因此这个断点被重复命中。简单的解决方法是禁用它，单步，重新启用，然后恢复运行。但是此外我们还需要修改程序计数器（program counter）指到断点的前面。因此我打算把这个留到下一篇讲解完寄存器的操作后在做介绍。</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>当然，如果我们不知道把断点设置在什么位置，那这个功能并非很有用。以后我们会给调试器添加通过函数名或是源码行设置断点的方法，但现在我们只能时候来实现这一点。</p>
<p>为测试你的调试器，最简单的方法是写一个helloworld程序并通过<code>std::cerr</code>输出（避免缓存），并在输出的call上设置一个断点。如果你对被调试端使用continue，程序会断下并没有任何输出。你可以重启程序并在输出call的后面设置断点，然后你会看到成功的输出了消息。</p>
<p>找到这个地址的其中一个方法是使用<code>objdump</code>。如果你打开一个终端并执行 <code>objdump -d &lt;your program&gt;</code>，你应该会看到程序的反汇编代码。接着你就能找到<code>main</code>函数并定位到你想要设置断点的<code>call</code>指令。例如现在我编一个helloworld程序，对他反汇编，并得到了<code>main</code>函数的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400936</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">400936</span>:	<span class="number">55</span>                   	push   rbp</span><br><span class="line">  <span class="number">400937</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    rbp,rsp</span><br><span class="line">  <span class="number">40093</span>a:	be <span class="number">35</span> <span class="number">0</span>a <span class="number">40</span> <span class="number">00</span>       	mov    esi,<span class="number">0x400a35</span></span><br><span class="line">  <span class="number">40093f</span>:	bf <span class="number">60</span> <span class="number">10</span> <span class="number">60</span> <span class="number">00</span>       	mov    edi,<span class="number">0x601060</span></span><br><span class="line">  <span class="number">400944</span>:	e8 d7 fe ff ff       	call   <span class="number">400820</span> &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;</span><br><span class="line">  <span class="number">400949</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    eax,<span class="number">0x0</span></span><br><span class="line">  <span class="number">40094</span>e:	<span class="number">5</span>d                   	pop    rbp</span><br><span class="line">  <span class="number">40094f</span>:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>就如你所见的那样，如果想要没有输出，我们要将断点设置在<code>0x400944</code>；想要看到输出就要在<code>0x400949</code>处设置断点。</p>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>你现在有了一个能启动程序并设置断点的调试器。下一次我们将添加对内存和寄存器进行读写的功能。如果你有任何问题，请在博客下面留言。</p>
<p>你可以在 <a href="https://github.com/TartanLlama/minidbg/tree/tut_break" target="_blank" rel="noopener">这里</a>找到本文的代码。</p>
<hr>
<h1 id="（三）：内存和寄存器"><a href="#（三）：内存和寄存器" class="headerlink" title="（三）：内存和寄存器"></a>（三）：内存和寄存器</h1><p>在上一篇文章中，我们给调试器添加了简单的断点功能。这一次，我们将添加对寄存器和内存的读写能力，这使得我们随意修改PC指针，观察当前的状态和改变程序的行为。</p>
<hr>
<h2 id="注册我们的寄存器"><a href="#注册我们的寄存器" class="headerlink" title="注册我们的寄存器"></a>注册我们的寄存器</h2><p>在我们开始读取寄存器值之前，我们需要告诉调试器一些关于我们目标的信息，这里是x86_64平台。除了一系列通用和专用的寄存器外，x86_64还拥有浮点寄存器和向量寄存器。为了简洁，我将跳过最后两种，但如果你喜欢你也可以选择对它们提供支持。x86_64同样允许你像32,16,8位寄存器那样操作64位寄存器，但我只专注于64位。处于简化，对每一个寄存器我们只需要它的名称、他的DWARF寄存器编号以及它在<code>ptrace</code>返回的结构体中的储存位置。我选择使用范围枚举引用这些寄存器，然后我列出一个全局寄存器描述数组，其中元素的顺序和它在<code>ptrace</code>寄存器结构体的中顺序相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">reg</span> &#123;</span></span><br><span class="line">    rax, rbx, rcx, rdx,</span><br><span class="line">    rdi, rsi, rbp, rsp,</span><br><span class="line">    r8,  r9,  r10, r11,</span><br><span class="line">    r12, r13, r14, r15,</span><br><span class="line">    rip, rflags,    cs,</span><br><span class="line">    orig_rax, fs_base,</span><br><span class="line">    gs_base,</span><br><span class="line">    fs, gs, ss, ds, es</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> n_registers = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_descriptor</span> &#123;</span></span><br><span class="line">    reg r;</span><br><span class="line">    <span class="keyword">int</span> dwarf_r;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;reg_descriptor, n_registers&gt; g_register_descriptors &#123;&#123;</span><br><span class="line">    &#123; reg::r15, <span class="number">15</span>, <span class="string">"r15"</span> &#125;,</span><br><span class="line">    &#123; reg::r14, <span class="number">14</span>, <span class="string">"r14"</span> &#125;,</span><br><span class="line">    &#123; reg::r13, <span class="number">13</span>, <span class="string">"r13"</span> &#125;,</span><br><span class="line">    &#123; reg::r12, <span class="number">12</span>, <span class="string">"r12"</span> &#125;,</span><br><span class="line">    &#123; reg::rbp, <span class="number">6</span>, <span class="string">"rbp"</span> &#125;,</span><br><span class="line">    &#123; reg::rbx, <span class="number">3</span>, <span class="string">"rbx"</span> &#125;,</span><br><span class="line">    &#123; reg::r11, <span class="number">11</span>, <span class="string">"r11"</span> &#125;,</span><br><span class="line">    &#123; reg::r10, <span class="number">10</span>, <span class="string">"r10"</span> &#125;,</span><br><span class="line">    &#123; reg::r9, <span class="number">9</span>, <span class="string">"r9"</span> &#125;,</span><br><span class="line">    &#123; reg::r8, <span class="number">8</span>, <span class="string">"r8"</span> &#125;,</span><br><span class="line">    &#123; reg::rax, <span class="number">0</span>, <span class="string">"rax"</span> &#125;,</span><br><span class="line">    &#123; reg::rcx, <span class="number">2</span>, <span class="string">"rcx"</span> &#125;,</span><br><span class="line">    &#123; reg::rdx, <span class="number">1</span>, <span class="string">"rdx"</span> &#125;,</span><br><span class="line">    &#123; reg::rsi, <span class="number">4</span>, <span class="string">"rsi"</span> &#125;,</span><br><span class="line">    &#123; reg::rdi, <span class="number">5</span>, <span class="string">"rdi"</span> &#125;,</span><br><span class="line">    &#123; reg::orig_rax, <span class="number">-1</span>, <span class="string">"orig_rax"</span> &#125;,</span><br><span class="line">    &#123; reg::rip, <span class="number">-1</span>, <span class="string">"rip"</span> &#125;,</span><br><span class="line">    &#123; reg::cs, <span class="number">51</span>, <span class="string">"cs"</span> &#125;,</span><br><span class="line">    &#123; reg::rflags, <span class="number">49</span>, <span class="string">"eflags"</span> &#125;,</span><br><span class="line">    &#123; reg::rsp, <span class="number">7</span>, <span class="string">"rsp"</span> &#125;,</span><br><span class="line">    &#123; reg::ss, <span class="number">52</span>, <span class="string">"ss"</span> &#125;,</span><br><span class="line">    &#123; reg::fs_base, <span class="number">58</span>, <span class="string">"fs_base"</span> &#125;,</span><br><span class="line">    &#123; reg::gs_base, <span class="number">59</span>, <span class="string">"gs_base"</span> &#125;,</span><br><span class="line">    &#123; reg::ds, <span class="number">53</span>, <span class="string">"ds"</span> &#125;,</span><br><span class="line">    &#123; reg::es, <span class="number">50</span>, <span class="string">"es"</span> &#125;,</span><br><span class="line">    &#123; reg::fs, <span class="number">54</span>, <span class="string">"fs"</span> &#125;,</span><br><span class="line">    &#123; reg::gs, <span class="number">55</span>, <span class="string">"gs"</span> &#125;,</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你想亲自查看，你可以在<code>/usr/include/sys/user.h</code>里找到这个寄存器数据结构体（user_regs_struct ）。DWARF寄存器编号来自<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf" target="_blank" rel="noopener">System V x86_64 ABI</a>。</p>
<p>现在我们可以编写一堆函数来与寄存器做交互。我们想要从寄存器中读取和写入值，根据DWARF寄存器编号获取值，以及通过名称查找寄存器，反之亦然。让我们先实现<code>get_register_value</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> get_register_value(<span class="keyword">pid_t</span> pid, reg r) &#123;</span><br><span class="line">    user_regs_struct regs;</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">nullptr</span>, &amp; regs);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ptrace</code>再次使我们轻松地获取到了我们想得到的值。我们只需构造一个<code>user_regs_struct</code> 的实例，并把它和<code>PTRACE_GETREGS</code> request传递给<code>ptrace</code>。</p>
<p>现在我们根据需求读取<code>regs</code>。我们可以写一个巨大的switch语句，因为我们的<code>g_register_descriptors</code>表的布局和 <code>user_regs_struct</code>相同，所以我们只需搜索寄存器描述符的索引，然后把 <code>user_regs_struct</code> 作为一个<code>uint64_t</code>的数组来操作即可（你也可以重拍<code>reg</code>枚举变量并用索引把他们转换成底层类型，但我第一次就是用这种方式写的，他能正常运作，我就懒得改了。）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(begin(g_register_descriptors), end(g_register_descriptors),</span><br><span class="line">                       [r](<span class="keyword">auto</span>&amp;&amp; rd) &#123; <span class="keyword">return</span> rd.r == r; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>*&gt;(&amp; regs) + (it - begin(g_register_descriptors)));</span><br></pre></td></tr></table></figure>
<p>将<code>regs</code>转换成 <code>uint64_t</code>类型是安全的，因为<code>user_regs_struct</code>是一个标准的布局类型。但我认为指针运算在技术上是未定义的行为（UB）。当前没有一个编译器对此发出警告而且我很懒，如果你想保证代码严格正确，就写一个大的switch语句吧。</p>
<p><code>set_register_value</code>非常类似，我们只需写入相应的地址并在最后写回寄存器中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_register_value</span><span class="params">(<span class="keyword">pid_t</span> pid, reg r, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">    user_regs_struct regs;</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">nullptr</span>, &amp; regs);</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(begin(g_register_descriptors), end(g_register_descriptors),</span><br><span class="line">                           [r](<span class="keyword">auto</span>&amp;&amp; rd) &#123; <span class="keyword">return</span> rd.r == r; &#125;);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>*&gt;(&amp;regs) + (it - begin(g_register_descriptors))) = value;</span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">nullptr</span>, &amp; regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是通过DWARF寄存器编号进行寻找。这一次我会进行一些错误检查以防得到一些奇怪的DWARF 信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> get_register_value_from_dwarf_register (<span class="keyword">pid_t</span> pid, <span class="keyword">unsigned</span> regnum) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(begin(g_register_descriptors), end(g_register_descriptors),</span><br><span class="line">                           [regnum](<span class="keyword">auto</span>&amp;&amp; rd) &#123; <span class="keyword">return</span> rd.dwarf_r == regnum; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (it == end(g_register_descriptors)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range&#123;<span class="string">"Unknown dwarf register"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_register_value(pid, it-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即将完工，现在我们已经有了寄存器名称查找功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_register_name</span><span class="params">(reg r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(begin(g_register_descriptors), end(g_register_descriptors),</span><br><span class="line">                           [r](<span class="keyword">auto</span>&amp;&amp; rd) &#123; <span class="keyword">return</span> rd.r == r; &#125;);</span><br><span class="line">    <span class="keyword">return</span> it-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reg <span class="title">get_register_from_name</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(begin(g_register_descriptors), end(g_register_descriptors),</span><br><span class="line">                           [name](<span class="keyword">auto</span>&amp;&amp; rd) &#123; <span class="keyword">return</span> rd.name == name; &#125;);</span><br><span class="line">    <span class="keyword">return</span> it-&gt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我会添加一个简单的帮助函数把所有寄存器的内容导出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::dump_registers() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rd : g_register_descriptors) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd.name &lt;&lt; <span class="string">" 0x"</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'0'</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">16</span>) &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; get_register_value(m_pid, rd.r) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，iostreams有简洁的接口来清晰地输出16进制数据。</p>
<p>这足够让我们在调试器的余下部分中轻松处理寄存器，因此我们现在可以加上UI界面了。</p>
<hr>
<h2 id="显示寄存器"><a href="#显示寄存器" class="headerlink" title="显示寄存器"></a>显示寄存器</h2><p>我们所要做的就是为<code>handle_command</code>函数添加一个新的命令。通过下面的代码，用户就能输入诸如 <code>register read rax</code>, <code>register write rax 0x42</code> 的命令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (is_prefix(command, <span class="string">"register"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prefix(args[<span class="number">1</span>], <span class="string">"dump"</span>)) &#123;</span><br><span class="line">        dump_registers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_prefix(args[<span class="number">1</span>], <span class="string">"read"</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_register_value(m_pid, get_register_from_name(args[<span class="number">2</span>])) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_prefix(args[<span class="number">1</span>], <span class="string">"write"</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> val &#123;args[<span class="number">3</span>], <span class="number">2</span>&#125;; <span class="comment">//假定输入格式为0xVAL</span></span><br><span class="line">        set_register_value(m_pid, get_register_from_name(args[<span class="number">2</span>]), <span class="built_in">std</span>::stol(val, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="接下来干什么？"><a href="#接下来干什么？" class="headerlink" title="接下来干什么？"></a>接下来干什么？</h2><p>当我们设置断点的时候，我们已经读取并写入内存了。因此我们只需要添加一些函数来包装<code>ptrace</code>的这些功能即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> debugger::read_memory(<span class="keyword">uint64_t</span> address) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptrace(PTRACE_PEEKDATA, m_pid, address, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> debugger::write_memory(<span class="keyword">uint64_t</span> address, <span class="keyword">uint64_t</span> value) &#123;</span><br><span class="line">    ptrace(PTRACE_POKEDATA, m_pid, address, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能想实现一次读写多个字节，你可以通过每次递增地址来读取下一个字节。如果你喜欢，你也可以使用<code>process_vm_readv</code> 和 <code>process_vm_writev</code>(<a href="http://man7.org/linux/man-pages/man2/process_vm_readv.2.html" target="_blank" rel="noopener">link</a>) 或 <code>/proc/&lt;pid&gt;/mem</code> 来代替 <code>ptrace</code>。</p>
<p>现在我们给UI添加一些命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"memory"</span>)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> addr &#123;args[<span class="number">2</span>], <span class="number">2</span>&#125;; <span class="comment">//假定输入为0xADDRESS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_prefix(args[<span class="number">1</span>], <span class="string">"read"</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; read_memory(<span class="built_in">std</span>::stol(addr, <span class="number">0</span>, <span class="number">16</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_prefix(args[<span class="number">1</span>], <span class="string">"write"</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> val &#123;args[<span class="number">3</span>], <span class="number">2</span>&#125;; <span class="comment">//假定输入为0xVAL</span></span><br><span class="line">        write_memory(<span class="built_in">std</span>::stol(addr, <span class="number">0</span>, <span class="number">16</span>), <span class="built_in">std</span>::stol(val, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="给-continue-execution-做修补"><a href="#给-continue-execution-做修补" class="headerlink" title="给 continue_execution 做修补"></a>给 continue_execution 做修补</h2><p>在我们对测试更改前，我们现在可以实现一个更健全的<code>continue_execution</code>。由于我们可以获取PC指针，我们可以检查我们的断点表来判断我们是否在一个断点上。如果是，我们可以停用断点并在继续之前单步跳过。</p>
<p>首先为了阐明清晰，我们添加一些帮助函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> debugger::get_pc() &#123;</span><br><span class="line">    <span class="keyword">return</span> get_register_value(m_pid, reg::rip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> debugger::set_pc(<span class="keyword">uint64_t</span> pc) &#123;</span><br><span class="line">    set_register_value(m_pid, reg::rip, pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以写一个函数来步过断点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::step_over_breakpoint() &#123;</span><br><span class="line">    <span class="comment">// - 1 是因为执行是跳过了断点</span></span><br><span class="line">    <span class="keyword">auto</span> possible_breakpoint_location = get_pc() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_breakpoints.count(possible_breakpoint_location)) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; bp = m_breakpoints[possible_breakpoint_location];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bp.is_enabled()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> previous_instruction_address = possible_breakpoint_location;</span><br><span class="line">            set_pc(previous_instruction_address);</span><br><span class="line"></span><br><span class="line">            bp.disable();</span><br><span class="line">            ptrace(PTRACE_SINGLESTEP, m_pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            wait_for_signal();</span><br><span class="line">            bp.enable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们检测当前PC所指代码时候已经被设置断点，如果是，我们先把PC改到断点前一句，禁用断点后再步过原来的指令，在重新启用它。</p>
<p><code>wait_for_signal</code> 封装了我们常用的<code>waitpid</code>模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::wait_for_signal() &#123;</span><br><span class="line">    <span class="keyword">int</span> wait_status;</span><br><span class="line">    <span class="keyword">auto</span> options = <span class="number">0</span>;</span><br><span class="line">    waitpid(m_pid, &amp;wait_status, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们重写 <code>continue_execution</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::continue_execution() &#123;</span><br><span class="line">    step_over_breakpoint();</span><br><span class="line">    ptrace(PTRACE_CONT, m_pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    wait_for_signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>现在我们可以读取和修改寄存器，我们可以对helloworld程序做些事情。第一个测试，尝试在一个call上再次设置断点并继续执行。你应该会看到程序打印出<code>Hello world</code>。有趣的部分，在输出的call后面设置断点，然后将<code>rip</code>改到call的参数设置处并继续，你应该会看到程序打印出<code>Hello world</code>。以防你不知道在哪里设置断点，这里是我上一篇中<code>objdump</code>的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400936 &lt;main&gt;:</span><br><span class="line">  400936:	55                   	push   rbp</span><br><span class="line">  400937:	48 89 e5             	mov    rbp,rsp</span><br><span class="line">  40093a:	be 35 0a 40 00       	mov    esi,0x400a35</span><br><span class="line">  40093f:	bf 60 10 60 00       	mov    edi,0x601060</span><br><span class="line">  400944:	e8 d7 fe ff ff       	call   400820 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;</span><br><span class="line">  400949:	b8 00 00 00 00       	mov    eax,0x0</span><br><span class="line">  40094e:	5d                   	pop    rbp</span><br><span class="line">  40094f:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>为正确设置<code>esi</code>和<code>edi</code>寄存器，你需要把PC指针设置到<code>0x40093a</code>。</p>
<p>在下一篇文章中，我们将第一次接触到DWARF信息并为我们的调试器增添一系列单步调试的功能。这样我们就有了一个能单步执行代码，在想要的地方设置断点，修改数据等等功能的调试器了。</p>
<p>和之前一样，如果你有任何问题欢迎在我博客下面评论！</p>
<p>你可以在<a href="https://github.com/TartanLlama/minidbg/tree/tut_registers" target="_blank" rel="noopener">这里</a>找到本文的代码。</p>
<hr>
<p>#（四）：Elves 和 dwarves</p>
<p>到现在为止，我们已经对dwarves有所耳闻，它是一种调试信息，一种理解源码而不用分析它的的方式。今天我们来介绍关于源码级调试的详细信息，以便后续教程中对它的使用。</p>
<hr>
<h2 id="ELF-和-DWARF简介"><a href="#ELF-和-DWARF简介" class="headerlink" title="ELF 和 DWARF简介"></a>ELF 和 DWARF简介</h2><p>ELF和DWARF这两种组件你或许没听说过，但你可能已经使用过了。ELF(Executable and Linkable Format)是Linux中最广泛使用的一种文件格式。它指定了binary中不同部分的储存方式，例如代码，静态数据，调试信息和字符串。他还告诉loader如何获取二进制并准备执行，这涉及到二进制的不同部分应该放在内存的什么位置，哪些比特需要根据其他组件（重定位）等的位置来进行修复。我们在文章中对ELF介绍过多，如果你感兴趣你可以看一下<a href="https://github.com/corkami/pics/raw/master/binary/elf101/elf101-64.pdf" target="_blank" rel="noopener">这个漂亮的图表</a>或<a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" target="_blank" rel="noopener">相关标准</a>。</p>
<p>DWARF是ELF中最常用的调试信息格式。它并不只限于ELF，但是它们两相互促进，一起工作的很好。这种格式允许编译器告诉调试器binary中待执行的部分在源码中的什么位置。这些信息在不同的ELF节中不同，每一部分都有自己的信息来中继。下面是定义的不同节，虽有些过时但信息很具体<a href="http://www.dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf" target="_blank" rel="noopener">DWARF调试格式介绍</a>：</p>
<ul>
<li><code>.debug_abbrev</code> 是在<code>.debug_info</code> 节中使用的缩写</li>
<li><code>.debug_aranges</code> 内存地址和编译间的映射</li>
<li><code>.debug_frame</code> Call Frame的信息</li>
<li><code>.debug_info</code> 是DWARF数据的核心，包含了DWARF信息的条目（DWARF Information Entries （DIEs））</li>
<li><code>.debug_line</code> 程序的行号</li>
<li><code>.debug_loc</code> 位置描述</li>
<li><code>.debug_macinfo</code> 宏描述</li>
<li><code>.debug_pubnames</code> 全局对象和函数的查找表</li>
<li><code>.debug_pubtypes</code> 全局类型的查找表</li>
<li><code>.debug_ranges</code> DIEs引用的地址范围</li>
<li><code>.debug_str</code> 是<code>.debug_info</code>使用的字符串表</li>
<li><code>.debug_types</code> 类型描述</li>
</ul>
<p>我们最感兴趣的是<code>.debug_line</code> 和<code>.debug_info</code>节，所以让我们看一下一个简单的程序的DWARF信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> c = a + b;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="DWARF-行号表"><a href="#DWARF-行号表" class="headerlink" title="DWARF 行号表"></a>DWARF 行号表</h2><p>如果你用<code>-g</code>选项来编译这个程序并对编译结果使用<code>dwarfdump</code>，你就会看到line number section的样子类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.debug_line: line number info for a single cu</span><br><span class="line">Source lines (from CU-DIE at .debug_info offset 0x0000000b):</span><br><span class="line"></span><br><span class="line">            NS new statement, BB new basic block, ET end of text sequence</span><br><span class="line">            PE prologue end, EB epilogue begin</span><br><span class="line">            IS=val ISA number, DI=val discriminator value</span><br><span class="line">&lt;pc&gt;        [lno,col] NS BB ET PE EB IS= DI= uri: &quot;filepath&quot;</span><br><span class="line">0x00400670  [   1, 0] NS uri: &quot;/home/simon/play/MiniDbg/examples/variable.cpp&quot;</span><br><span class="line">0x00400676  [   2,10] NS PE</span><br><span class="line">0x0040067e  [   3,10] NS</span><br><span class="line">0x00400686  [   4,14] NS</span><br><span class="line">0x0040068a  [   4,16]</span><br><span class="line">0x0040068e  [   4,10]</span><br><span class="line">0x00400692  [   5, 7] NS</span><br><span class="line">0x0040069a  [   6, 1] NS</span><br><span class="line">0x0040069c  [   6, 1] NS ET</span><br></pre></td></tr></table></figure>
<p>前面几行是一些关于如何理解dump内容的信息，主要的行号数据从<code>0x00400670</code>开始。本质上这将代码的内存地址与文件中的行号建立映射。<code>NS</code>表示地址标记着新语句的开始，这通常用于设置断点或单步执行。<code>PE</code>表示函数序言（function prologue）的结束，这对这只函数入口断点很有帮助。<code>ET</code>表示转换单元的结束。信息实际上并不像这样编码，真正的编码是一种非常节省空间，且可以通过执行它来建立这些行信息的排序程序。</p>
<p>假设我们想在<code>variable.cpp</code>的第四行设置断点，我们该怎么做？我们先查找和该文件对应的条目，然后寻找对应的行条目，寻找对应的地址，然后在那里设置断点。在这个例子中，这条条目是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00400686  [   4,14] NS</span><br></pre></td></tr></table></figure>
<p>我们想在<code>0x00400686</code>处设置断点。如果你想尝试你可以手动在已经编写好的调试器上尝试。</p>
<p>反过来也是这样。如果我们有一个内存地址，比如一个PC指针，我们想要找到它在源码中所对应的位置，我们只需从行号表中查找最接近的映射地址并将行号取出来。</p>
<hr>
<h2 id="DWARF调试信息"><a href="#DWARF调试信息" class="headerlink" title="DWARF调试信息"></a>DWARF调试信息</h2><p><code>.debug_info</code>节是DWARF的核心。它提供了类型，函数，变量的信息。这个节中最基本的单元是DWARF 信息条目（DWARF Information Entry），简称DIE。一个 DIE 包括一个能告诉你正在展现什么样的源码级实体的标签，后面跟着一系列该实体的属性。这是我上面展示的简单事例程序的 <code>.debug_info</code> 部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">.debug_info</span><br><span class="line"></span><br><span class="line">COMPILE_UNIT&lt;header overall offset = 0x00000000&gt;:</span><br><span class="line">&lt; 0&gt;&lt;0x0000000b&gt;  DW_TAG_compile_unit</span><br><span class="line">                    DW_AT_producer              clang version 3.9.1 (tags/RELEASE_391/final)</span><br><span class="line">                    DW_AT_language              DW_LANG_C_plus_plus</span><br><span class="line">                    DW_AT_name                  /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                    DW_AT_stmt_list             0x00000000</span><br><span class="line">                    DW_AT_comp_dir              /super/secret/path/MiniDbg/build</span><br><span class="line">                    DW_AT_low_pc                0x00400670</span><br><span class="line">                    DW_AT_high_pc               0x0040069c</span><br><span class="line"></span><br><span class="line">LOCAL_SYMBOLS:</span><br><span class="line">&lt; 1&gt;&lt;0x0000002e&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_low_pc                0x00400670</span><br><span class="line">                      DW_AT_high_pc               0x0040069c</span><br><span class="line">                      DW_AT_frame_base            DW_OP_reg6</span><br><span class="line">                      DW_AT_name                  main</span><br><span class="line">                      DW_AT_decl_file             0x00000001 /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br><span class="line">                      DW_AT_type                  &lt;0x00000077&gt;</span><br><span class="line">                      DW_AT_external              yes(1)</span><br><span class="line">&lt; 2&gt;&lt;0x0000004c&gt;      DW_TAG_variable</span><br><span class="line">                        DW_AT_location              DW_OP_fbreg -8</span><br><span class="line">                        DW_AT_name                  a</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000002</span><br><span class="line">                        DW_AT_type                  &lt;0x0000007e&gt;</span><br><span class="line">&lt; 2&gt;&lt;0x0000005a&gt;      DW_TAG_variable</span><br><span class="line">                        DW_AT_location              DW_OP_fbreg -16</span><br><span class="line">                        DW_AT_name                  b</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000003</span><br><span class="line">                        DW_AT_type                  &lt;0x0000007e&gt;</span><br><span class="line">&lt; 2&gt;&lt;0x00000068&gt;      DW_TAG_variable</span><br><span class="line">                        DW_AT_location              DW_OP_fbreg -24</span><br><span class="line">                        DW_AT_name                  c</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000004</span><br><span class="line">                        DW_AT_type                  &lt;0x0000007e&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000077&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  int</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">&lt; 1&gt;&lt;0x0000007e&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  long int</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br></pre></td></tr></table></figure>
<p>第一个DIE 代表一个编译单元（CU），本质上是一个包含了所有的<code>#includes</code>和类似的源码文件。以下是带含义注释的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DW_AT_producer   clang version 3.9.1 (tags/RELEASE_391/final)    &lt;-- The compiler which produced</span><br><span class="line">                                                                     this binary</span><br><span class="line">DW_AT_language   DW_LANG_C_plus_plus                             &lt;-- The source language</span><br><span class="line">DW_AT_name       /super/secret/path/MiniDbg/examples/variable.cpp  &lt;-- The name of the file which</span><br><span class="line">                                                                     this CU represents</span><br><span class="line">DW_AT_stmt_list  0x00000000                                      &lt;-- An offset into the line table</span><br><span class="line">                                                                     which tracks this CU</span><br><span class="line">DW_AT_comp_dir   /super/secret/path/MiniDbg/build                  &lt;-- The compilation directory</span><br><span class="line">DW_AT_low_pc     0x00400670                                      &lt;-- The start of the code for</span><br><span class="line">                                                                     this CU</span><br><span class="line">DW_AT_high_pc    0x0040069c                                      &lt;-- The end of the code for</span><br><span class="line">                                                                     this CU</span><br></pre></td></tr></table></figure>
<p>其他的DIE也遵循相似的类型，你可以凭直觉猜到不同属性的意思。</p>
<p>现在我们使用新学的DWARF的知识来尝试解决一些实际的问题。</p>
<hr>
<h2 id="我现在在哪个函数里？"><a href="#我现在在哪个函数里？" class="headerlink" title="我现在在哪个函数里？"></a>我现在在哪个函数里？</h2><p>假设我们现在得到了PC指针，我们想知道我们现在在哪个函数里，最简单的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each compile unit:</span><br><span class="line">    if the pc is between DW_AT_low_pc and DW_AT_high_pc:</span><br><span class="line">        for each function in the compile unit:</span><br><span class="line">            if the pc is between DW_AT_low_pc and DW_AT_high_pc:</span><br><span class="line">                return function information</span><br></pre></td></tr></table></figure>
<p>对大多数情况来说这都适用，但如果有成员函数或是内联代码，情况就会变得更加复杂。假设有内联代码，如果含有内联代码，当我们找到包含PC指针地址的函数时，我们需要递归遍历所有的子DIE以检查是否有内联函数来更好地匹配。我不会为我的调试器添加对内联代码的支持，但是如果你喜欢的话你可以自己加。</p>
<hr>
<h2 id="如何在函数上设置断点？"><a href="#如何在函数上设置断点？" class="headerlink" title="如何在函数上设置断点？"></a>如何在函数上设置断点？</h2><p>再次说明，这取决于你是否想要支持成员函数，命名空间以及其他类似的东西。对简单的函数你只需迭代遍历不同编译单元中的函数直到你找到正确的名字。如果你的编译器能填充<code>.debug_pubnames</code>节，那么就可以更快地找到正确的名字。</p>
<p>一旦找到了函数，你就能在<code>DW_AT_low_pc</code>提供的内存地址上设置断点。然而，那会在函数序言（function prologue）处设置断点，而在用户代码的开始处设置断点会更合适。由于行表信息可以指定序言结束的内存地址，你只需要在行表中查找<code>DW_AT_low_pc</code>的值，然后一直读取到被标记为序言结束的条目。一些编译器不会输出这些信息，因此另一种方式是在该函数的第二行条目指定的地址出设置断点。</p>
<p>假设我们想在<code>main</code>处设置断点，我们寻找叫做<code>main</code>的函数，然后获取它的<code>DIE</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt; 1&gt;&lt;0x0000002e&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_low_pc                0x00400670</span><br><span class="line">                      DW_AT_high_pc               0x0040069c</span><br><span class="line">                      DW_AT_frame_base            DW_OP_reg6</span><br><span class="line">                      DW_AT_name                  main</span><br><span class="line">                      DW_AT_decl_file             0x00000001 /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br><span class="line">                      DW_AT_type                  &lt;0x00000077&gt;</span><br><span class="line">                      DW_AT_external              yes(1)</span><br></pre></td></tr></table></figure>
<p>它告诉我们函数从<code>0x00400670</code>处开始。如果我们在行表中查找它，我们就可以得到这个条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00400670  [   1, 0] NS uri: &quot;/super/secret/path/MiniDbg/examples/variable.cpp&quot;</span><br></pre></td></tr></table></figure>
<p>我们想要跳过序言，因此我们再读一个条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00400676  [   2,10] NS PE</span><br></pre></td></tr></table></figure>
<p>Clang在这个条目中包含了序言结束的标志。因此我们知道要停在这里并在<code>0x00400676</code>处下断。</p>
<hr>
<h2 id="如何读取变量的内容？"><a href="#如何读取变量的内容？" class="headerlink" title="如何读取变量的内容？"></a>如何读取变量的内容？</h2><p>读取变量可能会很复杂。因为变量是一种难以捉摸的东西，他们可以在函数中传递，保存在寄存器中，放在内存中，被优化掉，藏在角落里等等。好在我们的示例非常简单，如果我们想要读取变量<code>a</code>的值，我们只需看看它的<code>DW_AT_location</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DW_AT_location              DW_OP_fbreg -8</span><br></pre></td></tr></table></figure>
<p>这告诉我们它的内存被保存在栈帧基址（base of the stack frame）的偏移为<code>-8</code>的地方。为了知道栈帧基址的值，我们查看所在函数的<code>DW_AT_frame_base</code>的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DW_AT_frame_base            DW_OP_reg6</span><br></pre></td></tr></table></figure>
<p>从<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf" target="_blank" rel="noopener">System V x86_64 ABI</a>的定义可知，<code>reg6</code>是x86上的栈指针寄存器。现在我们从栈指针中读取值并减8从而得到了我们的变量，我们需要看一下它的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; 2&gt;&lt;0x0000004c&gt;      DW_TAG_variable</span><br><span class="line">                        DW_AT_name                  a</span><br><span class="line">                        DW_AT_type                  &lt;0x0000007e&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们在调试信息中寻找这种类型，我们会得到以下的DIE：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; 1&gt;&lt;0x0000007e&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  long int</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br></pre></td></tr></table></figure>
<p>这告诉我们这种类型是一种8字节（64比特）的有符号整型。因此我们可以把这些字节解释为<code>int64_t</code>类型并向用户显示。</p>
<p>当然，类型可能比那要复杂得多，因为它们要能够表示C++中的类型，但这足以让你对它的工作原理有个基本的认识。</p>
<p>再来说说栈帧基址，Clang可以通过栈帧指针寄存器来跟踪栈帧基址。最新版本的GCC倾向于使用 <code>DW_OP_call_frame_cfa</code>，它包括解析<code>.eh_frame</code>ELF部分，那是一个完全不同的文章，因此我不打算去写。如果你告诉GCC用DWARF 2而不是最近的版本，他会输出更便于阅读的位置列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DW_AT_frame_base            &lt;loclist at offset 0x00000000 with 4 entries follows&gt;</span><br><span class="line"> low-off : 0x00000000 addr  0x00400696 high-off  0x00000001 addr 0x00400697&gt;DW_OP_breg7+8</span><br><span class="line"> low-off : 0x00000001 addr  0x00400697 high-off  0x00000004 addr 0x0040069a&gt;DW_OP_breg7+16</span><br><span class="line"> low-off : 0x00000004 addr  0x0040069a high-off  0x00000031 addr 0x004006c7&gt;DW_OP_breg6+16</span><br><span class="line"> low-off : 0x00000031 addr  0x004006c7 high-off  0x00000032 addr 0x004006c8&gt;DW_OP_breg7+8</span><br></pre></td></tr></table></figure>
<p>位置列表会根据PC指针的位置来给出不同的位置。本例中，如果PC指针在<code>DW_AT_low_pc</code>偏移为 <code>0x0</code> 处，那么栈帧基址在reg7所保存值的偏移为8的位置，如果它在<code>0x1</code> 和 <code>0x4</code> 之间，那么栈帧基址就在偏移地址为16的地方。</p>
<hr>
<h2 id="Take-a-breath"><a href="#Take-a-breath" class="headerlink" title="Take a breath"></a>Take a breath</h2><p>这一篇中的内容有点多，需要你大脑好好消化一下，但好消息是在下面几篇中，我们将使用一个库来帮我们完成这些事情。理解概念依然是很有意义的，尤其是当某些错误发生或是你想支持的DWARF内容没有被任何你所用的DWARF库所实现的时候。</p>
<p>如果你想了解更多关于 DWARF的内容，你可以从<a href="http://dwarfstd.org/Download.php" target="_blank" rel="noopener">这里</a>获取其标准。在我写这篇文章的时候，DWARF 5刚刚发布，但DWARF 4的支持更多。</p>
<hr>
<h1 id="（五）：源码和信号"><a href="#（五）：源码和信号" class="headerlink" title="（五）：源码和信号"></a>（五）：源码和信号</h1><p>在上一篇文章中，我们学习了有关DWARF信息的知识以及如何用它来读取变量的值和将我们的高级语言代码和正在被执行的机器码联系起来。这一篇中，我们把所学知识的利用起来，实现一些我们调试器后面会用到的DWARF原语（DWARF primitive）。借此机会，我们可以让我们的调试器在断点触发的同时打印当前源码上下文。</p>
<hr>
<h2 id="设置我们的DWARF解释器"><a href="#设置我们的DWARF解释器" class="headerlink" title="设置我们的DWARF解释器"></a>设置我们的DWARF解释器</h2><p>正如我在这系列文章最初所注的那样，我们使用<a href="https://github.com/TartanLlama/libelfin/tree/fbreg" target="_blank" rel="noopener">libelfin </a>来处理DWARF信息。希望你早已在第一部分设置好了这些，如果没有就现在赶紧去，并确保你用的是我fork的<code>fbreg</code>分支。</p>
<p>一旦你构建好了 <code>libelfin</code>，现在我们就可以把它加到我们的调试器中了。第一步就是解析我们所提供的ELF可执行文件并从中提取处DWARF信息。使用 <code>libelfin</code>能轻松实现这些，只需对<code>debugger</code>做如下更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class debugger &#123;</span><br><span class="line">public:</span><br><span class="line">    debugger (std::string prog_name, pid_t pid)</span><br><span class="line">         : m_prog_name&#123;std::move(prog_name)&#125;, m_pid&#123;pid&#125; &#123;</span><br><span class="line">        auto fd = open(m_prog_name.c_str(), O_RDONLY);</span><br><span class="line"></span><br><span class="line">        m_elf = elf::elf&#123;elf::create_mmap_loader(fd)&#125;;</span><br><span class="line">        m_dwarf = dwarf::dwarf&#123;dwarf::elf::create_loader(m_elf)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //...</span><br><span class="line">    dwarf::dwarf m_dwarf;</span><br><span class="line">    elf::elf m_elf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>open</code>而不是<code>std::ifstream</code>的原因是ELF loader 需要给<code>mmap</code>传递一个UNIX文件描述符，从而它能把文件映射到内存而不是每次读取一点点。</p>
<hr>
<p>##调试信息原语</p>
<p>下一步，我们可以实现一个从PC指针值提取条目（line entry）和函数DIEs的函数。我们从<code>get_function_from_pc</code>函数开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dwarf::die debugger::get_function_from_pc(uint64_t pc) &#123;</span><br><span class="line">    for (auto &amp;cu : m_dwarf.compilation_units()) &#123;</span><br><span class="line">        if (die_pc_range(cu.root()).contains(pc)) &#123;</span><br><span class="line">            for (const auto&amp; die : cu.root()) &#123;</span><br><span class="line">                if (die.tag == dwarf::DW_TAG::subprogram) &#123;</span><br><span class="line">                    if (die_pc_range(die).contains(pc)) &#123;</span><br><span class="line">                        return die;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw std::out_of_range&#123;&quot;Cannot find function&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我使用了相对简单的方法，迭代遍历编译单元知道找到一个包含PC指针的单元，然后迭代遍历它的子节点直到找到我们找到相关函数（<code>DW_TAG_subprogram</code>）。正如我上一篇中所说，如果你想的话你可以处理成员函数或内联。</p>
<p>接下来是<code>get_line_entry_from_pc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dwarf::line_table::iterator debugger::get_line_entry_from_pc(uint64_t pc) &#123;</span><br><span class="line">    for (auto &amp;cu : m_dwarf.compilation_units()) &#123;</span><br><span class="line">        if (die_pc_range(cu.root()).contains(pc)) &#123;</span><br><span class="line">            auto &amp;lt = cu.get_line_table();</span><br><span class="line">            auto it = lt.find_address(pc);</span><br><span class="line">            if (it == lt.end()) &#123;</span><br><span class="line">                throw std::out_of_range&#123;&quot;Cannot find line entry&quot;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw std::out_of_range&#123;&quot;Cannot find line entry&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还是简单的找到正确的编译单元，然后通过查询行表获取相关的条目。</p>
<hr>
<h2 id="打印源码"><a href="#打印源码" class="headerlink" title="打印源码"></a>打印源码</h2><p>当我们触发一个断点或是在单步执行的时候，我们想要知道我们现在在源码中的什么位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void debugger::print_source(const std::string&amp; file_name, unsigned line, unsigned n_lines_context) &#123;</span><br><span class="line">    std::ifstream file &#123;file_name&#125;;</span><br><span class="line"></span><br><span class="line">    //在当前行附近设置一个窗口</span><br><span class="line">    auto start_line = line &lt;= n_lines_context ? 1 : line - n_lines_context;</span><br><span class="line">    auto end_line = line + n_lines_context + (line &lt; n_lines_context ? n_lines_context - line : 0) + 1;</span><br><span class="line"></span><br><span class="line">    char c&#123;&#125;;</span><br><span class="line">    auto current_line = 1u;</span><br><span class="line">    //跳过start_line之前的行</span><br><span class="line">    while (current_line != start_line &amp;&amp; file.get(c)) &#123;</span><br><span class="line">        if (c == &apos;\n&apos;) &#123;</span><br><span class="line">            ++current_line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果我们在当前行则输出光标</span><br><span class="line">    std::cout &lt;&lt; (current_line==line ? &quot;&gt; &quot; : &quot;  &quot;);</span><br><span class="line"></span><br><span class="line">    //Write lines up until end_line</span><br><span class="line">    while (current_line &lt;= end_line &amp;&amp; file.get(c)) &#123;</span><br><span class="line">        std::cout &lt;&lt; c;</span><br><span class="line">        if (c == &apos;\n&apos;) &#123;</span><br><span class="line">            ++current_line;</span><br><span class="line">            //输出换行来刷新流</span><br><span class="line">            std::cout &lt;&lt; (current_line==line ? &quot;&gt; &quot; : &quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Write newline and make sure that the stream is flushed properly</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们能够打印源码了。我们需要将这些接入我们的调试器中。实现这个的好地方是当调试器从一个断点或（最终）单步中收到一个信号时。到了这里，我们也许会想给我们的调试器添加更强的信号处理函数。</p>
<hr>
<h2 id="更好的信号处理"><a href="#更好的信号处理" class="headerlink" title="更好的信号处理"></a>更好的信号处理</h2><p>我们想要知道什么信号被发送给了程序，而且我们我们还想知道它是怎么产生的。比如我们知道<code>SIGTRAP</code>的产生是因为断点触发、单步执行完成、产生了一个新线程等。辛运的是，<code>ptrace</code>再次帮了我们。<code>ptrace</code>有一个request叫<code>PTRACE_GETSIGINFO</code>，它可以告诉我们关于进程发送的最后一个信号的信息。我们可以这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">siginfo_t debugger::get_signal_info() &#123;</span><br><span class="line">    siginfo_t info;</span><br><span class="line">    ptrace(PTRACE_GETSIGINFO, m_pid, nullptr, &amp;info);</span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会返回一个<code>siginfo_t</code> 类型的对象，它提供了如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">siginfo_t &#123;</span><br><span class="line">    int      si_signo;     /* 信号编号 （Signal number） */</span><br><span class="line">    int      si_errno;     /* errno值 （An errno value） */</span><br><span class="line">    int      si_code;      /* 信号代码 （Signal code） */</span><br><span class="line">    int      si_trapno;    /* 导致硬件信号的陷阱信号</span><br><span class="line">                             （多数架构没有使用） */</span><br><span class="line">    pid_t    si_pid;       /* 发送信号的进程ID*/</span><br><span class="line">    uid_t    si_uid;       /* 发送型号的进程的用户ID */</span><br><span class="line">    int      si_status;    /* 退出值或信号 */</span><br><span class="line">    clock_t  si_utime;     /* 消耗的用户时间 */</span><br><span class="line">    clock_t  si_stime;     /* 消耗的系统时间 */</span><br><span class="line">    sigval_t si_value;     /* 信号值 */</span><br><span class="line">    int      si_int;       /* POSIX.1b 信号 */</span><br><span class="line">    void    *si_ptr;       /* POSIX.1b 信号 */</span><br><span class="line">    int      si_overrun;   /* 计时器 overrun 的计数;</span><br><span class="line">                              POSIX.1b 计时器 */</span><br><span class="line">    int      si_timerid;   /* 计时器的ID; POSIX.1b 计时器 */</span><br><span class="line">    void    *si_addr;      /* 导致错误的内存地址 */</span><br><span class="line">    long     si_band;      /* Band event </span><br><span class="line">							  (在glibc 2.3.2及之前是int类型) */</span><br><span class="line">    int      si_fd;        /* 文件描述符 */</span><br><span class="line">    short    si_addr_lsb;  /* 地址的最低有效位</span><br><span class="line">                             （Least significant bit）</span><br><span class="line">                              (自 Linux 2.6.32) */</span><br><span class="line">    void    *si_lower;     /* 出现地址违规的下限 (自 Linux 3.19) */</span><br><span class="line">    void    *si_upper;     /* 出现地址违规的上限 (自 Linux 3.19) */</span><br><span class="line">    int      si_pkey;      /* PTE 上导致错误的保护键 </span><br><span class="line">						      (自 Linux 4.6) */</span><br><span class="line">    void    *si_call_addr; /* 系统调用指令的地址</span><br><span class="line">                              (自 Linux 3.5) */</span><br><span class="line">    int      si_syscall;   /* 系统调用尝试次数</span><br><span class="line">                              (自 Linux 3.5) */</span><br><span class="line">    unsigned int si_arch;  /* 尝试系统调用的架构</span><br><span class="line">                              (自 Linux 3.5) */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要其中的<code>si_signo</code> 就可以知道所发送的信号是什么，通过 <code>si_code</code> 我们还可以知道更多的信息。我们创建一个叫做<code>wait_for_signal</code>的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void debugger::wait_for_signal() &#123;</span><br><span class="line">    int wait_status;</span><br><span class="line">    auto options = 0;</span><br><span class="line">    waitpid(m_pid, &amp;wait_status, options);</span><br><span class="line"></span><br><span class="line">    auto siginfo = get_signal_info();</span><br><span class="line"></span><br><span class="line">    switch (siginfo.si_signo) &#123;</span><br><span class="line">    case SIGTRAP:</span><br><span class="line">        handle_sigtrap(siginfo);</span><br><span class="line">        break;</span><br><span class="line">    case SIGSEGV:</span><br><span class="line">        std::cout &lt;&lt; &quot;Yay, segfault. Reason: &quot; &lt;&lt; siginfo.si_code &lt;&lt; std::endl;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        std::cout &lt;&lt; &quot;Got signal &quot; &lt;&lt; strsignal(siginfo.si_signo) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来处理一系列<code>SIGTRAP</code>。触发断点的时候会发送<code>SI_KERNEL</code>或<code>TRAP_BRKPT</code>，单步执行完成时会发送 <code>TRAP_TRACE</code>，知道这些就足够了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void debugger::handle_sigtrap(siginfo_t info) &#123;</span><br><span class="line">    switch (info.si_code) &#123;</span><br><span class="line">    //如果触发断点，其中一个会被设置</span><br><span class="line">    case SI_KERNEL:</span><br><span class="line">    case TRAP_BRKPT:</span><br><span class="line">    &#123;</span><br><span class="line">        set_pc(get_pc()-1); //PC指针指向正确地址</span><br><span class="line">        std::cout &lt;&lt; &quot;Hit breakpoint at address 0x&quot; &lt;&lt; std::hex &lt;&lt; get_pc() &lt;&lt; std::endl;</span><br><span class="line">        auto line_entry = get_line_entry_from_pc(get_pc());</span><br><span class="line">        print_source(line_entry-&gt;file-&gt;path, line_entry-&gt;line);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果信号时单步执行产生的，这个会被设置</span><br><span class="line">    case TRAP_TRACE:</span><br><span class="line">        return;</span><br><span class="line">    default:</span><br><span class="line">        std::cout &lt;&lt; &quot;Unknown SIGTRAP code &quot; &lt;&lt; info.si_code &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一大堆风格各异的信号你可以处理，因此通过<code>man sigaction</code> 去获取更过信息吧。</p>
<p>因为我们现在已经可以在我们收到<code>SIGTRAP</code>的时候修正PC指针的值，因此我们把这些代码从<code>step_over_breakpoint</code>中移除，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void debugger::step_over_breakpoint() &#123;</span><br><span class="line">    if (m_breakpoints.count(get_pc())) &#123;</span><br><span class="line">        auto&amp; bp = m_breakpoints[get_pc()];</span><br><span class="line">        if (bp.is_enabled()) &#123;</span><br><span class="line">            bp.disable();</span><br><span class="line">            ptrace(PTRACE_SINGLESTEP, m_pid, nullptr, nullptr);</span><br><span class="line">            wait_for_signal();</span><br><span class="line">            bp.enable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p>现在你已经可以在指定地址上设置断点，运行程序，看到源码打印出来并标记出了正在被执行的行。</p>
<p>下一次，我们添加设置源码级断点的能力。同时，你可以在<a href="https://github.com/TartanLlama/minidbg/tree/tut_source" target="_blank" rel="noopener">这里</a>获取到本文的代码。</p>
<hr>
<h1 id="（六）：源码级单步执行"><a href="#（六）：源码级单步执行" class="headerlink" title="（六）：源码级单步执行"></a>（六）：源码级单步执行</h1><p>在前几篇文章中，我们学习了DWARF信息以及它是如何让机器码和高等级源码联系起来的。这次我们试着把源码级单步调试加到我们的调试器中。</p>
<hr>
<h2 id="指令级单步执行"><a href="#指令级单步执行" class="headerlink" title="指令级单步执行"></a>指令级单步执行</h2><p>首先让我们通过UI界面来探索指令级单步执行。我决定把它分成两部分，能被其他部分的代码所使用的<code>single_step_instruction</code> 和确保断点被停用并重新启用的<code>single_step_instruction_with_breakpoint_check</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::single_step_instruction() &#123;</span><br><span class="line">    ptrace(PTRACE_SINGLESTEP, m_pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    wait_for_signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> debugger::single_step_instruction_with_breakpoint_check() &#123;</span><br><span class="line">    <span class="comment">//首先，检查我们是否需要停用或是启用断点</span></span><br><span class="line">    <span class="keyword">if</span> (m_breakpoints.count(get_pc())) &#123;</span><br><span class="line">        step_over_breakpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        single_step_instruction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前一样，又有一个函数被集成到我们的<code>handle_command</code>函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"stepi"</span>)) &#123;</span><br><span class="line">    single_step_instruction_with_breakpoint_check();</span><br><span class="line">    <span class="keyword">auto</span> line_entry = get_line_entry_from_pc(get_pc());</span><br><span class="line">    print_source(line_entry-&gt;file-&gt;path, line_entry-&gt;line);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>随着这个函数的加入，我们现在就可以开始实现我们的源码级单步执行的函数了。</p>
<hr>
<h2 id="实现单步执行"><a href="#实现单步执行" class="headerlink" title="实现单步执行"></a>实现单步执行</h2><p>我们打算写一个很简单的版本，真正的调试器都有一个thread plan来封装所有的单步信息。例如，调试器可能会有一些复杂的逻辑来判断断点的位置，然后有一些回调函数来判断单步操作是否已经完成。其中有许多基本组件需要实现，这里我们只采用一种简单的方法。我们可能会意外地跳过断点，但如果你愿意的话，你可以花一些时间把所有的细节都处理到位。</p>
<p>对于<code>step_out</code>，我们只需要在函数return的地方设置断点并continue即可。我暂时还不想考虑栈展开（<a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding" target="_blank" rel="noopener">stack unwinding</a>）的细节 - 后面会说到 - 返回地址就保存在栈帧开始的后8字节中。因此我们会读取栈指针的值然后在相应的地址上读取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void debugger::step_out() &#123;</span><br><span class="line">    auto frame_pointer = get_register_value(m_pid, reg::rbp);</span><br><span class="line">    auto return_address = read_memory(frame_pointer+8);</span><br><span class="line"></span><br><span class="line">    bool should_remove_breakpoint = false;</span><br><span class="line">    if (!m_breakpoints.count(return_address)) &#123;</span><br><span class="line">        set_breakpoint_at_address(return_address);</span><br><span class="line">        should_remove_breakpoint = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    continue_execution();</span><br><span class="line"></span><br><span class="line">    if (should_remove_breakpoint) &#123;</span><br><span class="line">        remove_breakpoint(return_address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove_breakpoint</code>是一个小帮助函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void debugger::remove_breakpoint(std::intptr_t addr) &#123;</span><br><span class="line">    if (m_breakpoints.at(addr).is_enabled()) &#123;</span><br><span class="line">        m_breakpoints.at(addr).disable();</span><br><span class="line">    &#125;</span><br><span class="line">    m_breakpoints.erase(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个是<code>step_in</code>。一个简单的算法是继续step over直到我们执行到新的一行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::step_in() &#123;</span><br><span class="line">   <span class="keyword">auto</span> line = get_line_entry_from_pc(get_pc())-&gt;line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (get_line_entry_from_pc(get_pc())-&gt;line == line) &#123;</span><br><span class="line">        single_step_instruction_with_breakpoint_check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> line_entry = get_line_entry_from_pc(get_pc());</span><br><span class="line">    print_source(line_entry-&gt;file-&gt;path, line_entry-&gt;line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>step_over</code>是三个中最难实现的一个。从概念上讲，解决方法是在源码的下一行设置断点，但是下一行源码是什么？它可能不是连续的下一行，因为我们可能在一个循环中或在某些条件结构中。真正的那些调试器通常会检查目前正在执行的是什么指令，然后计算出所有可能的分支目标，然后在所有可能上设置断点。对于这样一个小项目，我不打算在上面实现或集成一个x86指令模拟器，因此我们要想一个更简单的解决方案。几个恐怖的方案是：一直单步直到我们发现我们在当前函数的新的一行中；或是在当前函数的所有行上设置断点。前者非常低效因为我们需要单步执行完调用图中的每一条指令，因此我打算采用方案二。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> debugger::step_over() &#123;</span><br><span class="line">    <span class="keyword">auto</span> func = get_function_from_pc(get_pc());</span><br><span class="line">    <span class="keyword">auto</span> func_entry = at_low_pc(func);</span><br><span class="line">    <span class="keyword">auto</span> func_end = at_high_pc(func);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> line = get_line_entry_from_pc(func_entry);</span><br><span class="line">    <span class="keyword">auto</span> start_line = get_line_entry_from_pc(get_pc());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="keyword">intptr_t</span>&gt; to_delete&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (line-&gt;address &lt; func_end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line-&gt;address != start_line-&gt;address &amp;&amp; !m_breakpoints.count(line-&gt;address)) &#123;</span><br><span class="line">            set_breakpoint_at_address(line-&gt;address);</span><br><span class="line">            to_delete.push_back(line-&gt;address);</span><br><span class="line">        &#125;</span><br><span class="line">        ++line;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> frame_pointer = get_register_value(m_pid, reg::rbp);</span><br><span class="line">    <span class="keyword">auto</span> return_address = read_memory(frame_pointer+<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!m_breakpoints.count(return_address)) &#123;</span><br><span class="line">        set_breakpoint_at_address(return_address);</span><br><span class="line">        to_delete.push_back(return_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    continue_execution();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> addr : to_delete) &#123;</span><br><span class="line">        remove_breakpoint(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有些复杂，因此我打算拆开来讲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto func = get_function_from_pc(get_pc());</span><br><span class="line">auto func_entry = at_low_pc(func);</span><br><span class="line">auto func_end = at_high_pc(func);</span><br></pre></td></tr></table></figure>
<p><code>at_low_pc</code> 和 <code>at_high_pc</code> 是 <code>libelfin</code> 中的函数，它们给我们提供了指定函数 DWARF 信息条目的最小程序计数器值和最大程序计数器值，即PC指针范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> line = get_line_entry_from_pc(func_entry);</span><br><span class="line"><span class="keyword">auto</span> start_line = get_line_entry_from_pc(get_pc());</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="keyword">intptr_t</span>&gt; breakpoints_to_remove&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (line-&gt;address &lt; func_end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (line-&gt;address != start_line-&gt;address &amp;&amp; !m_breakpoints.count(line-&gt;address)) &#123;</span><br><span class="line">        set_breakpoint_at_address(line-&gt;address);</span><br><span class="line">        breakpoints_to_remove.push_back(line-&gt;address);</span><br><span class="line">    &#125;</span><br><span class="line">    ++line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要移除所有设置的断点，以便不会泄露出我们的单步执行函数，为此我们把它们保存到一个 <code>std::vector</code> 类型的变量中。为了设置所有断点，我们循环遍历行表条目直到找到一个不在函数范围内的断点。对于每一个行，我们都要确保它不是我们当前所在的行，而且还没有设置任何断点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> frame_pointer = get_register_value(m_pid, reg::rbp);</span><br><span class="line"><span class="keyword">auto</span> return_address = read_memory(frame_pointer+<span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (!m_breakpoints.count(return_address)) &#123;</span><br><span class="line">    set_breakpoint_at_address(return_address);</span><br><span class="line">    to_delete.push_back(return_address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们在函数的返回处设置断点，正如<code>step_out</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">continue_execution();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> addr : to_delete) &#123;</span><br><span class="line">    remove_breakpoint(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们继续执行直到触发断点，然后我们把所有临时设置的断点移除。</p>
<p>虽然不美观但暂时就这样吧。</p>
<p>当然，我们还需要把这个新功能加到我们的UI中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"step"</span>)) &#123;</span><br><span class="line">    step_in();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"next"</span>)) &#123;</span><br><span class="line">    step_over();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"finish"</span>)) &#123;</span><br><span class="line">    step_out();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><p>我通过一个满是call的小程序来测试我们刚实现的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">2</span>;</span><br><span class="line">    a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">3</span>;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">4</span>;</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">5</span>;</span><br><span class="line">    d();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">6</span>;</span><br><span class="line">    e();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你已经可以在<code>main</code>地址上设置断点，然后在程序中step in ,step over, step out。然如果你尝试跳出<code>main</code>或是跳入动态链接库中，那么非预期的事情将会发生。</p>
<p>你可以在<a href="https://github.com/TartanLlama/minidbg/tree/tut_dwarf_step" target="_blank" rel="noopener">这里</a>找到本篇的源码。下一次我们将使用我们新学会的DWARF技巧来实现源码级断点。</p>
<hr>
<h1 id="（七）：源码级断点"><a href="#（七）：源码级断点" class="headerlink" title="（七）：源码级断点"></a>（七）：源码级断点</h1><p>在内存地址上设置断点虽然很棒，但它对用户来说并不是最友好的工具。我们希望能够在源码行或是函数的入口点设置断点，因此我们能够像看我们的代码那样直观的调试它。</p>
<p>这篇文章我们将把源码级断点功能添加到我们的调试器中。有了我们之前那么多的准备工作，实现它比我们第一次听到它名字时简单了许多。我们还需要添加一个能够获取类型和符号的地址的命令，这对于定位代码或数据以及理解链接的概念很有帮助。</p>
<hr>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="DWARF"><a href="#DWARF" class="headerlink" title="DWARF"></a>DWARF</h3><p>在第四篇中，我们描述了DWARF 调试信息的工作原理以及如何使用它将机器码映射到高级源码中。回想一下，DWARF 包含了函数的地址范围和一个允许你在抽象层之间转换代码位置的行表。我们将使用这些功能来实现我们的断点。</p>
<h3 id="函数入口点"><a href="#函数入口点" class="headerlink" title="函数入口点"></a>函数入口点</h3><p>如果你将重载、成员函数等考虑在内，那么在函数名上设置断点可能有些复杂，但是我们将遍历所有的编译单元，并搜索与我们正在寻找的名称匹配的函数。DWARF信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt; 0&gt;&lt;0x0000000b&gt;  DW_TAG_compile_unit</span><br><span class="line">                    DW_AT_producer              clang version 3.9.1 (tags/RELEASE_391/final)</span><br><span class="line">                    DW_AT_language              DW_LANG_C_plus_plus</span><br><span class="line">                    DW_AT_name                  /super/secret/path/MiniDbg/examples/variable.cpp</span><br><span class="line">                    DW_AT_stmt_list             0x00000000</span><br><span class="line">                    DW_AT_comp_dir              /super/secret/path/MiniDbg/build</span><br><span class="line">                    DW_AT_low_pc                0x00400670</span><br><span class="line">                    DW_AT_high_pc               0x0040069c</span><br><span class="line"></span><br><span class="line">LOCAL_SYMBOLS:</span><br><span class="line">&lt; 1&gt;&lt;0x0000002e&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_low_pc                0x00400670</span><br><span class="line">                      DW_AT_high_pc               0x0040069c</span><br><span class="line">                      DW_AT_name                  foo</span><br><span class="line">                      ...</span><br><span class="line">...</span><br><span class="line">&lt;14&gt;&lt;0x000000b0&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_low_pc                0x00400700</span><br><span class="line">                      DW_AT_high_pc               0x004007a0</span><br><span class="line">                      DW_AT_name                  bar</span><br><span class="line">                      ...</span><br></pre></td></tr></table></figure>
<p>我们像通过<code>DW_AT_name</code>进行匹配并使用<code>DW_AT_low_pc</code>（函数的开始地址）来设置我们的断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void debugger::set_breakpoint_at_function(const std::string&amp; name) &#123;</span><br><span class="line">    for (const auto&amp; cu : m_dwarf.compilation_units()) &#123;</span><br><span class="line">        for (const auto&amp; die : cu.root()) &#123;</span><br><span class="line">            if (die.has(dwarf::DW_AT::name) &amp;&amp; at_name(die) == name) &#123;</span><br><span class="line">                auto low_pc = at_low_pc(die);</span><br><span class="line">                auto entry = get_line_entry_from_pc(low_pc);</span><br><span class="line">                ++entry; //跳过函数序言</span><br><span class="line">                set_breakpoint_at_address(entry-&gt;address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中唯一有点奇怪的是<code>++entry</code>。问题是一个函数的<code>DW_AT_low_pc</code>实际上并不指向用户代码的起始地址，而是指向函数的序言。编译器通常会为函数生成序言和结尾（<a href="https://en.wikipedia.org/wiki/Function_prologue" target="_blank" rel="noopener">prologue and epilogue</a>）来保存和恢复寄存器，操作栈指针等。这对我们来说并不是十分有用，因此我们递增入口的行号来到大用户代码的第一行而不是函数序言。DWARF行表实际上具有一些功能来将入口标记位函数序言后的第一行，但并不是所有的编译器都会输出这些，因此我们采用了手动的方法。</p>
<h3 id="源码行"><a href="#源码行" class="headerlink" title="源码行"></a>源码行</h3><p>为了在一个高级源代码行上设置断点，我们需要把行号转换为我们在DWARF中寻你找的地址。我们遍历编译单元，寻找一个名称与给定文件匹配的编译单元，然后查找与给定行对应的入口。</p>
<p>这是DWARF的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.debug_line: line number info for a single cu</span><br><span class="line">Source lines (from CU-DIE at .debug_info offset 0x0000000b):</span><br><span class="line"></span><br><span class="line">NS new statement, BB new basic block, ET end of text sequence</span><br><span class="line">PE prologue end, EB epilogue begin</span><br><span class="line">IS=val ISA number, DI=val discriminator value</span><br><span class="line">&lt;pc&gt;        [lno,col] NS BB ET PE EB IS= DI= uri: &quot;filepath&quot;</span><br><span class="line">0x004004a7  [   1, 0] NS uri: &quot;/super/secret/path/a.hpp&quot;</span><br><span class="line">0x004004ab  [   2, 0] NS</span><br><span class="line">0x004004b2  [   3, 0] NS</span><br><span class="line">0x004004b9  [   4, 0] NS</span><br><span class="line">0x004004c1  [   5, 0] NS</span><br><span class="line">0x004004c3  [   1, 0] NS uri: &quot;/super/secret/path/b.hpp&quot;</span><br><span class="line">0x004004c7  [   2, 0] NS</span><br><span class="line">0x004004ce  [   3, 0] NS</span><br><span class="line">0x004004d5  [   4, 0] NS</span><br><span class="line">0x004004dd  [   5, 0] NS</span><br><span class="line">0x004004df  [   4, 0] NS uri: &quot;/super/secret/path/ab.cpp&quot;</span><br><span class="line">0x004004e3  [   5, 0] NS</span><br><span class="line">0x004004e8  [   6, 0] NS</span><br><span class="line">0x004004ed  [   7, 0] NS</span><br><span class="line">0x004004f4  [   7, 0] NS ET</span><br></pre></td></tr></table></figure>
<p>因此我们希望在<code>ab.cpp</code>的第五行设置断点，我们寻找与<code>0x004004e3</code>所在行对应的入口点并设置断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void debugger::set_breakpoint_at_source_line(const std::string&amp; file, unsigned line) &#123;</span><br><span class="line">    for (const auto&amp; cu : m_dwarf.compilation_units()) &#123;</span><br><span class="line">        if (is_suffix(file, at_name(cu.root()))) &#123;</span><br><span class="line">            const auto&amp; lt = cu.get_line_table();</span><br><span class="line"></span><br><span class="line">            for (const auto&amp; entry : lt) &#123;</span><br><span class="line">                if (entry.is_stmt &amp;&amp; entry.line == line) &#123;</span><br><span class="line">                    set_breakpoint_at_address(entry.address);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>is_suffix</code>的作用是你可以通过输入<code>c.cpp</code>来代替 <code>a/b/c.cpp</code>。事实上，你应该使用路径处理库或是其他，但我太懒了。<code>entry.is_stmt</code> 检查行表入口是否被标记为一个语句的开头，这是由编译器根据它认为是断点的最佳目标的地址设置的。</p>
<hr>
<h2 id="符号查找"><a href="#符号查找" class="headerlink" title="符号查找"></a>符号查找</h2><p>当我们到对象文件的层面时，符号是最重要的。函数是用符号命名的，全局变量使用符号命名的，每一个对象都有一个符号。在给定的对象文件中，一些符号可能引用了其他对象文件或是共享库.</p>
<p>符号可以在一张被正确命名的符号表中找到，这张表存储在二进制文件的ELF节中。幸运的是，<code>libelfin</code>提供了个一个非常不错的接口来完成这些，因此我们不用花大力气去自己处理ELF。为了让你了解到我们现在在处理什么，这里是用<code>readelf</code>工具得到的一个二进制文件的<code>.symtab</code>节的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line"> 0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line"> 1: 0000000000400238     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line"> 2: 0000000000400254     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line"> 3: 0000000000400278     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line"> 4: 00000000004002c8     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line"> 5: 0000000000400430     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line"> 6: 00000000004004e4     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line"> 7: 0000000000400508     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line"> 8: 0000000000400528     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line"> 9: 0000000000400558     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">10: 0000000000400570     0 SECTION LOCAL  DEFAULT   10</span><br><span class="line">11: 0000000000400714     0 SECTION LOCAL  DEFAULT   11</span><br><span class="line">12: 0000000000400720     0 SECTION LOCAL  DEFAULT   12</span><br><span class="line">13: 0000000000400724     0 SECTION LOCAL  DEFAULT   13</span><br><span class="line">14: 0000000000400750     0 SECTION LOCAL  DEFAULT   14</span><br><span class="line">15: 0000000000600e18     0 SECTION LOCAL  DEFAULT   15</span><br><span class="line">16: 0000000000600e20     0 SECTION LOCAL  DEFAULT   16</span><br><span class="line">17: 0000000000600e28     0 SECTION LOCAL  DEFAULT   17</span><br><span class="line">18: 0000000000600e30     0 SECTION LOCAL  DEFAULT   18</span><br><span class="line">19: 0000000000600ff0     0 SECTION LOCAL  DEFAULT   19</span><br><span class="line">20: 0000000000601000     0 SECTION LOCAL  DEFAULT   20</span><br><span class="line">21: 0000000000601018     0 SECTION LOCAL  DEFAULT   21</span><br><span class="line">22: 0000000000601028     0 SECTION LOCAL  DEFAULT   22</span><br><span class="line">23: 0000000000000000     0 SECTION LOCAL  DEFAULT   23</span><br><span class="line">24: 0000000000000000     0 SECTION LOCAL  DEFAULT   24</span><br><span class="line">25: 0000000000000000     0 SECTION LOCAL  DEFAULT   25</span><br><span class="line">26: 0000000000000000     0 SECTION LOCAL  DEFAULT   26</span><br><span class="line">27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27</span><br><span class="line">28: 0000000000000000     0 SECTION LOCAL  DEFAULT   28</span><br><span class="line">29: 0000000000000000     0 SECTION LOCAL  DEFAULT   29</span><br><span class="line">30: 0000000000000000     0 SECTION LOCAL  DEFAULT   30</span><br><span class="line">31: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS init.c</span><br><span class="line">32: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">33: 0000000000600e28     0 OBJECT  LOCAL  DEFAULT   17 __JCR_LIST__</span><br><span class="line">34: 00000000004005a0     0 FUNC    LOCAL  DEFAULT   10 deregister_tm_clones</span><br><span class="line">35: 00000000004005e0     0 FUNC    LOCAL  DEFAULT   10 register_tm_clones</span><br><span class="line">36: 0000000000400620     0 FUNC    LOCAL  DEFAULT   10 __do_global_dtors_aux</span><br><span class="line">37: 0000000000601028     1 OBJECT  LOCAL  DEFAULT   22 completed.6917</span><br><span class="line">38: 0000000000600e20     0 OBJECT  LOCAL  DEFAULT   16 __do_global_dtors_aux_fin</span><br><span class="line">39: 0000000000400640     0 FUNC    LOCAL  DEFAULT   10 frame_dummy</span><br><span class="line">40: 0000000000600e18     0 OBJECT  LOCAL  DEFAULT   15 __frame_dummy_init_array_</span><br><span class="line">41: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS /super/secret/path/MiniDbg/</span><br><span class="line">42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">43: 0000000000400818     0 OBJECT  LOCAL  DEFAULT   14 __FRAME_END__</span><br><span class="line">44: 0000000000600e28     0 OBJECT  LOCAL  DEFAULT   17 __JCR_END__</span><br><span class="line">45: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS</span><br><span class="line">46: 0000000000400724     0 NOTYPE  LOCAL  DEFAULT   13 __GNU_EH_FRAME_HDR</span><br><span class="line">47: 0000000000601000     0 OBJECT  LOCAL  DEFAULT   20 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">48: 0000000000601028     0 OBJECT  LOCAL  DEFAULT   21 __TMC_END__</span><br><span class="line">49: 0000000000601020     0 OBJECT  LOCAL  DEFAULT   21 __dso_handle</span><br><span class="line">50: 0000000000600e20     0 NOTYPE  LOCAL  DEFAULT   15 __init_array_end</span><br><span class="line">51: 0000000000600e18     0 NOTYPE  LOCAL  DEFAULT   15 __init_array_start</span><br><span class="line">52: 0000000000600e30     0 OBJECT  LOCAL  DEFAULT   18 _DYNAMIC</span><br><span class="line">53: 0000000000601018     0 NOTYPE  WEAK   DEFAULT   21 data_start</span><br><span class="line">54: 0000000000400710     2 FUNC    GLOBAL DEFAULT   10 __libc_csu_fini</span><br><span class="line">55: 0000000000400570    43 FUNC    GLOBAL DEFAULT   10 _start</span><br><span class="line">56: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">57: 0000000000400714     0 FUNC    GLOBAL DEFAULT   11 _fini</span><br><span class="line">58: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span><br><span class="line">59: 0000000000400720     4 OBJECT  GLOBAL DEFAULT   12 _IO_stdin_used</span><br><span class="line">60: 0000000000601018     0 NOTYPE  GLOBAL DEFAULT   21 __data_start</span><br><span class="line">61: 00000000004006a0   101 FUNC    GLOBAL DEFAULT   10 __libc_csu_init</span><br><span class="line">62: 0000000000601028     0 NOTYPE  GLOBAL DEFAULT   22 __bss_start</span><br><span class="line">63: 0000000000601030     0 NOTYPE  GLOBAL DEFAULT   22 _end</span><br><span class="line">64: 0000000000601028     0 NOTYPE  GLOBAL DEFAULT   21 _edata</span><br><span class="line">65: 0000000000400670    44 FUNC    GLOBAL DEFAULT   10 main</span><br><span class="line">66: 0000000000400558     0 FUNC    GLOBAL DEFAULT    9 _init</span><br></pre></td></tr></table></figure>
<p>你可以看到在对象文件中有许多关于节的符号，它们被来设置环境。在末尾你可以看到<code>main</code>的符号。</p>
<p>我们对符号的类型，名字和值（地址）感兴趣。type为<code>symbol_type</code>枚举类型，name为<code>std::string</code> ，address为<code>std::uintptr_t</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum class symbol_type &#123;</span><br><span class="line">    notype,            // 无类型 (例： absolute symbol)</span><br><span class="line">    object,            // 数据对象</span><br><span class="line">    func,              // 函数入口点</span><br><span class="line">    section,           // 和节相关联的符号</span><br><span class="line">    file,              // 和对象文件相联系的源码文件</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::string to_string (symbol_type st) &#123;</span><br><span class="line">    switch (st) &#123;</span><br><span class="line">    case symbol_type::notype: return &quot;notype&quot;;</span><br><span class="line">    case symbol_type::object: return &quot;object&quot;;</span><br><span class="line">    case symbol_type::func: return &quot;func&quot;;</span><br><span class="line">    case symbol_type::section: return &quot;section&quot;;</span><br><span class="line">    case symbol_type::file: return &quot;file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct symbol &#123;</span><br><span class="line">    symbol_type type;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::uintptr_t addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们不想让依赖破坏接口因此我们需要将从<code>libelfin</code>获取到的符号类型映射到我们的枚举变量中。因为我们对所有东西都选用了相同的名字，所以这超级简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">symbol_type to_symbol_type(elf::stt sym) &#123;</span><br><span class="line">    switch (sym) &#123;</span><br><span class="line">    case elf::stt::notype: return symbol_type::notype;</span><br><span class="line">    case elf::stt::object: return symbol_type::object;</span><br><span class="line">    case elf::stt::func: return symbol_type::func;</span><br><span class="line">    case elf::stt::section: return symbol_type::section;</span><br><span class="line">    case elf::stt::file: return symbol_type::file;</span><br><span class="line">    default: return symbol_type::notype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后我们想要查找符号。为了解释说明，我在ELF中循环查找符号表，然后把我在其中找到的符号存在<code>std::vector</code> 类型中。更智能的方法是建立一个从名称到符号的映射，这样你只要查看一次数据就够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;symbol&gt; debugger::lookup_symbol(const std::string&amp; name) &#123;</span><br><span class="line">    std::vector&lt;symbol&gt; syms;</span><br><span class="line"></span><br><span class="line">    for (auto &amp;sec : m_elf.sections()) &#123;</span><br><span class="line">        if (sec.get_hdr().type != elf::sht::symtab &amp;&amp; sec.get_hdr().type != elf::sht::dynsym)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        for (auto sym : sec.as_symtab()) &#123;</span><br><span class="line">            if (sym.get_name() == name) &#123;</span><br><span class="line">                auto &amp;d = sym.get_data();</span><br><span class="line">                syms.push_back(symbol&#123;to_symbol_type(d.type()), sym.get_name(), d.value&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return syms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="添加命令"><a href="#添加命令" class="headerlink" title="添加命令"></a>添加命令</h2><p>和之前一样，我们需要添加一些更多的命令来给用户使用。断点我使用了 GDB 风格的接口，断点类型是通过你传递的参数推断的，而不要求显式切换：</p>
<ul>
<li><code>0x&lt;hexadecimal&gt;</code> -&gt; 地址断点</li>
<li><code>&lt;line&gt;:&lt;filename&gt;</code> -&gt; 行号断点</li>
<li><code>&lt;anything else&gt;</code> -&gt;函数名断点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"break"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; args[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'x'</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> addr &#123;args[<span class="number">1</span>], <span class="number">2</span>&#125;;</span><br><span class="line">        set_breakpoint_at_address(<span class="built_in">std</span>::stol(addr, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].find(<span class="string">':'</span>) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="keyword">auto</span> file_and_line = split(args[<span class="number">1</span>], <span class="string">':'</span>);</span><br><span class="line">        set_breakpoint_at_source_line(file_and_line[<span class="number">0</span>], <span class="built_in">std</span>::stoi(file_and_line[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        set_breakpoint_at_function(args[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于符号，我们将查找符号并打印出我们找到的匹配项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(is_prefix(command, <span class="string">"symbol"</span>)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> syms = lookup_symbol(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; s : syms) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.name &lt;&lt; <span class="string">' '</span> &lt;&lt; to_string(s.type) &lt;&lt; <span class="string">" 0x"</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; s.addr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><p>用调试器调试一个简单的二进制文件，设置源码级断点。在一些 <code>foo</code> 函数上设置断点，看到我的调试器断在上面是我这个项目最有价值的时刻之一。</p>
<p>符号查找可以通过在程序中添加一些函数或全局变量并查找它们的名称来进行测试。如果你正在编译 C++ 代码，你还需要考虑名字修饰(<a href="https://en.wikipedia.org/wiki/Name_mangling#C.2B.2B" target="_blank" rel="noopener">name mangling</a>)。</p>
<p>下一篇我将展示如何向调试器添加栈卷回（<a href="https://en.wikipedia.org/wiki/Call_stack#STACK-UNWINDING" target="_blank" rel="noopener">stack unwinding</a>）支持。</p>
<p>你可以在<a href="(https://github.com/TartanLlama/minidbg/tree/tut_source_break">这里</a>)找到这篇文章的代码。</p>
<hr>
<h1 id="（八）：栈卷回"><a href="#（八）：栈卷回" class="headerlink" title="（八）：栈卷回"></a>（八）：栈卷回</h1><p>有时候，你想知道的你当前程序运行状态的最重要的信息是程序是如何运行到那里的。这些信息通常可以通过执行<code>backtrace</code>命令来得到，它会打印出到目前位置的函数调用链。这一篇文章将会展示如何在x86_64上实现像<code>backtrace</code>一样的栈卷回（<a href="https://en.wikipedia.org/wiki/Call_stack#STACK-UNWINDING" target="_blank" rel="noopener">stack unwinding</a>）</p>
<hr>
<p>以下面的程序为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void a() &#123;</span><br><span class="line">    //断在这里</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void b() &#123;</span><br><span class="line">     a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void c() &#123;</span><br><span class="line">     a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    b();</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在程序断在<code>//断在这里</code>这一行，有两种方法可以到达那里：<code>main-&gt;b-&gt;a</code>或<code>main-&gt;c-&gt;a</code>。如果我们使用LLDB在那里设置断点，continue，然后请求<code>backtrace</code>，我们会得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x00000000004004da a.out`a() + 4 at bt.cpp:3</span><br><span class="line">  frame #1: 0x00000000004004e6 a.out`b() + 9 at bt.cpp:6</span><br><span class="line">  frame #2: 0x00000000004004fe a.out`main + 9 at bt.cpp:14</span><br><span class="line">  frame #3: 0x00007ffff7a2e830 libc.so.6`__libc_start_main + 240 at libc-start.c:291</span><br><span class="line">  frame #4: 0x0000000000400409 a.out`_start + 41</span><br></pre></td></tr></table></figure>
<p>它告诉我们我们当前在函数<code>a</code>中，是从函数<code>b</code>来的，再往前是从函数<code>main</code>来的。最后两个步是编译器如何引导程序到<code>main</code>函数上。</p>
<p>当前的问题是我们如何在x86_64上实现它。最鲁棒的方法是解析<code>.eh_frame</code>节，然后理清如何从那里栈卷回，但这方法太难了。你也可以使用<code>libunwind</code>或其他类似的来帮助你完成这些，但是这又太无聊了。相反，我们假设编译器已经使用某种确定的方法布置好了栈，我们只需要手动操作一遍。为了做到这一点，我们需要先了解栈布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">            High</span><br><span class="line">        |   ...   |</span><br><span class="line">        +---------+</span><br><span class="line">     +24|  Arg 1  |</span><br><span class="line">        +---------+</span><br><span class="line">     +16|  Arg 2  |</span><br><span class="line">        +---------+</span><br><span class="line">     + 8| Return  |</span><br><span class="line">        +---------+</span><br><span class="line">EBP+--&gt; |Saved EBP|</span><br><span class="line">        +---------+</span><br><span class="line">     - 8|  Var 1  |</span><br><span class="line">        +---------+</span><br><span class="line">ESP+--&gt; |  Var 2  |</span><br><span class="line">        +---------+</span><br><span class="line">        |   ...   |</span><br><span class="line">            Low</span><br></pre></td></tr></table></figure>
<p>如你所见，最后一个栈帧的栈指针被储存在当前栈帧的开始处，创建了一个栈指针的单项链表。栈通过这个栈指针的链表进行卷回。我们通过查找DWARF信息中的返回地址来找出链表中下一帧属于哪一个函数。有些编译器会忽略用<code>EBP</code>追踪帧基，因为这可以用<code>ESP</code>加偏移的方式来表示并且可以节省空间。向GCC或是Clang传递<code>-fno-omit-frame-pointer</code>参数就能强制它们遵循这个惯例，即使启用了优化。</p>
<p>我们将在<code>print_backtrace</code> 函数中实现这个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void debugger::print_backtrace() &#123;</span><br></pre></td></tr></table></figure>
<p>我们需要尽快决定栈帧信息打印的格式，我使用了一个小lambda来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto output_frame = [frame_number = 0] (auto&amp;&amp; func) mutable &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;frame #&quot; &lt;&lt; frame_number++ &lt;&lt; &quot;: 0x&quot; &lt;&lt; dwarf::at_low_pc(func)</span><br><span class="line">              &lt;&lt; &apos; &apos; &lt;&lt; dwarf::at_name(func) &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>被打印出来的第一帧是现在正在被执行的帧。我们可以在DWARF中通过查找当前程序的PC指针来获得这个栈帧的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto current_func = get_function_from_pc(get_pc());</span><br><span class="line">output_frame(current_func);</span><br></pre></td></tr></table></figure>
<p>下一步我们需要获取当前函数的栈指针和返回地址。栈指针存储在<code>rbp</code>寄存器中，而返回地址在栈指针上面8字节处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto frame_pointer = get_register_value(m_pid, reg::rbp);</span><br><span class="line">auto return_address = read_memory(frame_pointer+8);</span><br></pre></td></tr></table></figure>
<p>现在我们有了做栈回溯的所有信息。我将一直做回溯直到<code>main</code>函数。但你也可以选择回溯到到栈指针为<code>0x0</code>，这样你将获得<code>main</code>函数之前的函数。每一次我们都将打印出这个栈帧的栈指针值和返回地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    while (dwarf::at_name(current_func) != &quot;main&quot;) &#123;</span><br><span class="line">        current_func = get_function_from_pc(return_address);</span><br><span class="line">        output_frame(current_func);</span><br><span class="line">        frame_pointer = read_memory(frame_pointer);</span><br><span class="line">        return_address = read_memory(frame_pointer+8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在整个函数都在这里了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void debugger::print_backtrace() &#123;</span><br><span class="line">    auto output_frame = [frame_number = 0] (auto&amp;&amp; func) mutable &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;frame #&quot; &lt;&lt; frame_number++ &lt;&lt; &quot;: 0x&quot; &lt;&lt; dwarf::at_low_pc(func)</span><br><span class="line">                  &lt;&lt; &apos; &apos; &lt;&lt; dwarf::at_name(func) &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    auto current_func = get_function_from_pc(get_pc());</span><br><span class="line">    output_frame(current_func);</span><br><span class="line"></span><br><span class="line">    auto frame_pointer = get_register_value(m_pid, reg::rbp);</span><br><span class="line">    auto return_address = read_memory(frame_pointer+8);</span><br><span class="line"></span><br><span class="line">    while (dwarf::at_name(current_func) != &quot;main&quot;) &#123;</span><br><span class="line">        current_func = get_function_from_pc(return_address);</span><br><span class="line">        output_frame(current_func);</span><br><span class="line">        frame_pointer = read_memory(frame_pointer);</span><br><span class="line">        return_address = read_memory(frame_pointer+8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="添加命令-1"><a href="#添加命令-1" class="headerlink" title="添加命令"></a>添加命令</h2><p>当然，我们需要把这个命令提供给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if(is_prefix(command, &quot;backtrace&quot;)) &#123;</span><br><span class="line">    print_backtrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h2><p>测试这个功能的好方法是写一个小程序，里面有一对的小函数相互调用。设置一些断点，跳过一些代码，然后确保你的栈回溯是准确的。</p>
<hr>
<p>我们从一个只能运行和附加的程序已经走过了很长一段路。本系列文章的倒数第二篇将使调试器支持读取和存储变量。<a href="https://github.com/TartanLlama/minidbg/tree/tut_unwind" target="_blank" rel="noopener">这里</a>是本篇的代码。</p>
<hr>
<h1 id="（九）：处理变量"><a href="#（九）：处理变量" class="headerlink" title="（九）：处理变量"></a>（九）：处理变量</h1><p>变量非常神秘。刚在还呆在寄存器里，一转头就转入栈中。也可能编译器把他们优化掉了。无论变量在内存中移动的多么频繁，我们需要一些手段在我们的调试器中跟踪和操作它们。这一篇我将告诉你们如何在调试器中处理变量并使用<code>libelfin</code>实现一个demo。</p>
<hr>
<p>在你开始之前，确认你使用的<code>libelfin</code>是我<a href="https://github.com/TartanLlama/libelfin/tree/fbreg" target="_blank" rel="noopener">fork</a>的<code>fbreg</code> 分支。这个分支对<code>libelfin</code>做了一些修改，可以获取当前栈帧的基址以及对位置列表求值。这在原版的<code>libelfin</code>中是不存在的。你可能需要将<code>-gdwarf-2</code>参数传递给GCC来生成兼容的DWARF信息。但在开始实现之前，我将介绍位置信息在DWARF5 中是如何编码的（最新的规范）。如果你想获取更多的信息，你们在<a href="http://dwarfstd.org/" target="_blank" rel="noopener">这里</a>获取最新的标准。</p>
<hr>
<h2 id="DWARF-位置信息"><a href="#DWARF-位置信息" class="headerlink" title="DWARF 位置信息"></a>DWARF 位置信息</h2><p>在给定时刻中，一个变量的位置被编码在DWARF信息的<code>DW_AT_location</code>属性里。位置描述可以是一个单一的位置描述，也可以是复合位置描述或位置列表。</p>
<ul>
<li>简单的位置描述描述对象的一个​​连续块（通常是整个）的位置。简单的位置描述可以描述可寻址存储器或寄存器中的位置，或缺少位置（具有或不具有已知值）。<ul>
<li>例：<ul>
<li><code>DW_OP_fbreg -32</code></li>
<li>一个变量存储在栈帧地址-38字节偏移处</li>
</ul>
</li>
</ul>
</li>
<li>复合位置描述描述了一个由多部分组成的对象，每一部分都包含在一个寄存器或储存在内存中，且各部分的位置不相互关联。<ul>
<li>例：<ul>
<li><code>DW_OP_reg3 DW_OP_piece 4 DW_OP_reg10 DW_OP_piece 2</code></li>
<li>一个变量，它的前四字节在reg3中，后两字节在reg10中。</li>
</ul>
</li>
</ul>
</li>
<li>地址列表描述了一个拥有有限的生命周期或是在生命周期内会改变储存位置的对象。<ul>
<li>例：<ul>
<li><code>&lt;loclist with 3 entries follows&gt;</code><ul>
<li><code>[ 0]&lt;lowpc=0x2e00&gt;&lt;highpc=0x2e19&gt;DW_OP_reg0</code></li>
<li><code>[ 1]&lt;lowpc=0x2e19&gt;&lt;highpc=0x2e3f&gt;DW_OP_reg3</code></li>
<li><code>[ 2]&lt;lowpc=0x2ec4&gt;&lt;highpc=0x2ec7&gt;DW_OP_reg2</code></li>
</ul>
</li>
<li>根据当前PC指针的不同，变量的位置会在不同寄存器间移动。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>DW_AT_location</code>一共有三种编码方式，取决于位置描述的种类。<code>exprloc</code>编码了简单或是复合的位置描述。他们由一个字节组成，后面跟着一个DWARF表达式或者位置描述。<code>loclist</code>和<code>loclistptr</code>编码了位置列表。它们向<code>.debug_loclists</code>节提供了反映实际位置列表的索引或偏移量。</p>
<hr>
<h2 id="DWARF-表达式"><a href="#DWARF-表达式" class="headerlink" title="DWARF 表达式"></a>DWARF 表达式</h2><p>变量的实际位置是通过DWARF表达式计算出来的。这由一系列对栈上值的操作构成。因为DWARF的操作种类过多，因此我不会一一仔细介绍。我会为表达式的class写一个小示例，这样你就能了解可用的内容。此外，不必畏惧，<code>libelfin</code>将为我们处理好所有这些复杂的东西。</p>
<ul>
<li>文本编码<ul>
<li><code>DW_OP_lit0</code>, <code>DW_OP_lit1</code>, …, <code>DW_OP_lit31</code><ul>
<li>将文本push到栈上</li>
</ul>
</li>
<li><code>DW_OP_addr &lt;addr&gt;</code><ul>
<li>将地址操作数push到栈上</li>
</ul>
</li>
<li><code>DW_OP_constu &lt;unsigned&gt;</code><ul>
<li>将无符号值push到栈上</li>
</ul>
</li>
</ul>
</li>
<li>寄存器值<ul>
<li><code>DW_OP_fbreg &lt;offset&gt;</code><ul>
<li>将值push到栈帧基地址指定偏移处</li>
</ul>
</li>
<li><code>DW_OP_breg0</code>, <code>DW_OP_breg1</code>, …, <code>DW_OP_breg31 &lt;offset&gt;</code><ul>
<li>将指定的寄存器的内容加上指定偏移push到栈上</li>
</ul>
</li>
</ul>
</li>
<li>栈操作<ul>
<li><code>DW_OP_dup</code><ul>
<li>复制栈顶的值</li>
</ul>
</li>
<li><code>DW_OP_deref</code><ul>
<li>将栈顶视为内存地址，并将其替换成地址的内容</li>
</ul>
</li>
</ul>
</li>
<li>算数和逻辑运算<ul>
<li><code>DW_OP_and</code><ul>
<li>从栈中POP两个值并将它们做AND运算后的值PUSH到栈中</li>
</ul>
</li>
<li><code>DW_OP_plus</code><ul>
<li>和<code>DW_OP_and</code>相似, 但操作改为相加</li>
</ul>
</li>
</ul>
</li>
<li>控制流操作<ul>
<li><code>DW_OP_le</code>, <code>DW_OP_eq</code>, <code>DW_OP_gt</code>,等。<ul>
<li>POP两个值，比较它们，如果条件为真push <code>1</code>，反之push <code>0</code>。</li>
</ul>
</li>
<li><code>DW_OP_bra &lt;offset&gt;</code><ul>
<li>条件分支: 如果栈顶不是<code>0</code>，跳过或向前跳转指定的 <code>offset</code></li>
</ul>
</li>
</ul>
</li>
<li>类型转换<ul>
<li><code>DW_OP_convert &lt;DIE offset&gt;</code><ul>
<li>把栈顶的值转换成不同的类型，用DWARF信息加上偏移的形式来描述。</li>
</ul>
</li>
</ul>
</li>
<li>特殊操作<ul>
<li><code>DW_OP_nop</code><ul>
<li>啥都不做</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="DWARF类型"><a href="#DWARF类型" class="headerlink" title="DWARF类型"></a>DWARF类型</h2><p>DWARF的类型表示需要足够强大以给调试器的用户带来有用的类型表示。用户最希望能在程序级别进行调试而不是在机器级别进行调试，而且他们需要了解变量现在的值。</p>
<p>DWARF的类型和大多数调试信息一样被编码在DIE中。它们具有名称，编码形式，大小，字节顺序（endianness）等属性。有无数种类的标签来表示指针，数组，结构体，typedef，以及任何你能在C或C++中看到的种类。</p>
<p>以这个简单的结构体为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> j;</span><br><span class="line">    <span class="keyword">int</span> k[<span class="number">42</span>];</span><br><span class="line">    test* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体的父DIE是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; 1&gt;&lt;0x0000002a&gt;    DW_TAG_structure_type</span><br><span class="line">                      DW_AT_name                  &quot;test&quot;</span><br><span class="line">                      DW_AT_byte_size             0x000000b8</span><br><span class="line">                      DW_AT_decl_file             0x00000001 test.cpp</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br></pre></td></tr></table></figure>
<p>上面说，我们有一个叫做<code>test</code>的，大小为<code>0xb8</code>的结构体，定义在<code>test.cpp</code>的第<code>1</code>行。然后有许多子DIE描述了它的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt; 2&gt;&lt;0x00000032&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  &quot;i&quot;</span><br><span class="line">                        DW_AT_type                  &lt;0x00000063&gt;</span><br><span class="line">                        DW_AT_decl_file             0x00000001 test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000002</span><br><span class="line">                        DW_AT_data_member_location  0</span><br><span class="line">&lt; 2&gt;&lt;0x0000003e&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  &quot;j&quot;</span><br><span class="line">                        DW_AT_type                  &lt;0x0000006a&gt;</span><br><span class="line">                        DW_AT_decl_file             0x00000001 test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000003</span><br><span class="line">                        DW_AT_data_member_location  4</span><br><span class="line">&lt; 2&gt;&lt;0x0000004a&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  &quot;k&quot;</span><br><span class="line">                        DW_AT_type                  &lt;0x00000071&gt;</span><br><span class="line">                        DW_AT_decl_file             0x00000001 test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000004</span><br><span class="line">                        DW_AT_data_member_location  8</span><br><span class="line">&lt; 2&gt;&lt;0x00000056&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  &quot;next&quot;</span><br><span class="line">                        DW_AT_type                  &lt;0x00000084&gt;</span><br><span class="line">                        DW_AT_decl_file             0x00000001 test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000005</span><br><span class="line">                        DW_AT_data_member_location  176(as signed = -80)</span><br></pre></td></tr></table></figure>
<p>每个成员都有一个名字，一个种类（它是一个DIE中的偏移量），被声明的文件和行号。和他在所在结构体中的偏移位置。接下来是他所指向的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt; 1&gt;&lt;0x00000063&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  &quot;int&quot;</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">&lt; 1&gt;&lt;0x0000006a&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  &quot;float&quot;</span><br><span class="line">                      DW_AT_encoding              DW_ATE_float</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">&lt; 1&gt;&lt;0x00000071&gt;    DW_TAG_array_type</span><br><span class="line">                      DW_AT_type                  &lt;0x00000063&gt;</span><br><span class="line">&lt; 2&gt;&lt;0x00000076&gt;      DW_TAG_subrange_type</span><br><span class="line">                        DW_AT_type                  &lt;0x0000007d&gt;</span><br><span class="line">                        DW_AT_count                 0x0000002a</span><br><span class="line">&lt; 1&gt;&lt;0x0000007d&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_name                  &quot;sizetype&quot;</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_encoding              DW_ATE_unsigned</span><br><span class="line">&lt; 1&gt;&lt;0x00000084&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_type                  &lt;0x0000002a&gt;</span><br></pre></td></tr></table></figure>
<p>如你所见，<code>int</code>在我机器上是一个四字节的有符号整型，<code>float</code>是一个四字节的单精度浮点数。整数数组是通过<code>int</code>类型的指针定义的。<code>sizetype</code>（认为<code>size_t</code>）作为索引类型，有<code>2a</code>个元素。<code>test*</code>类型是<code>DW_TAG_pointer_type</code>，则是对<code>test</code>DIE的引用。</p>
<hr>
<h2 id="实现一个简单的变量读取函数"><a href="#实现一个简单的变量读取函数" class="headerlink" title="实现一个简单的变量读取函数"></a>实现一个简单的变量读取函数</h2><p>就如之前所说的，<code>libelfin</code>将会为我们处理绝大多数复杂的东西。然而它并没有实现关于表示变量位置的所有不同表示方法，而且在我们的代码中处理它们将会十分复杂。因此，我打算目前只支持<code>exprloc</code>。如果你很勇敢，你可以为<code>libelfin</code>提交一些补丁来帮助实现那些必要的支持！</p>
<p> 处理变量主要是从内存或寄存器中定位变量的不同部分，然后将它们读取或写入。为简便起见，我只展示如何实现变量的读取。</p>
<p>首先我们需要告诉<code>libelfin</code> 如何从我们的进程中读取寄存器。我们从<code>expr_context</code>继承一个类，然后使用<code>ptrace</code>来处理所有的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ptrace_expr_context : public dwarf::expr_context &#123;</span><br><span class="line">public:</span><br><span class="line">    ptrace_expr_context (pid_t pid) : m_pid&#123;pid&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    dwarf::taddr reg (unsigned regnum) override &#123;</span><br><span class="line">        return get_register_value_from_dwarf_register(m_pid, regnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dwarf::taddr pc() override &#123;</span><br><span class="line">        struct user_regs_struct regs;</span><br><span class="line">        ptrace(PTRACE_GETREGS, m_pid, nullptr, &amp;regs);</span><br><span class="line">        return regs.rip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dwarf::taddr deref_size (dwarf::taddr address, unsigned size) override &#123;</span><br><span class="line">        //TODO 考虑size</span><br><span class="line">        return ptrace(PTRACE_PEEKDATA, m_pid, address, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    pid_t m_pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>读取将由我们<code>debugger</code>类中的<code>read_variables</code> 函数来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void debugger::read_variables() &#123;</span><br><span class="line">    using namespace dwarf;</span><br><span class="line"></span><br><span class="line">    auto func = get_function_from_pc(get_pc());</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面做的第一件事是找到我们现在所在的函数。然后我们需要在这个函数的条目中循环查找变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; die : func) &#123;</span><br><span class="line">    <span class="keyword">if</span> (die.tag == DW_TAG::variable) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过在DIE中查找<code>DW_AT_location</code>条目来获取位置信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loc_val = die[DW_AT::location];</span><br></pre></td></tr></table></figure>
<p>然后我们确认它是<code>exprloc</code>，并请求<code>libelfin</code>对表达式求值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (loc_val.get_type() == value::type::exprloc) &#123;</span><br><span class="line">    ptrace_expr_context context &#123;m_pid&#125;;</span><br><span class="line">    auto result = loc_val.as_exprloc().evaluate(&amp;context);</span><br></pre></td></tr></table></figure>
<p>对表达式求值完后，我们需要将内容从变量中读取出来。它可能在内存中也可能在寄存器中，两种情况我们都需要考虑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result.location_type) &#123;</span><br><span class="line"><span class="keyword">case</span> expr_result::type::address:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = read_memory(result.value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; at_name(die) &lt;&lt; <span class="string">" (0x"</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; result.value &lt;&lt; <span class="string">") = "</span></span><br><span class="line">              &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> expr_result::type::reg:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = get_register_value_from_dwarf_register(m_pid, result.value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; at_name(die) &lt;&lt; <span class="string">" (reg "</span> &lt;&lt; result.value &lt;&lt; <span class="string">") = "</span></span><br><span class="line">              &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error&#123;<span class="string">"Unhandled variable location"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，我只是简单的把值打印出来，没有对他进行类型解释。希望你能通过这小段代码看出如何写入变量，通过给定的名字搜索变量。</p>
<p>最后，我们可以把它添加到我们的命令解释器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if(is_prefix(command, &quot;variables&quot;)) &#123;</span><br><span class="line">    read_variables();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h2><p>编写一些具有多个变量的小函数，用禁用优化，输出调试信息来编译，然后测试看是否能从变量中读取值。尝试向变量储存的地址写入值，看程序的行为会有什么改变。</p>
<p>九篇写完了，只剩下最后一篇了！下一次我将谈谈一些进阶的概念，你可能会感兴趣。你可以在<a href="https://github.com/TartanLlama/minidbg/tree/tut_variable" target="_blank" rel="noopener">这里</a>找到本篇的代码。</p>
<hr>
<h1 id="（十）：进阶话题"><a href="#（十）：进阶话题" class="headerlink" title="（十）：进阶话题"></a>（十）：进阶话题</h1><p>我们终于来到这系列文章的最后一篇，这一次我们将从较高的层面概述调试中的一些更高级的概念：远程调试，共享库支持，表达式求值和多线程支持。这些想法更难实现，所以我不会详细的说明如何做，但如果你有任何概念上的问题，我乐于回答。</p>
<hr>
<h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><p>对嵌入式系统或是环境差异影响的调试来说，远程调试是非常有用的。它还良好的区别了高级调试器操作和操作系统与硬件的交互。事实上，<br>像GDB或是LLDB那样的调试器几十载调试本地程序的时候也能像远程调试器那样操作。一般的架构是这样的：</p>
<p><img src="http://img2.tan90.me/ptrace_10_260e0e6cc5e29daf92c63851d919e8c2.png" alt=""></p>
<p>调试器是我们通过命令行进行交互的组件。如果你在使用IDE那么可能还有一层通过<em>机器接口</em>和调试器进行通信。在目标机器（可能和主机相同）上会有一个<em>调试存根(debug stub)</em>，理论上它是在系统调试库周围的一个包装器，它带来了所有低等级的调试指令，例如设置断点。我说“理论上”是因为存根目前在不断变大。在我机器上LLDB的调试存根大小为7.6MB。调试存根使用某些特定于系统的功能（在我们的例子中为<code>ptrace</code>）来与被调试端通信并通过一些远程协议和调试器通信。</p>
<p>在调试中，最常见的远程协议为GDB远程协议。这是一种基于文本的数据包格式，用于在调试器和调试存根间传递命令和信息。我不会详细介绍，但你可以在<a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html" target="_blank" rel="noopener">这里</a>阅读所有你想了解的内容。如果你启动LLDB并执行命令<code>log enable gdb-remote packets</code>，你将得到所有通过远程协议发送的数据包。在GDB上你可以执行<code>set remotelogfile &lt;file&gt;</code>获得上述结果。</p>
<p>举个例子，这是设置断点发送的一个数据包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$Z0,400570,1#43</span><br></pre></td></tr></table></figure>
<p><code>$</code>标记着数据包的开始，<code>Z0</code>代表插入一个内存断点，<code>400570</code>和 <code>1</code>是参数，前者是断点设置的地址，后者是目标特定的断点类型说明符。<code>#43</code>是一个校验和，确保数据没有被损坏。</p>
<p>GDB远程协议非常容易扩展自定义数据包，这对实现平台或是语言特定的功能非常有用。</p>
<hr>
<h2 id="共享库和动态加载支持"><a href="#共享库和动态加载支持" class="headerlink" title="共享库和动态加载支持"></a>共享库和动态加载支持</h2><p>唯有当调试器知道被调试端加载了哪些共享库时，他才能设置断点，获取源码级的信息以及符号等。除了查找已经动态链接的库外，调试器还需要跟踪通过<code>dlopen</code>在运行时加载的库。为促进这一点，动态链接器会维护一个<em>对接结构体（rendezvous structure）</em>。这个结构体维护了一个共享库描述符的链表以及一个指向函数的指针，当链表被更新的时候这个指针指向的函数就会被调用。这个结构体存储在ELF文件的<code>.dynamic</code>节的加载处，在程序运行之前被初始化。</p>
<p>以下是一个简单的跟踪算法：</p>
<ul>
<li>跟踪器在ELF头部寻找程序的入口点（或通过存储在<code>/proc/&lt;pid&gt;/aux</code>中的辅助向量（auxillary vector））</li>
<li>跟踪器在程序的入口点设置断点并开始执行</li>
<li>当程序断下时，对接结构体的地址就可以通过查找ELF文件的<code>.dynamic</code>节的加载地址来找到</li>
<li>检查对接结构体以确认获取到的是正确的加载库的列表</li>
<li>在链接器更新函数上设置断点</li>
<li>当断点断下时，列表已经被更新了</li>
<li>跟踪器进入循环，继续执行程序等在被跟踪端发出退出的信号</li>
</ul>
<p>我写了一个小demo，你可以在<a href="https://github.com/TartanLlama/dltrace" target="_blank" rel="noopener">这里</a>找到。如果有人感兴趣，我可以在以后写一份更详细的。</p>
<hr>
<p>##表达式求值</p>
<p>表达式求值是一个能够让用户在调试期间用原始源语言对表达式进行求值的功能。举个例子，LLDB和GDB允许你执行<code>print foo()</code>来调用<code>foo</code>函数并打印结果。</p>
<p>根据表达式的复杂程度，有几种不同的求值方法。如果表达式只是一个简单的标识符，那么调试器可以查找调试信息，定位变量然后打印变量的值，就和前几篇一样。但如果表达式更复杂一点，那可能需要将代码编译成中间语言（IR）然后解释它得到结果。例如对某些表达式而言LLDB会使用Clang来将代码编译成LLVM IR并执行它。如果表达式比它更复杂，或需要调用某些函数，那么代码可能需要通过JIT解释并在被调试端的地址空间内执行。这将涉及到使用<code>mmap</code>来分配一些可执行的内存。LLDB使用LLVM的JIT功能来实现这些。</p>
<p>如果你想对JIT编译做更多了解，我高度推荐<a href="http://eli.thegreenplace.net/tag/code-generation" target="_blank" rel="noopener">Eli Bendersky的帖子</a>。</p>
<hr>
<h2 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h2><p>在这系列文章中的调试器只支持单线程调试，但在更加现实的调试过程中，多线程调试是非常需要的。最简单的实现方法是跟踪线程创建和解析进程文件系统（procfs）来获取你想得到的信息。</p>
<p>Linux的进程库叫做<code>pthreads</code>。当 <code>pthread_create</code>被调用时，进程库使用<code>clone</code>系统调用来创建一条新线程，因此我们可以使用<code>ptrace</code>来跟踪这个系统调用（假设你的内核版本低于2.5.46）。为此，你需要在<code>ptrace</code>附加到被调试端后设置一些选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_SETOPTIONS, m_pid, nullptr, PTRACE_O_TRACECLONE);</span><br></pre></td></tr></table></figure>
<p>现在当<code>clone</code>被调用时，将会发送我们熟悉的<code>SIGTRAP</code>信号。对于本系列文章中的调试器，你可以添加一个<code>handle_sigtrap</code>的case来处理新线程的创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case (SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; 8)):</span><br><span class="line">    //获取新的线程ID</span><br><span class="line">    unsigned long event_message = 0;</span><br><span class="line">    ptrace(PTRACE_GETEVENTMSG, pid, nullptr, message);</span><br><span class="line"></span><br><span class="line">    //处理线程的创建</span><br><span class="line">    //...</span><br></pre></td></tr></table></figure>
<p>这之后你可以查看<code>/proc/&lt;pid&gt;/task/</code>并读取memory maps来获取你所需的信息。</p>
<p>GDB使用<code>libthread_db</code>，它提供了一系列的帮助函数因此你不需要亲自完成所有的解释和处理。设置这个库的过程非常奇怪，因此我这里不会说他是怎么工作的，但如果你想使用你可以去看<a href="http://timetobleed.com/notes-about-an-odd-esoteric-yet-incredibly-useful-library-libthread_db/" target="_blank" rel="noopener">这篇教程</a>。</p>
<p>多线程中最复杂的部分是对调试器中的线程状态进行建模，特别是如果要支持不间断模式（<a href="https://sourceware.org/gdb/onlinedocs/gdb/Non_002dStop-Mode.html" target="_blank" rel="noopener">non-stop mode</a>）或某种异构调试（有不止一个CPU参与计算）。</p>
<hr>
<h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>呼！这系列文章花了我不少时间来写，但我也在这个过程中学到了不少东西。如果你想和我聊聊调试或是对这系列文章有任何疑问，你可以Twitter <a href="https://twitter.com/TartanLlama" target="_blank" rel="noopener">@TartanLlama</a>或是下方评论中联系我。如果你有其他关于调试的信息想发布你可以告诉我，我会发一个额外的帖子。</p>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Veritas501</li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://veritas501.github.io/2017/10/16/翻译_编写一个Linux调试器/" title="【翻译】编写一个Linux 调试器 （一）~（十）">https://veritas501.github.io/2017/10/16/翻译_编写一个Linux调试器/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Ptrace/" rel="tag"># Ptrace</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/08/CupHead茶杯头资源提取/" rel="next" title="CupHead茶杯头资源提取">
                <i class="fa fa-chevron-left"></i> CupHead茶杯头资源提取
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/05/2017上海大学生网络安全大赛_部分writeup/" rel="prev" title="2017上海大学生网络安全大赛 部分writeup">
                2017上海大学生网络安全大赛 部分writeup <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/215.png"
                alt="Veritas501" />
            
              <p class="site-author-name" itemprop="name">Veritas501</p>
              <p class="site-description motion-element" itemprop="description">开始踏上Re&Pwn之路...</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/veritas501" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://music.163.com/#/user/home?id=58295006" target="_blank" title="网易云"><i class="fa fa-fw fa-music"></i>网易云</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/xu-qt/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-quora"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://osu.ppy.sh/users/9533614" target="_blank" title="OSU"><i class="fa fa-fw fa-headphones"></i>OSU</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#（一）：准备工作"><span class="nav-number">1.</span> <span class="nav-text">（一）：准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行可执行文件"><span class="nav-number">1.2.</span> <span class="nav-text">运行可执行文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加调试器循环"><span class="nav-number">1.3.</span> <span class="nav-text">添加调试器循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理输入"><span class="nav-number">1.4.</span> <span class="nav-text">处理输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（二）：断点"><span class="nav-number">2.</span> <span class="nav-text">（二）：断点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#断点是怎么形成的？"><span class="nav-number">2.1.</span> <span class="nav-text">断点是怎么形成的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现内存断点"><span class="nav-number">2.2.</span> <span class="nav-text">实现内存断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给调试器添加断点"><span class="nav-number">2.3.</span> <span class="nav-text">给调试器添加断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从断点恢复执行"><span class="nav-number">2.4.</span> <span class="nav-text">从断点恢复执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试"><span class="nav-number">2.5.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（三）：内存和寄存器"><span class="nav-number">3.</span> <span class="nav-text">（三）：内存和寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#注册我们的寄存器"><span class="nav-number">3.1.</span> <span class="nav-text">注册我们的寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显示寄存器"><span class="nav-number">3.2.</span> <span class="nav-text">显示寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接下来干什么？"><span class="nav-number">3.3.</span> <span class="nav-text">接下来干什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给-continue-execution-做修补"><span class="nav-number">3.4.</span> <span class="nav-text">给 continue_execution 做修补</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-1"><span class="nav-number">3.5.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF-和-DWARF简介"><span class="nav-number">3.6.</span> <span class="nav-text">ELF 和 DWARF简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DWARF-行号表"><span class="nav-number">3.7.</span> <span class="nav-text">DWARF 行号表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DWARF调试信息"><span class="nav-number">3.8.</span> <span class="nav-text">DWARF调试信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我现在在哪个函数里？"><span class="nav-number">3.9.</span> <span class="nav-text">我现在在哪个函数里？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在函数上设置断点？"><span class="nav-number">3.10.</span> <span class="nav-text">如何在函数上设置断点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何读取变量的内容？"><span class="nav-number">3.11.</span> <span class="nav-text">如何读取变量的内容？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Take-a-breath"><span class="nav-number">3.12.</span> <span class="nav-text">Take a breath</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（五）：源码和信号"><span class="nav-number">4.</span> <span class="nav-text">（五）：源码和信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设置我们的DWARF解释器"><span class="nav-number">4.1.</span> <span class="nav-text">设置我们的DWARF解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印源码"><span class="nav-number">4.2.</span> <span class="nav-text">打印源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更好的信号处理"><span class="nav-number">4.3.</span> <span class="nav-text">更好的信号处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-2"><span class="nav-number">4.4.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（六）：源码级单步执行"><span class="nav-number">5.</span> <span class="nav-text">（六）：源码级单步执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指令级单步执行"><span class="nav-number">5.1.</span> <span class="nav-text">指令级单步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现单步执行"><span class="nav-number">5.2.</span> <span class="nav-text">实现单步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-3"><span class="nav-number">5.3.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（七）：源码级断点"><span class="nav-number">6.</span> <span class="nav-text">（七）：源码级断点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#断点"><span class="nav-number">6.1.</span> <span class="nav-text">断点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DWARF"><span class="nav-number">6.1.1.</span> <span class="nav-text">DWARF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数入口点"><span class="nav-number">6.1.2.</span> <span class="nav-text">函数入口点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码行"><span class="nav-number">6.1.3.</span> <span class="nav-text">源码行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号查找"><span class="nav-number">6.2.</span> <span class="nav-text">符号查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加命令"><span class="nav-number">6.3.</span> <span class="nav-text">添加命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-4"><span class="nav-number">6.4.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（八）：栈卷回"><span class="nav-number">7.</span> <span class="nav-text">（八）：栈卷回</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加命令-1"><span class="nav-number">7.1.</span> <span class="nav-text">添加命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-5"><span class="nav-number">7.2.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（九）：处理变量"><span class="nav-number">8.</span> <span class="nav-text">（九）：处理变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DWARF-位置信息"><span class="nav-number">8.1.</span> <span class="nav-text">DWARF 位置信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DWARF-表达式"><span class="nav-number">8.2.</span> <span class="nav-text">DWARF 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DWARF类型"><span class="nav-number">8.3.</span> <span class="nav-text">DWARF类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个简单的变量读取函数"><span class="nav-number">8.4.</span> <span class="nav-text">实现一个简单的变量读取函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-6"><span class="nav-number">8.5.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（十）：进阶话题"><span class="nav-number">9.</span> <span class="nav-text">（十）：进阶话题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#远程调试"><span class="nav-number">9.1.</span> <span class="nav-text">远程调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享库和动态加载支持"><span class="nav-number">9.2.</span> <span class="nav-text">共享库和动态加载支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程调试"><span class="nav-number">9.3.</span> <span class="nav-text">多线程调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-end"><span class="nav-number">9.4.</span> <span class="nav-text">The end</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Veritas501</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'zUGXRoho5JEFbk0lDKssrDi6-gzGzoHsz',
        appKey: 'IE9Knp7ku8I57kP5vFnPO2zA',
        placeholder: '说点什么...',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("97qzbH6lJuabRg1KDY7DtJRS-gzGzoHsz", "GS8vVhMCaeXncQF8mQOIShBj");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  

  


  
  

  

  

  

  

  

</body>
</html>
